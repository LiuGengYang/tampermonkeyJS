// ==UserScript==
// @name       hgj_environment_switcher
// @namespace  npm/vite-plugin-monkey
// @version    1.0.0
// @icon       https://vitejs.dev/logo.svg
// @match      http://localhost:8880/*
// @match      http://localhost:8899/*
// @match      *://*.hgj.com/*
// @match      *://*.smartai.hgj.com/*
// @require    https://cdn.jsdelivr.net/npm/vue@3.5.21/dist/vue.global.prod.js
// @grant      GM_addStyle
// @grant      GM_addValueChangeListener
// @grant      GM_cookie
// @grant      GM_deleteValue
// @grant      GM_getValue
// @grant      GM_openInTab
// @grant      GM_removeValueChangeListener
// @grant      GM_setClipboard
// @grant      GM_setValue
// @grant      unsafeWindow
// ==/UserScript==

(function (vue) {
  'use strict';

  const d=new Set;const importCSS = async e=>{d.has(e)||(d.add(e),(t=>{typeof GM_addStyle=="function"?GM_addStyle(t):document.head.appendChild(document.createElement("style")).append(t);})(e));};

  importCSS(" .quick-switch[data-v-f5224cf8]{width:220px;height:200px;border:1px solid #e5e7eb;border-radius:6px;font-family:system-ui,-apple-system,Helvetica Neue,Arial;background:#fff;box-shadow:0 1px 2px #1018280a;display:flex;flex-direction:column;overflow:hidden}.quick-switch__header[data-v-f5224cf8]{padding:8px 10px;background:linear-gradient(180deg,#f9fafb,#fff);border-bottom:1px solid #f1f5f9;font-size:13px;font-weight:600;color:#111827;display:flex;justify-content:center;align-items:center}.quick-switch__list[data-v-f5224cf8]{padding:6px;overflow-y:auto;flex:1 1 auto;display:flex;flex-direction:column;gap:6px}.quick-switch__item[data-v-f5224cf8]{display:flex;flex-direction:column;padding:6px;border-radius:4px;background:#fbfdff;border:1px solid transparent;transition:background .15s,border-color .15s;font-size:12px}.quick-switch__item[data-v-f5224cf8]:hover{background:#f1f5f9;border-color:#e6eef8}.item-top[data-v-f5224cf8]{display:flex;justify-content:space-between;align-items:center;gap:6px}.account-name[data-v-f5224cf8]{font-weight:600;color:#0f172a;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;max-width:75px;font-size:12px;display:flex;flex-direction:column;align-items:flex-start}.badge-account[data-v-f5224cf8]{font-size:11px;color:#374151;background:#eef2ff;padding:2px 6px;border-radius:999px}.item-bottom[data-v-f5224cf8]{display:flex;justify-content:space-between;align-items:center;margin-top:6px;gap:6px}.env[data-v-f5224cf8]{font-size:11px;color:#6b7280;padding:2px 6px}.session-indicator[data-v-f5224cf8]{font-size:11px;padding:2px 6px;border-radius:999px;background:#e5e7eb;color:#374151}.session-indicator.active[data-v-f5224cf8]{background:#10b981;color:#fff;box-shadow:0 1px #10b98126 inset}.quick-switch__list[data-v-f5224cf8]::-webkit-scrollbar{width:6px;height:6px}.quick-switch__list[data-v-f5224cf8]::-webkit-scrollbar-track{background:transparent}.quick-switch__list[data-v-f5224cf8]::-webkit-scrollbar-thumb{background:#e5e7eb;border-radius:10px}.options[data-v-f5224cf8]{display:flex;flex-direction:column;align-items:flex-end}.copyBtn[data-v-f5224cf8]{width:50px;height:20px;margin-top:10px}.el-button[data-v-d9ac85f1]{margin-left:0!important}.envOptions[data-v-d9ac85f1]{display:flex;flex-direction:column;padding:12px;z-index:9999;position:absolute}button[data-v-d9ac85f1]{width:120px;margin-top:8px}.quick-menu[data-v-d9ac85f1]{position:absolute;top:0;color:#000}.account-table[data-v-8f985f51]{margin-top:20px}.modal-content[data-v-d1d92ceb]{min-width:600px}.tab-content[data-v-d1d92ceb]{width:600px;height:500px;padding:0 20px}.env-switcher[data-v-e1bd9c12]{position:fixed;border-radius:50%;display:flex;justify-content:center;align-items:center;color:#fff;font-weight:700;cursor:move;z-index:99999;-webkit-user-select:none;user-select:none}.env-switcher-btn[data-v-e1bd9c12]{width:40px;height:40px;background-color:#4285f4;border-radius:50%;display:flex;justify-content:center;align-items:center;box-shadow:0 3px 12px #0000004d;-webkit-backdrop-filter:blur(5px);backdrop-filter:blur(5px);border:2px solid rgba(255,255,255,.3);cursor:pointer;position:absolute;left:0;top:0;z-index:99999}.account-icon[data-v-e1bd9c12]{position:absolute;right:-60px;top:-15px;cursor:pointer} ");

  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var require_main_001 = __commonJS({
    "main-DAvz3uUN.js"(exports, module) {
      /*!
       * pinia v3.0.3
       * (c) 2025 Eduardo San Martin Morote
       * @license MIT
       */
      let activePinia;
      const setActivePinia = (pinia) => activePinia = pinia;
      const piniaSymbol = (
Symbol()
      );
      function isPlainObject$1(o) {
        return o && typeof o === "object" && Object.prototype.toString.call(o) === "[object Object]" && typeof o.toJSON !== "function";
      }
      var MutationType;
      (function(MutationType2) {
        MutationType2["direct"] = "direct";
        MutationType2["patchObject"] = "patch object";
        MutationType2["patchFunction"] = "patch function";
      })(MutationType || (MutationType = {}));
      function createPinia() {
        const scope = vue.effectScope(true);
        const state = scope.run(() => vue.ref({}));
        let _p = [];
        let toBeInstalled = [];
        const pinia = vue.markRaw({
          install(app) {
            setActivePinia(pinia);
            pinia._a = app;
            app.provide(piniaSymbol, pinia);
            app.config.globalProperties.$pinia = pinia;
            toBeInstalled.forEach((plugin2) => _p.push(plugin2));
            toBeInstalled = [];
          },
          use(plugin2) {
            if (!this._a) {
              toBeInstalled.push(plugin2);
            } else {
              _p.push(plugin2);
            }
            return this;
          },
          _p,

_a: null,
          _e: scope,
          _s: new Map(),
          state
        });
        return pinia;
      }
      const noop = () => {
      };
      function addSubscription(subscriptions, callback, detached, onCleanup = noop) {
        subscriptions.push(callback);
        const removeSubscription = () => {
          const idx = subscriptions.indexOf(callback);
          if (idx > -1) {
            subscriptions.splice(idx, 1);
            onCleanup();
          }
        };
        if (!detached && vue.getCurrentScope()) {
          vue.onScopeDispose(removeSubscription);
        }
        return removeSubscription;
      }
      function triggerSubscriptions(subscriptions, ...args) {
        subscriptions.slice().forEach((callback) => {
          callback(...args);
        });
      }
      const fallbackRunWithContext = (fn) => fn();
      const ACTION_MARKER = Symbol();
      const ACTION_NAME = Symbol();
      function mergeReactiveObjects(target, patchToApply) {
        if (target instanceof Map && patchToApply instanceof Map) {
          patchToApply.forEach((value, key) => target.set(key, value));
        } else if (target instanceof Set && patchToApply instanceof Set) {
          patchToApply.forEach(target.add, target);
        }
        for (const key in patchToApply) {
          if (!patchToApply.hasOwnProperty(key))
            continue;
          const subPatch = patchToApply[key];
          const targetValue = target[key];
          if (isPlainObject$1(targetValue) && isPlainObject$1(subPatch) && target.hasOwnProperty(key) && !vue.isRef(subPatch) && !vue.isReactive(subPatch)) {
            target[key] = mergeReactiveObjects(targetValue, subPatch);
          } else {
            target[key] = subPatch;
          }
        }
        return target;
      }
      const skipHydrateSymbol = (
Symbol()
      );
      function shouldHydrate(obj) {
        return !isPlainObject$1(obj) || !Object.prototype.hasOwnProperty.call(obj, skipHydrateSymbol);
      }
      const { assign } = Object;
      function isComputed(o) {
        return !!(vue.isRef(o) && o.effect);
      }
      function createOptionsStore(id, options, pinia, hot) {
        const { state, actions, getters } = options;
        const initialState = pinia.state.value[id];
        let store;
        function setup2() {
          if (!initialState && true) {
            pinia.state.value[id] = state ? state() : {};
          }
          const localState = vue.toRefs(pinia.state.value[id]);
          return assign(localState, actions, Object.keys(getters || {}).reduce((computedGetters, name) => {
            computedGetters[name] = vue.markRaw(vue.computed(() => {
              setActivePinia(pinia);
              const store2 = pinia._s.get(id);
              return getters[name].call(store2, store2);
            }));
            return computedGetters;
          }, {}));
        }
        store = createSetupStore(id, setup2, options, pinia, hot, true);
        return store;
      }
      function createSetupStore($id, setup2, options = {}, pinia, hot, isOptionsStore) {
        let scope;
        const optionsForPlugin = assign({ actions: {} }, options);
        const $subscribeOptions = { deep: true };
        let isListening;
        let isSyncListening;
        let subscriptions = [];
        let actionSubscriptions = [];
        let debuggerEvents;
        const initialState = pinia.state.value[$id];
        if (!isOptionsStore && !initialState && true) {
          pinia.state.value[$id] = {};
        }
        vue.ref({});
        let activeListener;
        function $patch(partialStateOrMutator) {
          let subscriptionMutation;
          isListening = isSyncListening = false;
          if (typeof partialStateOrMutator === "function") {
            partialStateOrMutator(pinia.state.value[$id]);
            subscriptionMutation = {
              type: MutationType.patchFunction,
              storeId: $id,
              events: debuggerEvents
            };
          } else {
            mergeReactiveObjects(pinia.state.value[$id], partialStateOrMutator);
            subscriptionMutation = {
              type: MutationType.patchObject,
              payload: partialStateOrMutator,
              storeId: $id,
              events: debuggerEvents
            };
          }
          const myListenerId = activeListener = Symbol();
          vue.nextTick().then(() => {
            if (activeListener === myListenerId) {
              isListening = true;
            }
          });
          isSyncListening = true;
          triggerSubscriptions(subscriptions, subscriptionMutation, pinia.state.value[$id]);
        }
        const $reset = isOptionsStore ? function $reset2() {
          const { state } = options;
          const newState = state ? state() : {};
          this.$patch(($state) => {
            assign($state, newState);
          });
        } : (
noop
        );
        function $dispose() {
          scope.stop();
          subscriptions = [];
          actionSubscriptions = [];
          pinia._s.delete($id);
        }
        const action = (fn, name = "") => {
          if (ACTION_MARKER in fn) {
            fn[ACTION_NAME] = name;
            return fn;
          }
          const wrappedAction = function() {
            setActivePinia(pinia);
            const args = Array.from(arguments);
            const afterCallbackList = [];
            const onErrorCallbackList = [];
            function after(callback) {
              afterCallbackList.push(callback);
            }
            function onError(callback) {
              onErrorCallbackList.push(callback);
            }
            triggerSubscriptions(actionSubscriptions, {
              args,
              name: wrappedAction[ACTION_NAME],
              store,
              after,
              onError
            });
            let ret;
            try {
              ret = fn.apply(this && this.$id === $id ? this : store, args);
            } catch (error) {
              triggerSubscriptions(onErrorCallbackList, error);
              throw error;
            }
            if (ret instanceof Promise) {
              return ret.then((value) => {
                triggerSubscriptions(afterCallbackList, value);
                return value;
              }).catch((error) => {
                triggerSubscriptions(onErrorCallbackList, error);
                return Promise.reject(error);
              });
            }
            triggerSubscriptions(afterCallbackList, ret);
            return ret;
          };
          wrappedAction[ACTION_MARKER] = true;
          wrappedAction[ACTION_NAME] = name;
          return wrappedAction;
        };
        const partialStore = {
          _p: pinia,
$id,
          $onAction: addSubscription.bind(null, actionSubscriptions),
          $patch,
          $reset,
          $subscribe(callback, options2 = {}) {
            const removeSubscription = addSubscription(subscriptions, callback, options2.detached, () => stopWatcher());
            const stopWatcher = scope.run(() => vue.watch(() => pinia.state.value[$id], (state) => {
              if (options2.flush === "sync" ? isSyncListening : isListening) {
                callback({
                  storeId: $id,
                  type: MutationType.direct,
                  events: debuggerEvents
                }, state);
              }
            }, assign({}, $subscribeOptions, options2)));
            return removeSubscription;
          },
          $dispose
        };
        const store = vue.reactive(partialStore);
        pinia._s.set($id, store);
        const runWithContext = pinia._a && pinia._a.runWithContext || fallbackRunWithContext;
        const setupStore = runWithContext(() => pinia._e.run(() => (scope = vue.effectScope()).run(() => setup2({ action }))));
        for (const key in setupStore) {
          const prop = setupStore[key];
          if (vue.isRef(prop) && !isComputed(prop) || vue.isReactive(prop)) {
            if (!isOptionsStore) {
              if (initialState && shouldHydrate(prop)) {
                if (vue.isRef(prop)) {
                  prop.value = initialState[key];
                } else {
                  mergeReactiveObjects(prop, initialState[key]);
                }
              }
              pinia.state.value[$id][key] = prop;
            }
          } else if (typeof prop === "function") {
            const actionValue = action(prop, key);
            setupStore[key] = actionValue;
            optionsForPlugin.actions[key] = prop;
          } else ;
        }
        assign(store, setupStore);
        assign(vue.toRaw(store), setupStore);
        Object.defineProperty(store, "$state", {
          get: () => pinia.state.value[$id],
          set: (state) => {
            $patch(($state) => {
              assign($state, state);
            });
          }
        });
        pinia._p.forEach((extender) => {
          {
            assign(store, scope.run(() => extender({
              store,
              app: pinia._a,
              pinia,
              options: optionsForPlugin
            })));
          }
        });
        if (initialState && isOptionsStore && options.hydrate) {
          options.hydrate(store.$state, initialState);
        }
        isListening = true;
        isSyncListening = true;
        return store;
      }

function defineStore(id, setup2, setupOptions) {
        let options;
        const isSetupStore = typeof setup2 === "function";
        options = isSetupStore ? setupOptions : setup2;
        function useStore(pinia, hot) {
          const hasContext = vue.hasInjectionContext();
          pinia =

pinia || (hasContext ? vue.inject(piniaSymbol, null) : null);
          if (pinia)
            setActivePinia(pinia);
          pinia = activePinia;
          if (!pinia._s.has(id)) {
            if (isSetupStore) {
              createSetupStore(id, setup2, options, pinia);
            } else {
              createOptionsStore(id, options, pinia);
            }
          }
          const store = pinia._s.get(id);
          return store;
        }
        useStore.$id = id;
        return useStore;
      }
      var _GM_addValueChangeListener = (() => typeof GM_addValueChangeListener != "undefined" ? GM_addValueChangeListener : void 0)();
      var _GM_cookie = (() => typeof GM_cookie != "undefined" ? GM_cookie : void 0)();
      var _GM_deleteValue = (() => typeof GM_deleteValue != "undefined" ? GM_deleteValue : void 0)();
      var _GM_getValue = (() => typeof GM_getValue != "undefined" ? GM_getValue : void 0)();
      var _GM_openInTab = (() => typeof GM_openInTab != "undefined" ? GM_openInTab : void 0)();
      var _GM_removeValueChangeListener = (() => typeof GM_removeValueChangeListener != "undefined" ? GM_removeValueChangeListener : void 0)();
      var _GM_setClipboard = (() => typeof GM_setClipboard != "undefined" ? GM_setClipboard : void 0)();
      var _GM_setValue = (() => typeof GM_setValue != "undefined" ? GM_setValue : void 0)();
      var _unsafeWindow = (() => typeof unsafeWindow != "undefined" ? unsafeWindow : void 0)();
      function plugin$1(options) {
        let _bPrefix = ".";
        let _ePrefix = "__";
        let _mPrefix = "--";
        let c2;
        if (options) {
          let t = options.blockPrefix;
          if (t) {
            _bPrefix = t;
          }
          t = options.elementPrefix;
          if (t) {
            _ePrefix = t;
          }
          t = options.modifierPrefix;
          if (t) {
            _mPrefix = t;
          }
        }
        const _plugin = {
          install(instance) {
            c2 = instance.c;
            const ctx2 = instance.context;
            ctx2.bem = {};
            ctx2.bem.b = null;
            ctx2.bem.els = null;
          }
        };
        function b(arg) {
          let memorizedB;
          let memorizedE;
          return {
            before(ctx2) {
              memorizedB = ctx2.bem.b;
              memorizedE = ctx2.bem.els;
              ctx2.bem.els = null;
            },
            after(ctx2) {
              ctx2.bem.b = memorizedB;
              ctx2.bem.els = memorizedE;
            },
            $({ context, props }) {
              arg = typeof arg === "string" ? arg : arg({ context, props });
              context.bem.b = arg;
              return `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}`;
            }
          };
        }
        function e(arg) {
          let memorizedE;
          return {
            before(ctx2) {
              memorizedE = ctx2.bem.els;
            },
            after(ctx2) {
              ctx2.bem.els = memorizedE;
            },
            $({ context, props }) {
              arg = typeof arg === "string" ? arg : arg({ context, props });
              context.bem.els = arg.split(",").map((v) => v.trim());
              return context.bem.els.map((el) => `${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${_ePrefix}${el}`).join(", ");
            }
          };
        }
        function m(arg) {
          return {
            $({ context, props }) {
              arg = typeof arg === "string" ? arg : arg({ context, props });
              const modifiers = arg.split(",").map((v) => v.trim());
              function elementToSelector(el) {
                return modifiers.map((modifier) => `&${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${el !== void 0 ? `${_ePrefix}${el}` : ""}${_mPrefix}${modifier}`).join(", ");
              }
              const els = context.bem.els;
              if (els !== null) {
                return elementToSelector(els[0]);
              } else {
                return elementToSelector();
              }
            }
          };
        }
        function notM(arg) {
          return {
            $({ context, props }) {
              arg = typeof arg === "string" ? arg : arg({ context, props });
              const els = context.bem.els;
              return `&:not(${(props === null || props === void 0 ? void 0 : props.bPrefix) || _bPrefix}${context.bem.b}${els !== null && els.length > 0 ? `${_ePrefix}${els[0]}` : ""}${_mPrefix}${arg})`;
            }
          };
        }
        const cB2 = ((...args) => c2(b(args[0]), args[1], args[2]));
        const cE2 = ((...args) => c2(e(args[0]), args[1], args[2]));
        const cM2 = ((...args) => c2(m(args[0]), args[1], args[2]));
        const cNotM2 = ((...args) => c2(notM(args[0]), args[1], args[2]));
        Object.assign(_plugin, {
          cB: cB2,
          cE: cE2,
          cM: cM2,
          cNotM: cNotM2
        });
        return _plugin;
      }
      function ampCount(selector) {
        let cnt = 0;
        for (let i = 0; i < selector.length; ++i) {
          if (selector[i] === "&")
            ++cnt;
        }
        return cnt;
      }
      const separatorRegex = /\s*,(?![^(]*\))\s*/g;
      const extraSpaceRegex = /\s+/g;
      function resolveSelectorWithAmp(amp, selector) {
        const nextAmp = [];
        selector.split(separatorRegex).forEach((partialSelector) => {
          let round = ampCount(partialSelector);
          if (!round) {
            amp.forEach((partialAmp) => {
              nextAmp.push(
(partialAmp && partialAmp + " ") + partialSelector
              );
            });
            return;
          } else if (round === 1) {
            amp.forEach((partialAmp) => {
              nextAmp.push(partialSelector.replace("&", partialAmp));
            });
            return;
          }
          let partialNextAmp = [
            partialSelector
          ];
          while (round--) {
            const nextPartialNextAmp = [];
            partialNextAmp.forEach((selectorItr) => {
              amp.forEach((partialAmp) => {
                nextPartialNextAmp.push(selectorItr.replace("&", partialAmp));
              });
            });
            partialNextAmp = nextPartialNextAmp;
          }
          partialNextAmp.forEach((part) => nextAmp.push(part));
        });
        return nextAmp;
      }
      function resolveSelector(amp, selector) {
        const nextAmp = [];
        selector.split(separatorRegex).forEach((partialSelector) => {
          amp.forEach((partialAmp) => {
            nextAmp.push((partialAmp && partialAmp + " ") + partialSelector);
          });
        });
        return nextAmp;
      }
      function parseSelectorPath(selectorPaths) {
        let amp = [""];
        selectorPaths.forEach((selector) => {
          selector = selector && selector.trim();
          if (
!selector
          ) {
            return;
          }
          if (selector.includes("&")) {
            amp = resolveSelectorWithAmp(amp, selector);
          } else {
            amp = resolveSelector(amp, selector);
          }
        });
        return amp.join(", ").replace(extraSpaceRegex, " ");
      }
      function removeElement(el) {
        if (!el)
          return;
        const parentElement = el.parentElement;
        if (parentElement)
          parentElement.removeChild(el);
      }
      function queryElement(id, parent) {
        return (parent !== null && parent !== void 0 ? parent : document.head).querySelector(`style[cssr-id="${id}"]`);
      }
      function createElement(id) {
        const el = document.createElement("style");
        el.setAttribute("cssr-id", id);
        return el;
      }
      function isMediaOrSupports(selector) {
        if (!selector)
          return false;
        return /^\s*@(s|m)/.test(selector);
      }
      const kebabRegex = /[A-Z]/g;
      function kebabCase(pattern) {
        return pattern.replace(kebabRegex, (match2) => "-" + match2.toLowerCase());
      }
      function unwrapProperty(prop, indent = "  ") {
        if (typeof prop === "object" && prop !== null) {
          return " {\n" + Object.entries(prop).map((v) => {
            return indent + `  ${kebabCase(v[0])}: ${v[1]};`;
          }).join("\n") + "\n" + indent + "}";
        }
        return `: ${prop};`;
      }
      function unwrapProperties(props, instance, params) {
        if (typeof props === "function") {
          return props({
            context: instance.context,
            props: params
          });
        }
        return props;
      }
      function createStyle(selector, props, instance, params) {
        if (!props)
          return "";
        const unwrappedProps = unwrapProperties(props, instance, params);
        if (!unwrappedProps)
          return "";
        if (typeof unwrappedProps === "string") {
          return `${selector} {
${unwrappedProps}
}`;
        }
        const propertyNames = Object.keys(unwrappedProps);
        if (propertyNames.length === 0) {
          if (instance.config.keepEmptyBlock)
            return selector + " {\n}";
          return "";
        }
        const statements = selector ? [
          selector + " {"
        ] : [];
        propertyNames.forEach((propertyName) => {
          const property2 = unwrappedProps[propertyName];
          if (propertyName === "raw") {
            statements.push("\n" + property2 + "\n");
            return;
          }
          propertyName = kebabCase(propertyName);
          if (property2 !== null && property2 !== void 0) {
            statements.push(`  ${propertyName}${unwrapProperty(property2)}`);
          }
        });
        if (selector) {
          statements.push("}");
        }
        return statements.join("\n");
      }
      function loopCNodeListWithCallback(children, options, callback) {
        if (!children)
          return;
        children.forEach((child) => {
          if (Array.isArray(child)) {
            loopCNodeListWithCallback(child, options, callback);
          } else if (typeof child === "function") {
            const grandChildren = child(options);
            if (Array.isArray(grandChildren)) {
              loopCNodeListWithCallback(grandChildren, options, callback);
            } else if (grandChildren) {
              callback(grandChildren);
            }
          } else if (child) {
            callback(child);
          }
        });
      }
      function traverseCNode(node, selectorPaths, styles2, instance, params) {
        const $ = node.$;
        let blockSelector = "";
        if (!$ || typeof $ === "string") {
          if (isMediaOrSupports($)) {
            blockSelector = $;
          } else {
            selectorPaths.push($);
          }
        } else if (typeof $ === "function") {
          const selector2 = $({
            context: instance.context,
            props: params
          });
          if (isMediaOrSupports(selector2)) {
            blockSelector = selector2;
          } else {
            selectorPaths.push(selector2);
          }
        } else {
          if ($.before)
            $.before(instance.context);
          if (!$.$ || typeof $.$ === "string") {
            if (isMediaOrSupports($.$)) {
              blockSelector = $.$;
            } else {
              selectorPaths.push($.$);
            }
          } else if ($.$) {
            const selector2 = $.$({
              context: instance.context,
              props: params
            });
            if (isMediaOrSupports(selector2)) {
              blockSelector = selector2;
            } else {
              selectorPaths.push(selector2);
            }
          }
        }
        const selector = parseSelectorPath(selectorPaths);
        const style2 = createStyle(selector, node.props, instance, params);
        if (blockSelector) {
          styles2.push(`${blockSelector} {`);
        } else if (style2.length) {
          styles2.push(style2);
        }
        if (node.children) {
          loopCNodeListWithCallback(node.children, {
            context: instance.context,
            props: params
          }, (childNode) => {
            if (typeof childNode === "string") {
              const style3 = createStyle(selector, { raw: childNode }, instance, params);
              styles2.push(style3);
            } else {
              traverseCNode(childNode, selectorPaths, styles2, instance, params);
            }
          });
        }
        selectorPaths.pop();
        if (blockSelector) {
          styles2.push("}");
        }
        if ($ && $.after)
          $.after(instance.context);
      }
      function render$1(node, instance, props) {
        const styles2 = [];
        traverseCNode(node, [], styles2, instance, props);
        return styles2.join("\n\n");
      }
      function murmur2(str) {
        var h2 = 0;
        var k, i = 0, len2 = str.length;
        for (; len2 >= 4; ++i, len2 -= 4) {
          k = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
          k =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16);
          k ^=
k >>> 24;
          h2 =
(k & 65535) * 1540483477 + ((k >>> 16) * 59797 << 16) ^
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        }
        switch (len2) {
          case 3:
            h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
          case 2:
            h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
          case 1:
            h2 ^= str.charCodeAt(i) & 255;
            h2 =
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        }
        h2 ^= h2 >>> 13;
        h2 =
(h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
        return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
      }
      if (typeof window !== "undefined") {
        window.__cssrContext = {};
      }
      function unmount(instance, node, id, parent) {
        const { els } = node;
        if (id === void 0) {
          els.forEach(removeElement);
          node.els = [];
        } else {
          const target = queryElement(id, parent);
          if (target && els.includes(target)) {
            removeElement(target);
            node.els = els.filter((el) => el !== target);
          }
        }
      }
      function addElementToList(els, target) {
        els.push(target);
      }
      function mount(instance, node, id, props, head, force, anchorMetaName, parent, ssrAdapter2) {
        let style2;
        if (id === void 0) {
          style2 = node.render(props);
          id = murmur2(style2);
        }
        if (ssrAdapter2) {
          ssrAdapter2.adapter(id, style2 !== null && style2 !== void 0 ? style2 : node.render(props));
          return;
        }
        if (parent === void 0) {
          parent = document.head;
        }
        const queriedTarget = queryElement(id, parent);
        if (queriedTarget !== null && !force) {
          return queriedTarget;
        }
        const target = queriedTarget !== null && queriedTarget !== void 0 ? queriedTarget : createElement(id);
        if (style2 === void 0)
          style2 = node.render(props);
        target.textContent = style2;
        if (queriedTarget !== null)
          return queriedTarget;
        if (anchorMetaName) {
          const anchorMetaEl = parent.querySelector(`meta[name="${anchorMetaName}"]`);
          if (anchorMetaEl) {
            parent.insertBefore(target, anchorMetaEl);
            addElementToList(node.els, target);
            return target;
          }
        }
        if (head) {
          parent.insertBefore(target, parent.querySelector("style, link"));
        } else {
          parent.appendChild(target);
        }
        addElementToList(node.els, target);
        return target;
      }
      function wrappedRender(props) {
        return render$1(this, this.instance, props);
      }
      function wrappedMount(options = {}) {
        const { id, ssr, props, head = false, force = false, anchorMetaName, parent } = options;
        const targetElement = mount(this.instance, this, id, props, head, force, anchorMetaName, parent, ssr);
        return targetElement;
      }
      function wrappedUnmount(options = {}) {
        const { id, parent } = options;
        unmount(this.instance, this, id, parent);
      }
      const createCNode = function(instance, $, props, children) {
        return {
          instance,
          $,
          props,
          children,
          els: [],
          render: wrappedRender,
          mount: wrappedMount,
          unmount: wrappedUnmount
        };
      };
      const c$2 = function(instance, $, props, children) {
        if (Array.isArray($)) {
          return createCNode(instance, { $: null }, null, $);
        } else if (Array.isArray(props)) {
          return createCNode(instance, $, null, props);
        } else if (Array.isArray(children)) {
          return createCNode(instance, $, props, children);
        } else {
          return createCNode(instance, $, props, null);
        }
      };
      function CssRender(config = {}) {
        const cssr2 = {
          c: ((...args) => c$2(cssr2, ...args)),
          use: (plugin2, ...args) => plugin2.install(cssr2, ...args),
          find: queryElement,
          context: {},
          config
        };
        return cssr2;
      }
      function exists(id, ssr) {
        if (id === void 0)
          return false;
        if (ssr) {
          const { context: { ids } } = ssr;
          return ids.has(id);
        }
        return queryElement(id) !== null;
      }
      const namespace = "n";
      const prefix$1 = `.${namespace}-`;
      const elementPrefix = "__";
      const modifierPrefix = "--";
      const cssr = CssRender();
      const plugin = plugin$1({
        blockPrefix: prefix$1,
        elementPrefix,
        modifierPrefix
      });
      cssr.use(plugin);
      const {
        c: c$1,
        find
      } = cssr;
      const {
        cB,
        cE,
        cM,
        cNotM
      } = plugin;
      function insideModal(style2) {
        return c$1(({
          props: {
            bPrefix
          }
        }) => `${bPrefix || prefix$1}modal, ${bPrefix || prefix$1}drawer`, [style2]);
      }
      function insidePopover(style2) {
        return c$1(({
          props: {
            bPrefix
          }
        }) => `${bPrefix || prefix$1}popover`, [style2]);
      }
      function asModal(style2) {
        return c$1(({
          props: {
            bPrefix
          }
        }) => `&${bPrefix || prefix$1}modal`, style2);
      }
      const cCB = (...args) => {
        return c$1(">", [cB(...args)]);
      };
      function createKey(prefix2, suffix2) {
        return prefix2 + (suffix2 === "default" ? "" : suffix2.replace(/^[a-z]/, (startChar) => startChar.toUpperCase()));
      }
      let onceCbs = [];
      const paramsMap = new WeakMap();
      function flushOnceCallbacks() {
        onceCbs.forEach((cb) => cb(...paramsMap.get(cb)));
        onceCbs = [];
      }
      function beforeNextFrameOnce(cb, ...params) {
        paramsMap.set(cb, params);
        if (onceCbs.includes(cb))
          return;
        onceCbs.push(cb) === 1 && requestAnimationFrame(flushOnceCallbacks);
      }
      function happensIn(e, dataSetPropName) {
        let { target } = e;
        while (target) {
          if (target.dataset) {
            if (target.dataset[dataSetPropName] !== void 0)
              return true;
          }
          target = target.parentElement;
        }
        return false;
      }
      function getPreciseEventTarget(event) {
        return event.composedPath()[0] || null;
      }
      function depx(value) {
        if (typeof value === "string") {
          if (value.endsWith("px")) {
            return Number(value.slice(0, value.length - 2));
          }
          return Number(value);
        }
        return value;
      }
      function pxfy(value) {
        if (value === void 0 || value === null)
          return void 0;
        if (typeof value === "number")
          return `${value}px`;
        if (value.endsWith("px"))
          return value;
        return `${value}px`;
      }
      function getMargin(value, position) {
        const parts = value.trim().split(/\s+/g);
        const margin = {
          top: parts[0]
        };
        switch (parts.length) {
          case 1:
            margin.right = parts[0];
            margin.bottom = parts[0];
            margin.left = parts[0];
            break;
          case 2:
            margin.right = parts[1];
            margin.left = parts[1];
            margin.bottom = parts[0];
            break;
          case 3:
            margin.right = parts[1];
            margin.bottom = parts[2];
            margin.left = parts[1];
            break;
          case 4:
            margin.right = parts[1];
            margin.bottom = parts[2];
            margin.left = parts[3];
            break;
          default:
            throw new Error("[seemly/getMargin]:" + value + " is not a valid value.");
        }
        if (position === void 0)
          return margin;
        return margin[position];
      }
      function getGap(value, orient) {
        const [rowGap, colGap] = value.split(" ");
        return {
          row: rowGap,
          col: colGap || rowGap
        };
      }
      const colors = {
        aliceblue: "#F0F8FF",
        antiquewhite: "#FAEBD7",
        aqua: "#0FF",
        aquamarine: "#7FFFD4",
        azure: "#F0FFFF",
        beige: "#F5F5DC",
        bisque: "#FFE4C4",
        black: "#000",
        blanchedalmond: "#FFEBCD",
        blue: "#00F",
        blueviolet: "#8A2BE2",
        brown: "#A52A2A",
        burlywood: "#DEB887",
        cadetblue: "#5F9EA0",
        chartreuse: "#7FFF00",
        chocolate: "#D2691E",
        coral: "#FF7F50",
        cornflowerblue: "#6495ED",
        cornsilk: "#FFF8DC",
        crimson: "#DC143C",
        cyan: "#0FF",
        darkblue: "#00008B",
        darkcyan: "#008B8B",
        darkgoldenrod: "#B8860B",
        darkgray: "#A9A9A9",
        darkgrey: "#A9A9A9",
        darkgreen: "#006400",
        darkkhaki: "#BDB76B",
        darkmagenta: "#8B008B",
        darkolivegreen: "#556B2F",
        darkorange: "#FF8C00",
        darkorchid: "#9932CC",
        darkred: "#8B0000",
        darksalmon: "#E9967A",
        darkseagreen: "#8FBC8F",
        darkslateblue: "#483D8B",
        darkslategray: "#2F4F4F",
        darkslategrey: "#2F4F4F",
        darkturquoise: "#00CED1",
        darkviolet: "#9400D3",
        deeppink: "#FF1493",
        deepskyblue: "#00BFFF",
        dimgray: "#696969",
        dimgrey: "#696969",
        dodgerblue: "#1E90FF",
        firebrick: "#B22222",
        floralwhite: "#FFFAF0",
        forestgreen: "#228B22",
        fuchsia: "#F0F",
        gainsboro: "#DCDCDC",
        ghostwhite: "#F8F8FF",
        gold: "#FFD700",
        goldenrod: "#DAA520",
        gray: "#808080",
        grey: "#808080",
        green: "#008000",
        greenyellow: "#ADFF2F",
        honeydew: "#F0FFF0",
        hotpink: "#FF69B4",
        indianred: "#CD5C5C",
        indigo: "#4B0082",
        ivory: "#FFFFF0",
        khaki: "#F0E68C",
        lavender: "#E6E6FA",
        lavenderblush: "#FFF0F5",
        lawngreen: "#7CFC00",
        lemonchiffon: "#FFFACD",
        lightblue: "#ADD8E6",
        lightcoral: "#F08080",
        lightcyan: "#E0FFFF",
        lightgoldenrodyellow: "#FAFAD2",
        lightgray: "#D3D3D3",
        lightgrey: "#D3D3D3",
        lightgreen: "#90EE90",
        lightpink: "#FFB6C1",
        lightsalmon: "#FFA07A",
        lightseagreen: "#20B2AA",
        lightskyblue: "#87CEFA",
        lightslategray: "#778899",
        lightslategrey: "#778899",
        lightsteelblue: "#B0C4DE",
        lightyellow: "#FFFFE0",
        lime: "#0F0",
        limegreen: "#32CD32",
        linen: "#FAF0E6",
        magenta: "#F0F",
        maroon: "#800000",
        mediumaquamarine: "#66CDAA",
        mediumblue: "#0000CD",
        mediumorchid: "#BA55D3",
        mediumpurple: "#9370DB",
        mediumseagreen: "#3CB371",
        mediumslateblue: "#7B68EE",
        mediumspringgreen: "#00FA9A",
        mediumturquoise: "#48D1CC",
        mediumvioletred: "#C71585",
        midnightblue: "#191970",
        mintcream: "#F5FFFA",
        mistyrose: "#FFE4E1",
        moccasin: "#FFE4B5",
        navajowhite: "#FFDEAD",
        navy: "#000080",
        oldlace: "#FDF5E6",
        olive: "#808000",
        olivedrab: "#6B8E23",
        orange: "#FFA500",
        orangered: "#FF4500",
        orchid: "#DA70D6",
        palegoldenrod: "#EEE8AA",
        palegreen: "#98FB98",
        paleturquoise: "#AFEEEE",
        palevioletred: "#DB7093",
        papayawhip: "#FFEFD5",
        peachpuff: "#FFDAB9",
        peru: "#CD853F",
        pink: "#FFC0CB",
        plum: "#DDA0DD",
        powderblue: "#B0E0E6",
        purple: "#800080",
        rebeccapurple: "#663399",
        red: "#F00",
        rosybrown: "#BC8F8F",
        royalblue: "#4169E1",
        saddlebrown: "#8B4513",
        salmon: "#FA8072",
        sandybrown: "#F4A460",
        seagreen: "#2E8B57",
        seashell: "#FFF5EE",
        sienna: "#A0522D",
        silver: "#C0C0C0",
        skyblue: "#87CEEB",
        slateblue: "#6A5ACD",
        slategray: "#708090",
        slategrey: "#708090",
        snow: "#FFFAFA",
        springgreen: "#00FF7F",
        steelblue: "#4682B4",
        tan: "#D2B48C",
        teal: "#008080",
        thistle: "#D8BFD8",
        tomato: "#FF6347",
        turquoise: "#40E0D0",
        violet: "#EE82EE",
        wheat: "#F5DEB3",
        white: "#FFF",
        whitesmoke: "#F5F5F5",
        yellow: "#FF0",
        yellowgreen: "#9ACD32",
        transparent: "#0000"
      };
      function hsv2rgb(h2, s, v) {
        s /= 100;
        v /= 100;
        let f = (n, k = (n + h2 / 60) % 6) => v - v * s * Math.max(Math.min(k, 4 - k, 1), 0);
        return [f(5) * 255, f(3) * 255, f(1) * 255];
      }
      function hsl2rgb(h2, s, l) {
        s /= 100;
        l /= 100;
        let a = s * Math.min(l, 1 - l);
        let f = (n, k = (n + h2 / 30) % 12) => l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
        return [f(0) * 255, f(8) * 255, f(4) * 255];
      }
      const prefix = "^\\s*";
      const suffix = "\\s*$";
      const percent = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))%\\s*";
      const float = "\\s*((\\.\\d+)|(\\d+(\\.\\d*)?))\\s*";
      const hex = "([0-9A-Fa-f])";
      const dhex = "([0-9A-Fa-f]{2})";
      const hslRegex = new RegExp(`${prefix}hsl\\s*\\(${float},${percent},${percent}\\)${suffix}`);
      const hsvRegex = new RegExp(`${prefix}hsv\\s*\\(${float},${percent},${percent}\\)${suffix}`);
      const hslaRegex = new RegExp(`${prefix}hsla\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
      const hsvaRegex = new RegExp(`${prefix}hsva\\s*\\(${float},${percent},${percent},${float}\\)${suffix}`);
      const rgbRegex = new RegExp(`${prefix}rgb\\s*\\(${float},${float},${float}\\)${suffix}`);
      const rgbaRegex = new RegExp(`${prefix}rgba\\s*\\(${float},${float},${float},${float}\\)${suffix}`);
      const sHexRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${suffix}`);
      const hexRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${suffix}`);
      const sHexaRegex = new RegExp(`${prefix}#${hex}${hex}${hex}${hex}${suffix}`);
      const hexaRegex = new RegExp(`${prefix}#${dhex}${dhex}${dhex}${dhex}${suffix}`);
      function parseHex(value) {
        return parseInt(value, 16);
      }
      function hsla(color) {
        try {
          let i;
          if (i = hslaRegex.exec(color)) {
            return [
              roundDeg(i[1]),
              roundPercent(i[5]),
              roundPercent(i[9]),
              roundAlpha(i[13])
            ];
          } else if (i = hslRegex.exec(color)) {
            return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
          }
          throw new Error(`[seemly/hsla]: Invalid color value ${color}.`);
        } catch (e) {
          throw e;
        }
      }
      function hsva(color) {
        try {
          let i;
          if (i = hsvaRegex.exec(color)) {
            return [
              roundDeg(i[1]),
              roundPercent(i[5]),
              roundPercent(i[9]),
              roundAlpha(i[13])
            ];
          } else if (i = hsvRegex.exec(color)) {
            return [roundDeg(i[1]), roundPercent(i[5]), roundPercent(i[9]), 1];
          }
          throw new Error(`[seemly/hsva]: Invalid color value ${color}.`);
        } catch (e) {
          throw e;
        }
      }
      function rgba(color) {
        try {
          let i;
          if (i = hexRegex.exec(color)) {
            return [parseHex(i[1]), parseHex(i[2]), parseHex(i[3]), 1];
          } else if (i = rgbRegex.exec(color)) {
            return [roundChannel(i[1]), roundChannel(i[5]), roundChannel(i[9]), 1];
          } else if (i = rgbaRegex.exec(color)) {
            return [
              roundChannel(i[1]),
              roundChannel(i[5]),
              roundChannel(i[9]),
              roundAlpha(i[13])
            ];
          } else if (i = sHexRegex.exec(color)) {
            return [
              parseHex(i[1] + i[1]),
              parseHex(i[2] + i[2]),
              parseHex(i[3] + i[3]),
              1
            ];
          } else if (i = hexaRegex.exec(color)) {
            return [
              parseHex(i[1]),
              parseHex(i[2]),
              parseHex(i[3]),
              roundAlpha(parseHex(i[4]) / 255)
            ];
          } else if (i = sHexaRegex.exec(color)) {
            return [
              parseHex(i[1] + i[1]),
              parseHex(i[2] + i[2]),
              parseHex(i[3] + i[3]),
              roundAlpha(parseHex(i[4] + i[4]) / 255)
            ];
          } else if (color in colors) {
            return rgba(colors[color]);
          } else if (hslRegex.test(color) || hslaRegex.test(color)) {
            const [h2, s, l, a] = hsla(color);
            return [...hsl2rgb(h2, s, l), a];
          } else if (hsvRegex.test(color) || hsvaRegex.test(color)) {
            const [h2, s, v, a] = hsva(color);
            return [...hsv2rgb(h2, s, v), a];
          }
          throw new Error(`[seemly/rgba]: Invalid color value ${color}.`);
        } catch (e) {
          throw e;
        }
      }
      function normalizeAlpha(alphaValue) {
        return alphaValue > 1 ? 1 : alphaValue < 0 ? 0 : alphaValue;
      }
      function stringifyRgba(r, g, b, a) {
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${normalizeAlpha(a)})`;
      }
      function compositeChannel(v1, a1, v2, a2, a) {
        return roundChannel((v1 * a1 * (1 - a2) + v2 * a2) / a);
      }
      function composite(background, overlay2) {
        if (!Array.isArray(background))
          background = rgba(background);
        if (!Array.isArray(overlay2))
          overlay2 = rgba(overlay2);
        const a1 = background[3];
        const a2 = overlay2[3];
        const alpha = roundAlpha(a1 + a2 - a1 * a2);
        return stringifyRgba(compositeChannel(background[0], a1, overlay2[0], a2, alpha), compositeChannel(background[1], a1, overlay2[1], a2, alpha), compositeChannel(background[2], a1, overlay2[2], a2, alpha), alpha);
      }
      function changeColor(base2, options) {
        const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
        if (typeof options.alpha === "number") {
          return stringifyRgba(r, g, b, options.alpha);
        }
        return stringifyRgba(r, g, b, a);
      }
      function scaleColor(base2, options) {
        const [r, g, b, a = 1] = Array.isArray(base2) ? base2 : rgba(base2);
        const { lightness = 1, alpha = 1 } = options;
        return toRgbaString([r * lightness, g * lightness, b * lightness, a * alpha]);
      }
      function roundAlpha(value) {
        const v = Math.round(Number(value) * 100) / 100;
        if (v > 1)
          return 1;
        if (v < 0)
          return 0;
        return v;
      }
      function roundDeg(value) {
        const v = Math.round(Number(value));
        if (v >= 360)
          return 0;
        if (v < 0)
          return 0;
        return v;
      }
      function roundChannel(value) {
        const v = Math.round(Number(value));
        if (v > 255)
          return 255;
        if (v < 0)
          return 0;
        return v;
      }
      function roundPercent(value) {
        const v = Math.round(Number(value));
        if (v > 100)
          return 100;
        if (v < 0)
          return 0;
        return v;
      }
      function toRgbaString(base2) {
        const [r, g, b] = base2;
        if (3 in base2) {
          return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, ${roundAlpha(base2[3])})`;
        }
        return `rgba(${roundChannel(r)}, ${roundChannel(g)}, ${roundChannel(b)}, 1)`;
      }
      function createId(length = 8) {
        return Math.random().toString(16).slice(2, 2 + length);
      }
      function repeat(count, v) {
        const ret = [];
        for (let i = 0; i < count; ++i) {
          ret.push(v);
        }
        return ret;
      }
      function getEventTarget(e) {
        const path = e.composedPath();
        return path[0];
      }
      const traps = {
        mousemoveoutside: new WeakMap(),
        clickoutside: new WeakMap()
      };
      function createTrapHandler(name, el, originalHandler) {
        if (name === "mousemoveoutside") {
          const moveHandler = (e) => {
            if (el.contains(getEventTarget(e)))
              return;
            originalHandler(e);
          };
          return {
            mousemove: moveHandler,
            touchstart: moveHandler
          };
        } else if (name === "clickoutside") {
          let mouseDownOutside = false;
          const downHandler = (e) => {
            mouseDownOutside = !el.contains(getEventTarget(e));
          };
          const upHanlder = (e) => {
            if (!mouseDownOutside)
              return;
            if (el.contains(getEventTarget(e)))
              return;
            originalHandler(e);
          };
          return {
            mousedown: downHandler,
            mouseup: upHanlder,
            touchstart: downHandler,
            touchend: upHanlder
          };
        }
        console.error(
`[evtd/create-trap-handler]: name \`${name}\` is invalid. This could be a bug of evtd.`
        );
        return {};
      }
      function ensureTrapHandlers(name, el, handler) {
        const handlers = traps[name];
        let elHandlers = handlers.get(el);
        if (elHandlers === void 0) {
          handlers.set(el, elHandlers = new WeakMap());
        }
        let trapHandler = elHandlers.get(handler);
        if (trapHandler === void 0) {
          elHandlers.set(handler, trapHandler = createTrapHandler(name, el, handler));
        }
        return trapHandler;
      }
      function trapOn(name, el, handler, options) {
        if (name === "mousemoveoutside" || name === "clickoutside") {
          const trapHandlers = ensureTrapHandlers(name, el, handler);
          Object.keys(trapHandlers).forEach((key) => {
            on(key, document, trapHandlers[key], options);
          });
          return true;
        }
        return false;
      }
      function trapOff(name, el, handler, options) {
        if (name === "mousemoveoutside" || name === "clickoutside") {
          const trapHandlers = ensureTrapHandlers(name, el, handler);
          Object.keys(trapHandlers).forEach((key) => {
            off(key, document, trapHandlers[key], options);
          });
          return true;
        }
        return false;
      }
      function createDelegate() {
        if (typeof window === "undefined") {
          return {
            on: () => {
            },
            off: () => {
            }
          };
        }
        const propagationStopped = new WeakMap();
        const immediatePropagationStopped = new WeakMap();
        function trackPropagation() {
          propagationStopped.set(this, true);
        }
        function trackImmediate() {
          propagationStopped.set(this, true);
          immediatePropagationStopped.set(this, true);
        }
        function spy(event, propName, fn) {
          const source = event[propName];
          event[propName] = function() {
            fn.apply(event, arguments);
            return source.apply(event, arguments);
          };
          return event;
        }
        function unspy(event, propName) {
          event[propName] = Event.prototype[propName];
        }
        const currentTargets = new WeakMap();
        const currentTargetDescriptor = Object.getOwnPropertyDescriptor(Event.prototype, "currentTarget");
        function getCurrentTarget() {
          var _a;
          return (_a = currentTargets.get(this)) !== null && _a !== void 0 ? _a : null;
        }
        function defineCurrentTarget(event, getter) {
          if (currentTargetDescriptor === void 0)
            return;
          Object.defineProperty(event, "currentTarget", {
            configurable: true,
            enumerable: true,
            get: getter !== null && getter !== void 0 ? getter : currentTargetDescriptor.get
          });
        }
        const phaseToTypeToElToHandlers = {
          bubble: {},
          capture: {}
        };
        const typeToWindowEventHandlers = {};
        function createUnifiedHandler() {
          const delegeteHandler = function(e) {
            const { type, eventPhase, bubbles } = e;
            const target = getEventTarget(e);
            if (eventPhase === 2)
              return;
            const phase = eventPhase === 1 ? "capture" : "bubble";
            let cursor = target;
            const path = [];
            while (true) {
              if (cursor === null)
                cursor = window;
              path.push(cursor);
              if (cursor === window) {
                break;
              }
              cursor = cursor.parentNode || null;
            }
            const captureElToHandlers = phaseToTypeToElToHandlers.capture[type];
            const bubbleElToHandlers = phaseToTypeToElToHandlers.bubble[type];
            spy(e, "stopPropagation", trackPropagation);
            spy(e, "stopImmediatePropagation", trackImmediate);
            defineCurrentTarget(e, getCurrentTarget);
            if (phase === "capture") {
              if (captureElToHandlers === void 0)
                return;
              for (let i = path.length - 1; i >= 0; --i) {
                if (propagationStopped.has(e))
                  break;
                const target2 = path[i];
                const handlers = captureElToHandlers.get(target2);
                if (handlers !== void 0) {
                  currentTargets.set(e, target2);
                  for (const handler of handlers) {
                    if (immediatePropagationStopped.has(e))
                      break;
                    handler(e);
                  }
                }
                if (i === 0 && !bubbles && bubbleElToHandlers !== void 0) {
                  const bubbleHandlers = bubbleElToHandlers.get(target2);
                  if (bubbleHandlers !== void 0) {
                    for (const handler of bubbleHandlers) {
                      if (immediatePropagationStopped.has(e))
                        break;
                      handler(e);
                    }
                  }
                }
              }
            } else if (phase === "bubble") {
              if (bubbleElToHandlers === void 0)
                return;
              for (let i = 0; i < path.length; ++i) {
                if (propagationStopped.has(e))
                  break;
                const target2 = path[i];
                const handlers = bubbleElToHandlers.get(target2);
                if (handlers !== void 0) {
                  currentTargets.set(e, target2);
                  for (const handler of handlers) {
                    if (immediatePropagationStopped.has(e))
                      break;
                    handler(e);
                  }
                }
              }
            }
            unspy(e, "stopPropagation");
            unspy(e, "stopImmediatePropagation");
            defineCurrentTarget(e);
          };
          delegeteHandler.displayName = "evtdUnifiedHandler";
          return delegeteHandler;
        }
        function createUnifiedWindowEventHandler() {
          const delegateHandler = function(e) {
            const { type, eventPhase } = e;
            if (eventPhase !== 2)
              return;
            const handlers = typeToWindowEventHandlers[type];
            if (handlers === void 0)
              return;
            handlers.forEach((handler) => handler(e));
          };
          delegateHandler.displayName = "evtdUnifiedWindowEventHandler";
          return delegateHandler;
        }
        const unifiedHandler = createUnifiedHandler();
        const unfiendWindowEventHandler = createUnifiedWindowEventHandler();
        function ensureElToHandlers(phase, type) {
          const phaseHandlers = phaseToTypeToElToHandlers[phase];
          if (phaseHandlers[type] === void 0) {
            phaseHandlers[type] = new Map();
            window.addEventListener(type, unifiedHandler, phase === "capture");
          }
          return phaseHandlers[type];
        }
        function ensureWindowEventHandlers(type) {
          const windowEventHandlers = typeToWindowEventHandlers[type];
          if (windowEventHandlers === void 0) {
            typeToWindowEventHandlers[type] = new Set();
            window.addEventListener(type, unfiendWindowEventHandler);
          }
          return typeToWindowEventHandlers[type];
        }
        function ensureHandlers(elToHandlers, el) {
          let elHandlers = elToHandlers.get(el);
          if (elHandlers === void 0) {
            elToHandlers.set(el, elHandlers = new Set());
          }
          return elHandlers;
        }
        function handlerExist(el, phase, type, handler) {
          const elToHandlers = phaseToTypeToElToHandlers[phase][type];
          if (elToHandlers !== void 0) {
            const handlers = elToHandlers.get(el);
            if (handlers !== void 0) {
              if (handlers.has(handler))
                return true;
            }
          }
          return false;
        }
        function windowEventHandlerExist(type, handler) {
          const handlers = typeToWindowEventHandlers[type];
          if (handlers !== void 0) {
            if (handlers.has(handler)) {
              return true;
            }
          }
          return false;
        }
        function on2(type, el, handler, options) {
          let mergedHandler;
          if (typeof options === "object" && options.once === true) {
            mergedHandler = (e) => {
              off2(type, el, mergedHandler, options);
              handler(e);
            };
          } else {
            mergedHandler = handler;
          }
          const trapped = trapOn(type, el, mergedHandler, options);
          if (trapped)
            return;
          const phase = options === true || typeof options === "object" && options.capture === true ? "capture" : "bubble";
          const elToHandlers = ensureElToHandlers(phase, type);
          const handlers = ensureHandlers(elToHandlers, el);
          if (!handlers.has(mergedHandler))
            handlers.add(mergedHandler);
          if (el === window) {
            const windowEventHandlers = ensureWindowEventHandlers(type);
            if (!windowEventHandlers.has(mergedHandler)) {
              windowEventHandlers.add(mergedHandler);
            }
          }
        }
        function off2(type, el, handler, options) {
          const trapped = trapOff(type, el, handler, options);
          if (trapped)
            return;
          const capture = options === true || typeof options === "object" && options.capture === true;
          const phase = capture ? "capture" : "bubble";
          const elToHandlers = ensureElToHandlers(phase, type);
          const handlers = ensureHandlers(elToHandlers, el);
          if (el === window) {
            const mirrorPhase = capture ? "bubble" : "capture";
            if (!handlerExist(el, mirrorPhase, type, handler) && windowEventHandlerExist(type, handler)) {
              const windowEventHandlers = typeToWindowEventHandlers[type];
              windowEventHandlers.delete(handler);
              if (windowEventHandlers.size === 0) {
                window.removeEventListener(type, unfiendWindowEventHandler);
                typeToWindowEventHandlers[type] = void 0;
              }
            }
          }
          if (handlers.has(handler))
            handlers.delete(handler);
          if (handlers.size === 0) {
            elToHandlers.delete(el);
          }
          if (elToHandlers.size === 0) {
            window.removeEventListener(type, unifiedHandler, phase === "capture");
            phaseToTypeToElToHandlers[phase][type] = void 0;
          }
        }
        return {
          on: on2,
          off: off2
        };
      }
      const { on, off } = createDelegate();
      function useFalseUntilTruthy(originalRef) {
        const currentRef = vue.ref(!!originalRef.value);
        if (currentRef.value)
          return vue.readonly(currentRef);
        const stop = vue.watch(originalRef, (value) => {
          if (value) {
            currentRef.value = true;
            stop();
          }
        });
        return vue.readonly(currentRef);
      }
      function useMemo(getterOrOptions) {
        const computedValueRef = vue.computed(getterOrOptions);
        const valueRef = vue.ref(computedValueRef.value);
        vue.watch(computedValueRef, (value) => {
          valueRef.value = value;
        });
        if (typeof getterOrOptions === "function") {
          return valueRef;
        } else {
          return {
            __v_isRef: true,
            get value() {
              return valueRef.value;
            },
            set value(v) {
              getterOrOptions.set(v);
            }
          };
        }
      }
      function hasInstance() {
        return vue.getCurrentInstance() !== null;
      }
      const isBrowser$2 = typeof window !== "undefined";
      let fontsReady;
      let isFontReady;
      const init = () => {
        var _a, _b;
        fontsReady = isBrowser$2 ? (_b = (_a = document) === null || _a === void 0 ? void 0 : _a.fonts) === null || _b === void 0 ? void 0 : _b.ready : void 0;
        isFontReady = false;
        if (fontsReady !== void 0) {
          void fontsReady.then(() => {
            isFontReady = true;
          });
        } else {
          isFontReady = true;
        }
      };
      init();
      function onFontsReady(cb) {
        if (isFontReady)
          return;
        let deactivated = false;
        vue.onMounted(() => {
          if (!isFontReady) {
            fontsReady === null || fontsReady === void 0 ? void 0 : fontsReady.then(() => {
              if (deactivated)
                return;
              cb();
            });
          }
        });
        vue.onBeforeUnmount(() => {
          deactivated = true;
        });
      }
      const mousePositionRef = vue.ref(null);
      function clickHandler(e) {
        if (e.clientX > 0 || e.clientY > 0) {
          mousePositionRef.value = {
            x: e.clientX,
            y: e.clientY
          };
        } else {
          const { target } = e;
          if (target instanceof Element) {
            const { left, top, width, height } = target.getBoundingClientRect();
            if (left > 0 || top > 0) {
              mousePositionRef.value = {
                x: left + width / 2,
                y: top + height / 2
              };
            } else {
              mousePositionRef.value = { x: 0, y: 0 };
            }
          } else {
            mousePositionRef.value = null;
          }
        }
      }
      let usedCount$1 = 0;
      let managable$1 = true;
      function useClickPosition() {
        if (!isBrowser$2)
          return vue.readonly(vue.ref(null));
        if (usedCount$1 === 0)
          on("click", document, clickHandler, true);
        const setup2 = () => {
          usedCount$1 += 1;
        };
        if (managable$1 && (managable$1 = hasInstance())) {
          vue.onBeforeMount(setup2);
          vue.onBeforeUnmount(() => {
            usedCount$1 -= 1;
            if (usedCount$1 === 0)
              off("click", document, clickHandler, true);
          });
        } else {
          setup2();
        }
        return vue.readonly(mousePositionRef);
      }
      const clickedTimeRef = vue.ref(void 0);
      let usedCount = 0;
      function handleClick() {
        clickedTimeRef.value = Date.now();
      }
      let managable = true;
      function useClicked(timeout) {
        if (!isBrowser$2)
          return vue.readonly(vue.ref(false));
        const clickedRef = vue.ref(false);
        let timerId = null;
        function clearTimer() {
          if (timerId !== null)
            window.clearTimeout(timerId);
        }
        function clickedHandler() {
          clearTimer();
          clickedRef.value = true;
          timerId = window.setTimeout(() => {
            clickedRef.value = false;
          }, timeout);
        }
        if (usedCount === 0) {
          on("click", window, handleClick, true);
        }
        const setup2 = () => {
          usedCount += 1;
          on("click", window, clickedHandler, true);
        };
        if (managable && (managable = hasInstance())) {
          vue.onBeforeMount(setup2);
          vue.onBeforeUnmount(() => {
            usedCount -= 1;
            if (usedCount === 0) {
              off("click", window, handleClick, true);
            }
            off("click", window, clickedHandler, true);
            clearTimer();
          });
        } else {
          setup2();
        }
        return vue.readonly(clickedRef);
      }
      function useMergedState(controlledStateRef, uncontrolledStateRef) {
        vue.watch(controlledStateRef, (value) => {
          if (value !== void 0) {
            uncontrolledStateRef.value = value;
          }
        });
        return vue.computed(() => {
          if (controlledStateRef.value === void 0) {
            return uncontrolledStateRef.value;
          }
          return controlledStateRef.value;
        });
      }
      function isMounted() {
        const isMounted2 = vue.ref(false);
        vue.onMounted(() => {
          isMounted2.value = true;
        });
        return vue.readonly(isMounted2);
      }
      function useCompitable(reactive2, keys2) {
        return vue.computed(() => {
          for (const key of keys2) {
            if (reactive2[key] !== void 0)
              return reactive2[key];
          }
          return reactive2[keys2[keys2.length - 1]];
        });
      }
      const isIos = (typeof window === "undefined" ? false : /iPad|iPhone|iPod/.test(navigator.platform) || navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1) &&
!window.MSStream;
      function useIsIos() {
        return isIos;
      }
      function useKeyboard(options = {}, enabledRef) {
        const state = vue.reactive({
          ctrl: false,
          command: false,
          win: false,
          shift: false,
          tab: false
        });
        const { keydown, keyup } = options;
        const keydownHandler = (e) => {
          switch (e.key) {
            case "Control":
              state.ctrl = true;
              break;
            case "Meta":
              state.command = true;
              state.win = true;
              break;
            case "Shift":
              state.shift = true;
              break;
            case "Tab":
              state.tab = true;
              break;
          }
          if (keydown !== void 0) {
            Object.keys(keydown).forEach((key) => {
              if (key !== e.key)
                return;
              const handler = keydown[key];
              if (typeof handler === "function") {
                handler(e);
              } else {
                const { stop = false, prevent = false } = handler;
                if (stop)
                  e.stopPropagation();
                if (prevent)
                  e.preventDefault();
                handler.handler(e);
              }
            });
          }
        };
        const keyupHandler = (e) => {
          switch (e.key) {
            case "Control":
              state.ctrl = false;
              break;
            case "Meta":
              state.command = false;
              state.win = false;
              break;
            case "Shift":
              state.shift = false;
              break;
            case "Tab":
              state.tab = false;
              break;
          }
          if (keyup !== void 0) {
            Object.keys(keyup).forEach((key) => {
              if (key !== e.key)
                return;
              const handler = keyup[key];
              if (typeof handler === "function") {
                handler(e);
              } else {
                const { stop = false, prevent = false } = handler;
                if (stop)
                  e.stopPropagation();
                if (prevent)
                  e.preventDefault();
                handler.handler(e);
              }
            });
          }
        };
        const setup2 = () => {
          if (enabledRef === void 0 || enabledRef.value) {
            on("keydown", document, keydownHandler);
            on("keyup", document, keyupHandler);
          }
          if (enabledRef !== void 0) {
            vue.watch(enabledRef, (value) => {
              if (value) {
                on("keydown", document, keydownHandler);
                on("keyup", document, keyupHandler);
              } else {
                off("keydown", document, keydownHandler);
                off("keyup", document, keyupHandler);
              }
            });
          }
        };
        if (hasInstance()) {
          vue.onBeforeMount(setup2);
          vue.onBeforeUnmount(() => {
            if (enabledRef === void 0 || enabledRef.value) {
              off("keydown", document, keydownHandler);
              off("keyup", document, keyupHandler);
            }
          });
        } else {
          setup2();
        }
        return vue.readonly(state);
      }
      function createInjectionKey(key) {
        return key;
      }
      const internalSelectionMenuInjectionKey = createInjectionKey("n-internal-select-menu");
      const internalSelectionMenuBodyInjectionKey = createInjectionKey("n-internal-select-menu-body");
      const drawerBodyInjectionKey = createInjectionKey("n-drawer-body");
      const modalBodyInjectionKey = createInjectionKey("n-modal-body");
      const modalProviderInjectionKey$1 = createInjectionKey("n-modal-provider");
      const modalInjectionKey = createInjectionKey("n-modal");
      const popoverBodyInjectionKey = createInjectionKey("n-popover-body");
      const teleportDisabled = "__disabled__";
      function useAdjustedTo(props) {
        const modal = vue.inject(modalBodyInjectionKey, null);
        const drawer = vue.inject(drawerBodyInjectionKey, null);
        const popover = vue.inject(popoverBodyInjectionKey, null);
        const selectMenu = vue.inject(internalSelectionMenuBodyInjectionKey, null);
        const fullscreenElementRef = vue.ref();
        if (typeof document !== "undefined") {
          fullscreenElementRef.value = document.fullscreenElement;
          const handleFullscreenChange = () => {
            fullscreenElementRef.value = document.fullscreenElement;
          };
          vue.onMounted(() => {
            on("fullscreenchange", document, handleFullscreenChange);
          });
          vue.onBeforeUnmount(() => {
            off("fullscreenchange", document, handleFullscreenChange);
          });
        }
        return useMemo(() => {
          var _a;
          const {
            to
          } = props;
          if (to !== void 0) {
            if (to === false) return teleportDisabled;
            if (to === true) return fullscreenElementRef.value || "body";
            return to;
          }
          if (modal === null || modal === void 0 ? void 0 : modal.value) {
            return (_a = modal.value.$el) !== null && _a !== void 0 ? _a : modal.value;
          }
          if (drawer === null || drawer === void 0 ? void 0 : drawer.value) return drawer.value;
          if (popover === null || popover === void 0 ? void 0 : popover.value) return popover.value;
          if (selectMenu === null || selectMenu === void 0 ? void 0 : selectMenu.value) return selectMenu.value;
          return to !== null && to !== void 0 ? to : fullscreenElementRef.value || "body";
        });
      }
      useAdjustedTo.tdkey = teleportDisabled;
      useAdjustedTo.propTo = {
        type: [String, Object, Boolean],
        default: void 0
      };
      function useInjectionInstanceCollection(injectionName, collectionKey, registerKeyRef) {
        var _a;
        const injection = vue.inject(injectionName, null);
        if (injection === null) return;
        const vm = (_a = vue.getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy;
        vue.watch(registerKeyRef, registerInstance);
        registerInstance(registerKeyRef.value);
        vue.onBeforeUnmount(() => {
          registerInstance(void 0, registerKeyRef.value);
        });
        function registerInstance(key, oldKey) {
          if (!injection) return;
          const collection = injection[collectionKey];
          if (oldKey !== void 0) removeInstance(collection, oldKey);
          if (key !== void 0) addInstance(collection, key);
        }
        function removeInstance(collection, key) {
          if (!collection[key]) collection[key] = [];
          collection[key].splice(collection[key].findIndex((instance) => instance === vm), 1);
        }
        function addInstance(collection, key) {
          if (!collection[key]) collection[key] = [];
          if (!~collection[key].findIndex((instance) => instance === vm)) {
            collection[key].push(vm);
          }
        }
      }
      function useDeferredTrue(valueRef, delay, shouldDelayRef) {
        const delayedRef = vue.ref(valueRef.value);
        let timerId = null;
        vue.watch(valueRef, (value) => {
          if (timerId !== null) window.clearTimeout(timerId);
          if (value === true) {
            if (shouldDelayRef && !shouldDelayRef.value) {
              delayedRef.value = true;
            } else {
              timerId = window.setTimeout(() => {
                delayedRef.value = true;
              }, delay);
            }
          } else {
            delayedRef.value = false;
          }
        });
        return delayedRef;
      }
      const isBrowser$1 = typeof document !== "undefined" && typeof window !== "undefined";
      const isComposingRef = vue.ref(false);
      function compositionStartHandler() {
        isComposingRef.value = true;
      }
      function compositionEndHandler() {
        isComposingRef.value = false;
      }
      let mountedCount = 0;
      function useIsComposing() {
        if (isBrowser$1) {
          vue.onBeforeMount(() => {
            if (!mountedCount) {
              window.addEventListener("compositionstart", compositionStartHandler);
              window.addEventListener("compositionend", compositionEndHandler);
            }
            mountedCount++;
          });
          vue.onBeforeUnmount(() => {
            if (mountedCount <= 1) {
              window.removeEventListener("compositionstart", compositionStartHandler);
              window.removeEventListener("compositionend", compositionEndHandler);
              mountedCount = 0;
            } else {
              mountedCount--;
            }
          });
        }
        return isComposingRef;
      }
      let lockCount = 0;
      let originalMarginRight = "";
      let originalOverflow = "";
      let originalOverflowX = "";
      let originalOverflowY = "";
      const lockHtmlScrollRightCompensationRef = vue.ref("0px");
      function useLockHtmlScroll(lockRef) {
        if (typeof document === "undefined") return;
        const el = document.documentElement;
        let watchStopHandle;
        let activated = false;
        const unlock = () => {
          el.style.marginRight = originalMarginRight;
          el.style.overflow = originalOverflow;
          el.style.overflowX = originalOverflowX;
          el.style.overflowY = originalOverflowY;
          lockHtmlScrollRightCompensationRef.value = "0px";
        };
        vue.onMounted(() => {
          watchStopHandle = vue.watch(lockRef, (value) => {
            if (value) {
              if (!lockCount) {
                const scrollbarWidth = window.innerWidth - el.offsetWidth;
                if (scrollbarWidth > 0) {
                  originalMarginRight = el.style.marginRight;
                  el.style.marginRight = `${scrollbarWidth}px`;
                  lockHtmlScrollRightCompensationRef.value = `${scrollbarWidth}px`;
                }
                originalOverflow = el.style.overflow;
                originalOverflowX = el.style.overflowX;
                originalOverflowY = el.style.overflowY;
                el.style.overflow = "hidden";
                el.style.overflowX = "hidden";
                el.style.overflowY = "hidden";
              }
              activated = true;
              lockCount++;
            } else {
              lockCount--;
              if (!lockCount) {
                unlock();
              }
              activated = false;
            }
          }, {
            immediate: true
          });
        });
        vue.onBeforeUnmount(() => {
          watchStopHandle === null || watchStopHandle === void 0 ? void 0 : watchStopHandle();
          if (activated) {
            lockCount--;
            if (!lockCount) {
              unlock();
            }
            activated = false;
          }
        });
      }
      function useReactivated(callback) {
        const isDeactivatedRef = {
          isDeactivated: false
        };
        let activateStateInitialized = false;
        vue.onActivated(() => {
          isDeactivatedRef.isDeactivated = false;
          if (!activateStateInitialized) {
            activateStateInitialized = true;
            return;
          }
          callback();
        });
        vue.onDeactivated(() => {
          isDeactivatedRef.isDeactivated = true;
          if (!activateStateInitialized) {
            activateStateInitialized = true;
          }
        });
        return isDeactivatedRef;
      }
      function getSlot$1(scope, slots, slotName = "default") {
        const slot = slots[slotName];
        if (slot === void 0) {
          throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
        }
        return slot();
      }
      function flatten$3(vNodes, filterCommentNode = true, result = []) {
        vNodes.forEach((vNode) => {
          if (vNode === null)
            return;
          if (typeof vNode !== "object") {
            if (typeof vNode === "string" || typeof vNode === "number") {
              result.push(vue.createTextVNode(String(vNode)));
            }
            return;
          }
          if (Array.isArray(vNode)) {
            flatten$3(vNode, filterCommentNode, result);
            return;
          }
          if (vNode.type === vue.Fragment) {
            if (vNode.children === null)
              return;
            if (Array.isArray(vNode.children)) {
              flatten$3(vNode.children, filterCommentNode, result);
            }
          } else if (vNode.type !== vue.Comment) {
            result.push(vNode);
          }
        });
        return result;
      }
      function getFirstVNode(scope, slots, slotName = "default") {
        const slot = slots[slotName];
        if (slot === void 0) {
          throw new Error(`[vueuc/${scope}]: slot[${slotName}] is empty.`);
        }
        const content = flatten$3(slot());
        if (content.length === 1) {
          return content[0];
        } else {
          throw new Error(`[vueuc/${scope}]: slot[${slotName}] should have exactly one child.`);
        }
      }
      let viewMeasurer = null;
      function ensureViewBoundingRect() {
        if (viewMeasurer === null) {
          viewMeasurer = document.getElementById("v-binder-view-measurer");
          if (viewMeasurer === null) {
            viewMeasurer = document.createElement("div");
            viewMeasurer.id = "v-binder-view-measurer";
            const { style: style2 } = viewMeasurer;
            style2.position = "fixed";
            style2.left = "0";
            style2.right = "0";
            style2.top = "0";
            style2.bottom = "0";
            style2.pointerEvents = "none";
            style2.visibility = "hidden";
            document.body.appendChild(viewMeasurer);
          }
        }
        return viewMeasurer.getBoundingClientRect();
      }
      function getPointRect(x, y) {
        const viewRect = ensureViewBoundingRect();
        return {
          top: y,
          left: x,
          height: 0,
          width: 0,
          right: viewRect.width - x,
          bottom: viewRect.height - y
        };
      }
      function getRect(el) {
        const elRect = el.getBoundingClientRect();
        const viewRect = ensureViewBoundingRect();
        return {
          left: elRect.left - viewRect.left,
          top: elRect.top - viewRect.top,
          bottom: viewRect.height + viewRect.top - elRect.bottom,
          right: viewRect.width + viewRect.left - elRect.right,
          width: elRect.width,
          height: elRect.height
        };
      }
      function getParentNode(node) {
        if (node.nodeType === 9) {
          return null;
        }
        return node.parentNode;
      }
      function getScrollParent(node) {
        if (node === null)
          return null;
        const parentNode = getParentNode(node);
        if (parentNode === null) {
          return null;
        }
        if (parentNode.nodeType === 9) {
          return document;
        }
        if (parentNode.nodeType === 1) {
          const { overflow, overflowX, overflowY } = getComputedStyle(parentNode);
          if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
            return parentNode;
          }
        }
        return getScrollParent(parentNode);
      }
      const Binder = vue.defineComponent({
        name: "Binder",
        props: {
          syncTargetWithParent: Boolean,
          syncTarget: {
            type: Boolean,
            default: true
          }
        },
        setup(props) {
          var _a;
          vue.provide("VBinder", (_a = vue.getCurrentInstance()) === null || _a === void 0 ? void 0 : _a.proxy);
          const VBinder = vue.inject("VBinder", null);
          const targetRef = vue.ref(null);
          const setTargetRef = (el) => {
            targetRef.value = el;
            if (VBinder && props.syncTargetWithParent) {
              VBinder.setTargetRef(el);
            }
          };
          let scrollableNodes = [];
          const ensureScrollListener = () => {
            let cursor = targetRef.value;
            while (true) {
              cursor = getScrollParent(cursor);
              if (cursor === null)
                break;
              scrollableNodes.push(cursor);
            }
            for (const el of scrollableNodes) {
              on("scroll", el, onScroll, true);
            }
          };
          const removeScrollListeners = () => {
            for (const el of scrollableNodes) {
              off("scroll", el, onScroll, true);
            }
            scrollableNodes = [];
          };
          const followerScrollListeners = new Set();
          const addScrollListener = (listener) => {
            if (followerScrollListeners.size === 0) {
              ensureScrollListener();
            }
            if (!followerScrollListeners.has(listener)) {
              followerScrollListeners.add(listener);
            }
          };
          const removeScrollListener = (listener) => {
            if (followerScrollListeners.has(listener)) {
              followerScrollListeners.delete(listener);
            }
            if (followerScrollListeners.size === 0) {
              removeScrollListeners();
            }
          };
          const onScroll = () => {
            beforeNextFrameOnce(onScrollRaf);
          };
          const onScrollRaf = () => {
            followerScrollListeners.forEach((listener) => listener());
          };
          const followerResizeListeners = new Set();
          const addResizeListener = (listener) => {
            if (followerResizeListeners.size === 0) {
              on("resize", window, onResize);
            }
            if (!followerResizeListeners.has(listener)) {
              followerResizeListeners.add(listener);
            }
          };
          const removeResizeListener = (listener) => {
            if (followerResizeListeners.has(listener)) {
              followerResizeListeners.delete(listener);
            }
            if (followerResizeListeners.size === 0) {
              off("resize", window, onResize);
            }
          };
          const onResize = () => {
            followerResizeListeners.forEach((listener) => listener());
          };
          vue.onBeforeUnmount(() => {
            off("resize", window, onResize);
            removeScrollListeners();
          });
          return {
            targetRef,
            setTargetRef,
            addScrollListener,
            removeScrollListener,
            addResizeListener,
            removeResizeListener
          };
        },
        render() {
          return getSlot$1("binder", this.$slots);
        }
      });
      const VTarget = vue.defineComponent({
        name: "Target",
        setup() {
          const { setTargetRef, syncTarget } = vue.inject("VBinder");
          const setTargetDirective = {
            mounted: setTargetRef,
            updated: setTargetRef
          };
          return {
            syncTarget,
            setTargetDirective
          };
        },
        render() {
          const { syncTarget, setTargetDirective } = this;
          if (syncTarget) {
            return vue.withDirectives(getFirstVNode("follower", this.$slots), [
              [setTargetDirective]
            ]);
          }
          return getFirstVNode("follower", this.$slots);
        }
      });
      const ctxKey$1 = "@@mmoContext";
      const mousemoveoutside = {
        mounted(el, { value }) {
          el[ctxKey$1] = {
            handler: void 0
          };
          if (typeof value === "function") {
            el[ctxKey$1].handler = value;
            on("mousemoveoutside", el, value);
          }
        },
        updated(el, { value }) {
          const ctx2 = el[ctxKey$1];
          if (typeof value === "function") {
            if (ctx2.handler) {
              if (ctx2.handler !== value) {
                off("mousemoveoutside", el, ctx2.handler);
                ctx2.handler = value;
                on("mousemoveoutside", el, value);
              }
            } else {
              el[ctxKey$1].handler = value;
              on("mousemoveoutside", el, value);
            }
          } else {
            if (ctx2.handler) {
              off("mousemoveoutside", el, ctx2.handler);
              ctx2.handler = void 0;
            }
          }
        },
        unmounted(el) {
          const { handler } = el[ctxKey$1];
          if (handler) {
            off("mousemoveoutside", el, handler);
          }
          el[ctxKey$1].handler = void 0;
        }
      };
      const ctxKey = "@@coContext";
      const clickoutside = {
        mounted(el, { value, modifiers }) {
          el[ctxKey] = {
            handler: void 0
          };
          if (typeof value === "function") {
            el[ctxKey].handler = value;
            on("clickoutside", el, value, {
              capture: modifiers.capture
            });
          }
        },
        updated(el, { value, modifiers }) {
          const ctx2 = el[ctxKey];
          if (typeof value === "function") {
            if (ctx2.handler) {
              if (ctx2.handler !== value) {
                off("clickoutside", el, ctx2.handler, {
                  capture: modifiers.capture
                });
                ctx2.handler = value;
                on("clickoutside", el, value, {
                  capture: modifiers.capture
                });
              }
            } else {
              el[ctxKey].handler = value;
              on("clickoutside", el, value, {
                capture: modifiers.capture
              });
            }
          } else {
            if (ctx2.handler) {
              off("clickoutside", el, ctx2.handler, {
                capture: modifiers.capture
              });
              ctx2.handler = void 0;
            }
          }
        },
        unmounted(el, { modifiers }) {
          const { handler } = el[ctxKey];
          if (handler) {
            off("clickoutside", el, handler, {
              capture: modifiers.capture
            });
          }
          el[ctxKey].handler = void 0;
        }
      };
      function warn$2(location, message2) {
        console.error(`[vdirs/${location}]: ${message2}`);
      }
      class ZIndexManager {
        constructor() {
          this.elementZIndex = new Map();
          this.nextZIndex = 2e3;
        }
        get elementCount() {
          return this.elementZIndex.size;
        }
        ensureZIndex(el, zIndex) {
          const { elementZIndex } = this;
          if (zIndex !== void 0) {
            el.style.zIndex = `${zIndex}`;
            elementZIndex.delete(el);
            return;
          }
          const { nextZIndex } = this;
          if (elementZIndex.has(el)) {
            const currentZIndex = elementZIndex.get(el);
            if (currentZIndex + 1 === this.nextZIndex)
              return;
          }
          el.style.zIndex = `${nextZIndex}`;
          elementZIndex.set(el, nextZIndex);
          this.nextZIndex = nextZIndex + 1;
          this.squashState();
        }
        unregister(el, zIndex) {
          const { elementZIndex } = this;
          if (elementZIndex.has(el)) {
            elementZIndex.delete(el);
          } else if (zIndex === void 0) {
            warn$2("z-index-manager/unregister-element", "Element not found when unregistering.");
          }
          this.squashState();
        }
        squashState() {
          const { elementCount } = this;
          if (!elementCount) {
            this.nextZIndex = 2e3;
          }
          if (this.nextZIndex - elementCount > 2500)
            this.rearrange();
        }
        rearrange() {
          const elementZIndexPair = Array.from(this.elementZIndex.entries());
          elementZIndexPair.sort((pair1, pair2) => {
            return pair1[1] - pair2[1];
          });
          this.nextZIndex = 2e3;
          elementZIndexPair.forEach((pair) => {
            const el = pair[0];
            const zIndex = this.nextZIndex++;
            if (`${zIndex}` !== el.style.zIndex)
              el.style.zIndex = `${zIndex}`;
          });
        }
      }
      const zIndexManager = new ZIndexManager();
      const ctx = "@@ziContext";
      const zindexable = {
        mounted(el, bindings) {
          const { value = {} } = bindings;
          const { zIndex, enabled } = value;
          el[ctx] = {
            enabled: !!enabled,
            initialized: false
          };
          if (enabled) {
            zIndexManager.ensureZIndex(el, zIndex);
            el[ctx].initialized = true;
          }
        },
        updated(el, bindings) {
          const { value = {} } = bindings;
          const { zIndex, enabled } = value;
          const cachedEnabled = el[ctx].enabled;
          if (enabled && !cachedEnabled) {
            zIndexManager.ensureZIndex(el, zIndex);
            el[ctx].initialized = true;
          }
          el[ctx].enabled = !!enabled;
        },
        unmounted(el, bindings) {
          if (!el[ctx].initialized)
            return;
          const { value = {} } = bindings;
          const { zIndex } = value;
          zIndexManager.unregister(el, zIndex);
        }
      };
      const ssrContextKey = "@css-render/vue3-ssr";
      function createStyleString(id, style2) {
        return `<style cssr-id="${id}">
${style2}
</style>`;
      }
      function ssrAdapter(id, style2, ssrContext) {
        const { styles: styles2, ids } = ssrContext;
        if (ids.has(id))
          return;
        if (styles2 !== null) {
          ids.add(id);
          styles2.push(createStyleString(id, style2));
        }
      }
      const isBrowser = typeof document !== "undefined";
      function useSsrAdapter() {
        if (isBrowser)
          return void 0;
        const context = vue.inject(ssrContextKey, null);
        if (context === null)
          return void 0;
        return {
          adapter: (id, style2) => ssrAdapter(id, style2, context),
          context
        };
      }
      function warn$1(location, message2) {
        console.error(`[vueuc/${location}]: ${message2}`);
      }
      const { c } = CssRender();
      const cssrAnchorMetaName$1 = "vueuc-style";
      function lowBit(n) {
        return n & -n;
      }
      class FinweckTree {
constructor(l, min) {
          this.l = l;
          this.min = min;
          const ft = new Array(l + 1);
          for (let i = 0; i < l + 1; ++i) {
            ft[i] = 0;
          }
          this.ft = ft;
        }
add(i, n) {
          if (n === 0)
            return;
          const { l, ft } = this;
          i += 1;
          while (i <= l) {
            ft[i] += n;
            i += lowBit(i);
          }
        }
get(i) {
          return this.sum(i + 1) - this.sum(i);
        }
sum(i) {
          if (i === void 0)
            i = this.l;
          if (i <= 0)
            return 0;
          const { ft, min, l } = this;
          if (i > l)
            throw new Error("[FinweckTree.sum]: `i` is larger than length.");
          let ret = i * min;
          while (i > 0) {
            ret += ft[i];
            i -= lowBit(i);
          }
          return ret;
        }
getBound(threshold) {
          let l = 0;
          let r = this.l;
          while (r > l) {
            const m = Math.floor((l + r) / 2);
            const sumM = this.sum(m);
            if (sumM > threshold) {
              r = m;
              continue;
            } else if (sumM < threshold) {
              if (l === m) {
                if (this.sum(l + 1) <= threshold)
                  return l + 1;
                return m;
              }
              l = m;
            } else {
              return m;
            }
          }
          return l;
        }
      }
      function resolveTo(selector) {
        if (typeof selector === "string") {
          return document.querySelector(selector);
        }
        return selector() || null;
      }
      const LazyTeleport = vue.defineComponent({
        name: "LazyTeleport",
        props: {
          to: {
            type: [String, Object],
            default: void 0
          },
          disabled: Boolean,
          show: {
            type: Boolean,
            required: true
          }
        },
        setup(props) {
          return {
            showTeleport: useFalseUntilTruthy(vue.toRef(props, "show")),
            mergedTo: vue.computed(() => {
              const { to } = props;
              return to !== null && to !== void 0 ? to : "body";
            })
          };
        },
        render() {
          return this.showTeleport ? this.disabled ? getSlot$1("lazy-teleport", this.$slots) : vue.h(vue.Teleport, {
            disabled: this.disabled,
            to: this.mergedTo
          }, getSlot$1("lazy-teleport", this.$slots)) : null;
        }
      });
      const oppositionPositions = {
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      };
      const oppositeAligns = {
        start: "end",
        center: "center",
        end: "start"
      };
      const propToCompare = {
        top: "height",
        bottom: "height",
        left: "width",
        right: "width"
      };
      const transformOrigins = {
        "bottom-start": "top left",
        bottom: "top center",
        "bottom-end": "top right",
        "top-start": "bottom left",
        top: "bottom center",
        "top-end": "bottom right",
        "right-start": "top left",
        right: "center left",
        "right-end": "bottom left",
        "left-start": "top right",
        left: "center right",
        "left-end": "bottom right"
      };
      const overlapTransformOrigin = {
        "bottom-start": "bottom left",
        bottom: "bottom center",
        "bottom-end": "bottom right",
        "top-start": "top left",
        top: "top center",
        "top-end": "top right",
        "right-start": "top right",
        right: "center right",
        "right-end": "bottom right",
        "left-start": "top left",
        left: "center left",
        "left-end": "bottom left"
      };
      const oppositeAlignCssPositionProps = {
        "bottom-start": "right",
        "bottom-end": "left",
        "top-start": "right",
        "top-end": "left",
        "right-start": "bottom",
        "right-end": "top",
        "left-start": "bottom",
        "left-end": "top"
      };
      const keepOffsetDirection = {
        top: true,
bottom: false,
left: true,
right: false
};
      const cssPositionToOppositeAlign = {
        top: "end",
        bottom: "start",
        left: "end",
        right: "start"
      };
      function getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, shift, flip, overlap) {
        if (!flip || overlap) {
          return { placement, top: 0, left: 0 };
        }
        const [position, align] = placement.split("-");
        let properAlign = align !== null && align !== void 0 ? align : "center";
        let properOffset = {
          top: 0,
          left: 0
        };
        const deriveOffset = (oppositeAlignCssSizeProp, alignCssPositionProp, offsetVertically2) => {
          let left = 0;
          let top = 0;
          const diff = followerRect[oppositeAlignCssSizeProp] - targetRect[alignCssPositionProp] - targetRect[oppositeAlignCssSizeProp];
          if (diff > 0 && shift) {
            if (offsetVertically2) {
              top = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
            } else {
              left = keepOffsetDirection[alignCssPositionProp] ? diff : -diff;
            }
          }
          return {
            left,
            top
          };
        };
        const offsetVertically = position === "left" || position === "right";
        if (properAlign !== "center") {
          const oppositeAlignCssPositionProp = oppositeAlignCssPositionProps[placement];
          const currentAlignCssPositionProp = oppositionPositions[oppositeAlignCssPositionProp];
          const oppositeAlignCssSizeProp = propToCompare[oppositeAlignCssPositionProp];
          if (followerRect[oppositeAlignCssSizeProp] > targetRect[oppositeAlignCssSizeProp]) {
            if (


targetRect[oppositeAlignCssPositionProp] + targetRect[oppositeAlignCssSizeProp] < followerRect[oppositeAlignCssSizeProp]
            ) {
              const followerOverTargetSize = (followerRect[oppositeAlignCssSizeProp] - targetRect[oppositeAlignCssSizeProp]) / 2;
              if (targetRect[oppositeAlignCssPositionProp] < followerOverTargetSize || targetRect[currentAlignCssPositionProp] < followerOverTargetSize) {
                if (targetRect[oppositeAlignCssPositionProp] < targetRect[currentAlignCssPositionProp]) {
                  properAlign = oppositeAligns[align];
                  properOffset = deriveOffset(oppositeAlignCssSizeProp, currentAlignCssPositionProp, offsetVertically);
                } else {
                  properOffset = deriveOffset(oppositeAlignCssSizeProp, oppositeAlignCssPositionProp, offsetVertically);
                }
              } else {
                properAlign = "center";
              }
            }
          } else if (followerRect[oppositeAlignCssSizeProp] < targetRect[oppositeAlignCssSizeProp]) {
            if (targetRect[currentAlignCssPositionProp] < 0 &&


targetRect[oppositeAlignCssPositionProp] > targetRect[currentAlignCssPositionProp]) {
              properAlign = oppositeAligns[align];
            }
          }
        } else {
          const possibleAlternativeAlignCssPositionProp1 = position === "bottom" || position === "top" ? "left" : "top";
          const possibleAlternativeAlignCssPositionProp2 = oppositionPositions[possibleAlternativeAlignCssPositionProp1];
          const alternativeAlignCssSizeProp = propToCompare[possibleAlternativeAlignCssPositionProp1];
          const followerOverTargetSize = (followerRect[alternativeAlignCssSizeProp] - targetRect[alternativeAlignCssSizeProp]) / 2;
          if (


targetRect[possibleAlternativeAlignCssPositionProp1] < followerOverTargetSize || targetRect[possibleAlternativeAlignCssPositionProp2] < followerOverTargetSize
          ) {
            if (targetRect[possibleAlternativeAlignCssPositionProp1] > targetRect[possibleAlternativeAlignCssPositionProp2]) {
              properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp1];
              properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp1, offsetVertically);
            } else {
              properAlign = cssPositionToOppositeAlign[possibleAlternativeAlignCssPositionProp2];
              properOffset = deriveOffset(alternativeAlignCssSizeProp, possibleAlternativeAlignCssPositionProp2, offsetVertically);
            }
          }
        }
        let properPosition = position;
        if (
targetRect[position] < followerRect[propToCompare[position]] &&
targetRect[position] < targetRect[oppositionPositions[position]]
        ) {
          properPosition = oppositionPositions[position];
        }
        return {
          placement: properAlign !== "center" ? `${properPosition}-${properAlign}` : properPosition,
          left: properOffset.left,
          top: properOffset.top
        };
      }
      function getProperTransformOrigin(placement, overlap) {
        if (overlap)
          return overlapTransformOrigin[placement];
        return transformOrigins[placement];
      }
      function getOffset(placement, offsetRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap) {
        if (overlap) {
          switch (placement) {
            case "bottom-start":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: "translateY(-100%)"
              };
            case "bottom-end":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%) translateY(-100%)"
              };
            case "top-start":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: ""
              };
            case "top-end":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%)"
              };
            case "right-start":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%)"
              };
            case "right-end":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%) translateY(-100%)"
              };
            case "left-start":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: ""
              };
            case "left-end":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: "translateY(-100%)"
              };
            case "top":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                transform: "translateX(-50%)"
              };
            case "right":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width)}px`,
                transform: "translateX(-100%) translateY(-50%)"
              };
            case "left":
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left)}px`,
                transform: "translateY(-50%)"
              };
            case "bottom":
            default:
              return {
                top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height)}px`,
                left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2)}px`,
                transform: "translateX(-50%) translateY(-100%)"
              };
          }
        }
        switch (placement) {
          case "bottom-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: ""
            };
          case "bottom-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-100%)"
            };
          case "top-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-100%)"
            };
          case "top-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-100%) translateY(-100%)"
            };
          case "right-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: ""
            };
          case "right-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-100%)"
            };
          case "left-start":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-100%)"
            };
          case "left-end":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-100%) translateY(-100%)"
            };
          case "top":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-100%) translateX(-50%)"
            };
          case "right":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-50%)"
            };
          case "left":
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height / 2 + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + offsetLeftToStandardPlacement)}px`,
              transform: "translateY(-50%) translateX(-100%)"
            };
          case "bottom":
          default:
            return {
              top: `${Math.round(targetRect.top - offsetRect.top + targetRect.height + offsetTopToStandardPlacement)}px`,
              left: `${Math.round(targetRect.left - offsetRect.left + targetRect.width / 2 + offsetLeftToStandardPlacement)}px`,
              transform: "translateX(-50%)"
            };
        }
      }
      const style$z = c([
        c(".v-binder-follower-container", {
          position: "absolute",
          left: "0",
          right: "0",
          top: "0",
          height: "0",
          pointerEvents: "none",
          zIndex: "auto"
        }),
        c(".v-binder-follower-content", {
          position: "absolute",
          zIndex: "auto"
        }, [
          c("> *", {
            pointerEvents: "all"
          })
        ])
      ]);
      const VFollower = vue.defineComponent({
        name: "Follower",
        inheritAttrs: false,
        props: {
          show: Boolean,
          enabled: {
            type: Boolean,
            default: void 0
          },
          placement: {
            type: String,
            default: "bottom"
          },
          syncTrigger: {
            type: Array,
            default: ["resize", "scroll"]
          },
          to: [String, Object],
          flip: {
            type: Boolean,
            default: true
          },
          internalShift: Boolean,
          x: Number,
          y: Number,
          width: String,
          minWidth: String,
          containerClass: String,
          teleportDisabled: Boolean,
          zindexable: {
            type: Boolean,
            default: true
          },
          zIndex: Number,
          overlap: Boolean
        },
        setup(props) {
          const VBinder = vue.inject("VBinder");
          const mergedEnabledRef = useMemo(() => {
            return props.enabled !== void 0 ? props.enabled : props.show;
          });
          const followerRef = vue.ref(null);
          const offsetContainerRef = vue.ref(null);
          const ensureListeners = () => {
            const { syncTrigger } = props;
            if (syncTrigger.includes("scroll")) {
              VBinder.addScrollListener(syncPosition);
            }
            if (syncTrigger.includes("resize")) {
              VBinder.addResizeListener(syncPosition);
            }
          };
          const removeListeners = () => {
            VBinder.removeScrollListener(syncPosition);
            VBinder.removeResizeListener(syncPosition);
          };
          vue.onMounted(() => {
            if (mergedEnabledRef.value) {
              syncPosition();
              ensureListeners();
            }
          });
          const ssrAdapter2 = useSsrAdapter();
          style$z.mount({
            id: "vueuc/binder",
            head: true,
            anchorMetaName: cssrAnchorMetaName$1,
            ssr: ssrAdapter2
          });
          vue.onBeforeUnmount(() => {
            removeListeners();
          });
          onFontsReady(() => {
            if (mergedEnabledRef.value) {
              syncPosition();
            }
          });
          const syncPosition = () => {
            if (!mergedEnabledRef.value) {
              return;
            }
            const follower = followerRef.value;
            if (follower === null)
              return;
            const target = VBinder.targetRef;
            const { x, y, overlap } = props;
            const targetRect = x !== void 0 && y !== void 0 ? getPointRect(x, y) : getRect(target);
            follower.style.setProperty("--v-target-width", `${Math.round(targetRect.width)}px`);
            follower.style.setProperty("--v-target-height", `${Math.round(targetRect.height)}px`);
            const { width, minWidth, placement, internalShift, flip } = props;
            follower.setAttribute("v-placement", placement);
            if (overlap) {
              follower.setAttribute("v-overlap", "");
            } else {
              follower.removeAttribute("v-overlap");
            }
            const { style: style2 } = follower;
            if (width === "target") {
              style2.width = `${targetRect.width}px`;
            } else if (width !== void 0) {
              style2.width = width;
            } else {
              style2.width = "";
            }
            if (minWidth === "target") {
              style2.minWidth = `${targetRect.width}px`;
            } else if (minWidth !== void 0) {
              style2.minWidth = minWidth;
            } else {
              style2.minWidth = "";
            }
            const followerRect = getRect(follower);
            const offsetContainerRect = getRect(offsetContainerRef.value);
            const { left: offsetLeftToStandardPlacement, top: offsetTopToStandardPlacement, placement: properPlacement } = getPlacementAndOffsetOfFollower(placement, targetRect, followerRect, internalShift, flip, overlap);
            const properTransformOrigin = getProperTransformOrigin(properPlacement, overlap);
            const { left, top, transform } = getOffset(properPlacement, offsetContainerRect, targetRect, offsetTopToStandardPlacement, offsetLeftToStandardPlacement, overlap);
            follower.setAttribute("v-placement", properPlacement);
            follower.style.setProperty("--v-offset-left", `${Math.round(offsetLeftToStandardPlacement)}px`);
            follower.style.setProperty("--v-offset-top", `${Math.round(offsetTopToStandardPlacement)}px`);
            follower.style.transform = `translateX(${left}) translateY(${top}) ${transform}`;
            follower.style.setProperty("--v-transform-origin", properTransformOrigin);
            follower.style.transformOrigin = properTransformOrigin;
          };
          vue.watch(mergedEnabledRef, (value) => {
            if (value) {
              ensureListeners();
              syncOnNextTick();
            } else {
              removeListeners();
            }
          });
          const syncOnNextTick = () => {
            vue.nextTick().then(syncPosition).catch((e) => console.error(e));
          };
          [
            "placement",
            "x",
            "y",
            "internalShift",
            "flip",
            "width",
            "overlap",
            "minWidth"
          ].forEach((prop) => {
            vue.watch(vue.toRef(props, prop), syncPosition);
          });
          ["teleportDisabled"].forEach((prop) => {
            vue.watch(vue.toRef(props, prop), syncOnNextTick);
          });
          vue.watch(vue.toRef(props, "syncTrigger"), (value) => {
            if (!value.includes("resize")) {
              VBinder.removeResizeListener(syncPosition);
            } else {
              VBinder.addResizeListener(syncPosition);
            }
            if (!value.includes("scroll")) {
              VBinder.removeScrollListener(syncPosition);
            } else {
              VBinder.addScrollListener(syncPosition);
            }
          });
          const isMountedRef = isMounted();
          const mergedToRef = useMemo(() => {
            const { to } = props;
            if (to !== void 0)
              return to;
            if (isMountedRef.value) {
              return void 0;
            }
            return void 0;
          });
          return {
            VBinder,
            mergedEnabled: mergedEnabledRef,
            offsetContainerRef,
            followerRef,
            mergedTo: mergedToRef,
            syncPosition
          };
        },
        render() {
          return vue.h(LazyTeleport, {
            show: this.show,
            to: this.mergedTo,
            disabled: this.teleportDisabled
          }, {
            default: () => {
              var _a, _b;
              const vNode = vue.h("div", {
                class: ["v-binder-follower-container", this.containerClass],
                ref: "offsetContainerRef"
              }, [
                vue.h("div", {
                  class: "v-binder-follower-content",
                  ref: "followerRef"
                }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a))
              ]);
              if (this.zindexable) {
                return vue.withDirectives(vNode, [
                  [
                    zindexable,
                    {
                      enabled: this.mergedEnabled,
                      zIndex: this.zIndex
                    }
                  ]
                ]);
              }
              return vNode;
            }
          });
        }
      });
      var resizeObservers = [];
      var hasActiveObservations = function() {
        return resizeObservers.some(function(ro) {
          return ro.activeTargets.length > 0;
        });
      };
      var hasSkippedObservations = function() {
        return resizeObservers.some(function(ro) {
          return ro.skippedTargets.length > 0;
        });
      };
      var msg = "ResizeObserver loop completed with undelivered notifications.";
      var deliverResizeLoopError = function() {
        var event;
        if (typeof ErrorEvent === "function") {
          event = new ErrorEvent("error", {
            message: msg
          });
        } else {
          event = document.createEvent("Event");
          event.initEvent("error", false, false);
          event.message = msg;
        }
        window.dispatchEvent(event);
      };
      var ResizeObserverBoxOptions;
      (function(ResizeObserverBoxOptions2) {
        ResizeObserverBoxOptions2["BORDER_BOX"] = "border-box";
        ResizeObserverBoxOptions2["CONTENT_BOX"] = "content-box";
        ResizeObserverBoxOptions2["DEVICE_PIXEL_CONTENT_BOX"] = "device-pixel-content-box";
      })(ResizeObserverBoxOptions || (ResizeObserverBoxOptions = {}));
      var freeze = function(obj) {
        return Object.freeze(obj);
      };
      var ResizeObserverSize = (function() {
        function ResizeObserverSize2(inlineSize, blockSize) {
          this.inlineSize = inlineSize;
          this.blockSize = blockSize;
          freeze(this);
        }
        return ResizeObserverSize2;
      })();
      var DOMRectReadOnly = (function() {
        function DOMRectReadOnly2(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          this.top = this.y;
          this.left = this.x;
          this.bottom = this.top + this.height;
          this.right = this.left + this.width;
          return freeze(this);
        }
        DOMRectReadOnly2.prototype.toJSON = function() {
          var _a = this, x = _a.x, y = _a.y, top = _a.top, right = _a.right, bottom = _a.bottom, left = _a.left, width = _a.width, height = _a.height;
          return { x, y, top, right, bottom, left, width, height };
        };
        DOMRectReadOnly2.fromRect = function(rectangle) {
          return new DOMRectReadOnly2(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
        };
        return DOMRectReadOnly2;
      })();
      var isSVG = function(target) {
        return target instanceof SVGElement && "getBBox" in target;
      };
      var isHidden = function(target) {
        if (isSVG(target)) {
          var _a = target.getBBox(), width = _a.width, height = _a.height;
          return !width && !height;
        }
        var _b = target, offsetWidth = _b.offsetWidth, offsetHeight = _b.offsetHeight;
        return !(offsetWidth || offsetHeight || target.getClientRects().length);
      };
      var isElement = function(obj) {
        var _a;
        if (obj instanceof Element) {
          return true;
        }
        var scope = (_a = obj === null || obj === void 0 ? void 0 : obj.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView;
        return !!(scope && obj instanceof scope.Element);
      };
      var isReplacedElement = function(target) {
        switch (target.tagName) {
          case "INPUT":
            if (target.type !== "image") {
              break;
            }
          case "VIDEO":
          case "AUDIO":
          case "EMBED":
          case "OBJECT":
          case "CANVAS":
          case "IFRAME":
          case "IMG":
            return true;
        }
        return false;
      };
      var global$1 = typeof window !== "undefined" ? window : {};
      var cache = new WeakMap();
      var scrollRegexp = /auto|scroll/;
      var verticalRegexp = /^tb|vertical/;
      var IE = /msie|trident/i.test(global$1.navigator && global$1.navigator.userAgent);
      var parseDimension = function(pixel) {
        return parseFloat(pixel || "0");
      };
      var size = function(inlineSize, blockSize, switchSizes) {
        if (inlineSize === void 0) {
          inlineSize = 0;
        }
        if (blockSize === void 0) {
          blockSize = 0;
        }
        if (switchSizes === void 0) {
          switchSizes = false;
        }
        return new ResizeObserverSize((switchSizes ? blockSize : inlineSize) || 0, (switchSizes ? inlineSize : blockSize) || 0);
      };
      var zeroBoxes = freeze({
        devicePixelContentBoxSize: size(),
        borderBoxSize: size(),
        contentBoxSize: size(),
        contentRect: new DOMRectReadOnly(0, 0, 0, 0)
      });
      var calculateBoxSizes = function(target, forceRecalculation) {
        if (forceRecalculation === void 0) {
          forceRecalculation = false;
        }
        if (cache.has(target) && !forceRecalculation) {
          return cache.get(target);
        }
        if (isHidden(target)) {
          cache.set(target, zeroBoxes);
          return zeroBoxes;
        }
        var cs = getComputedStyle(target);
        var svg = isSVG(target) && target.ownerSVGElement && target.getBBox();
        var removePadding = !IE && cs.boxSizing === "border-box";
        var switchSizes = verticalRegexp.test(cs.writingMode || "");
        var canScrollVertically = !svg && scrollRegexp.test(cs.overflowY || "");
        var canScrollHorizontally = !svg && scrollRegexp.test(cs.overflowX || "");
        var paddingTop = svg ? 0 : parseDimension(cs.paddingTop);
        var paddingRight = svg ? 0 : parseDimension(cs.paddingRight);
        var paddingBottom = svg ? 0 : parseDimension(cs.paddingBottom);
        var paddingLeft = svg ? 0 : parseDimension(cs.paddingLeft);
        var borderTop = svg ? 0 : parseDimension(cs.borderTopWidth);
        var borderRight = svg ? 0 : parseDimension(cs.borderRightWidth);
        var borderBottom = svg ? 0 : parseDimension(cs.borderBottomWidth);
        var borderLeft = svg ? 0 : parseDimension(cs.borderLeftWidth);
        var horizontalPadding = paddingLeft + paddingRight;
        var verticalPadding = paddingTop + paddingBottom;
        var horizontalBorderArea = borderLeft + borderRight;
        var verticalBorderArea = borderTop + borderBottom;
        var horizontalScrollbarThickness = !canScrollHorizontally ? 0 : target.offsetHeight - verticalBorderArea - target.clientHeight;
        var verticalScrollbarThickness = !canScrollVertically ? 0 : target.offsetWidth - horizontalBorderArea - target.clientWidth;
        var widthReduction = removePadding ? horizontalPadding + horizontalBorderArea : 0;
        var heightReduction = removePadding ? verticalPadding + verticalBorderArea : 0;
        var contentWidth = svg ? svg.width : parseDimension(cs.width) - widthReduction - verticalScrollbarThickness;
        var contentHeight = svg ? svg.height : parseDimension(cs.height) - heightReduction - horizontalScrollbarThickness;
        var borderBoxWidth = contentWidth + horizontalPadding + verticalScrollbarThickness + horizontalBorderArea;
        var borderBoxHeight = contentHeight + verticalPadding + horizontalScrollbarThickness + verticalBorderArea;
        var boxes = freeze({
          devicePixelContentBoxSize: size(Math.round(contentWidth * devicePixelRatio), Math.round(contentHeight * devicePixelRatio), switchSizes),
          borderBoxSize: size(borderBoxWidth, borderBoxHeight, switchSizes),
          contentBoxSize: size(contentWidth, contentHeight, switchSizes),
          contentRect: new DOMRectReadOnly(paddingLeft, paddingTop, contentWidth, contentHeight)
        });
        cache.set(target, boxes);
        return boxes;
      };
      var calculateBoxSize = function(target, observedBox, forceRecalculation) {
        var _a = calculateBoxSizes(target, forceRecalculation), borderBoxSize = _a.borderBoxSize, contentBoxSize = _a.contentBoxSize, devicePixelContentBoxSize = _a.devicePixelContentBoxSize;
        switch (observedBox) {
          case ResizeObserverBoxOptions.DEVICE_PIXEL_CONTENT_BOX:
            return devicePixelContentBoxSize;
          case ResizeObserverBoxOptions.BORDER_BOX:
            return borderBoxSize;
          default:
            return contentBoxSize;
        }
      };
      var ResizeObserverEntry = (function() {
        function ResizeObserverEntry2(target) {
          var boxes = calculateBoxSizes(target);
          this.target = target;
          this.contentRect = boxes.contentRect;
          this.borderBoxSize = freeze([boxes.borderBoxSize]);
          this.contentBoxSize = freeze([boxes.contentBoxSize]);
          this.devicePixelContentBoxSize = freeze([boxes.devicePixelContentBoxSize]);
        }
        return ResizeObserverEntry2;
      })();
      var calculateDepthForNode = function(node) {
        if (isHidden(node)) {
          return Infinity;
        }
        var depth = 0;
        var parent = node.parentNode;
        while (parent) {
          depth += 1;
          parent = parent.parentNode;
        }
        return depth;
      };
      var broadcastActiveObservations = function() {
        var shallowestDepth = Infinity;
        var callbacks2 = [];
        resizeObservers.forEach(function processObserver(ro) {
          if (ro.activeTargets.length === 0) {
            return;
          }
          var entries = [];
          ro.activeTargets.forEach(function processTarget(ot) {
            var entry = new ResizeObserverEntry(ot.target);
            var targetDepth = calculateDepthForNode(ot.target);
            entries.push(entry);
            ot.lastReportedSize = calculateBoxSize(ot.target, ot.observedBox);
            if (targetDepth < shallowestDepth) {
              shallowestDepth = targetDepth;
            }
          });
          callbacks2.push(function resizeObserverCallback() {
            ro.callback.call(ro.observer, entries, ro.observer);
          });
          ro.activeTargets.splice(0, ro.activeTargets.length);
        });
        for (var _i = 0, callbacks_1 = callbacks2; _i < callbacks_1.length; _i++) {
          var callback = callbacks_1[_i];
          callback();
        }
        return shallowestDepth;
      };
      var gatherActiveObservationsAtDepth = function(depth) {
        resizeObservers.forEach(function processObserver(ro) {
          ro.activeTargets.splice(0, ro.activeTargets.length);
          ro.skippedTargets.splice(0, ro.skippedTargets.length);
          ro.observationTargets.forEach(function processTarget(ot) {
            if (ot.isActive()) {
              if (calculateDepthForNode(ot.target) > depth) {
                ro.activeTargets.push(ot);
              } else {
                ro.skippedTargets.push(ot);
              }
            }
          });
        });
      };
      var process = function() {
        var depth = 0;
        gatherActiveObservationsAtDepth(depth);
        while (hasActiveObservations()) {
          depth = broadcastActiveObservations();
          gatherActiveObservationsAtDepth(depth);
        }
        if (hasSkippedObservations()) {
          deliverResizeLoopError();
        }
        return depth > 0;
      };
      var trigger;
      var callbacks = [];
      var notify = function() {
        return callbacks.splice(0).forEach(function(cb) {
          return cb();
        });
      };
      var queueMicroTask = function(callback) {
        if (!trigger) {
          var toggle_1 = 0;
          var el_1 = document.createTextNode("");
          var config = { characterData: true };
          new MutationObserver(function() {
            return notify();
          }).observe(el_1, config);
          trigger = function() {
            el_1.textContent = "".concat(toggle_1 ? toggle_1-- : toggle_1++);
          };
        }
        callbacks.push(callback);
        trigger();
      };
      var queueResizeObserver = function(cb) {
        queueMicroTask(function ResizeObserver2() {
          requestAnimationFrame(cb);
        });
      };
      var watching = 0;
      var isWatching = function() {
        return !!watching;
      };
      var CATCH_PERIOD = 250;
      var observerConfig = { attributes: true, characterData: true, childList: true, subtree: true };
      var events = [
        "resize",
        "load",
        "transitionend",
        "animationend",
        "animationstart",
        "animationiteration",
        "keyup",
        "keydown",
        "mouseup",
        "mousedown",
        "mouseover",
        "mouseout",
        "blur",
        "focus"
      ];
      var time = function(timeout) {
        if (timeout === void 0) {
          timeout = 0;
        }
        return Date.now() + timeout;
      };
      var scheduled = false;
      var Scheduler = (function() {
        function Scheduler2() {
          var _this = this;
          this.stopped = true;
          this.listener = function() {
            return _this.schedule();
          };
        }
        Scheduler2.prototype.run = function(timeout) {
          var _this = this;
          if (timeout === void 0) {
            timeout = CATCH_PERIOD;
          }
          if (scheduled) {
            return;
          }
          scheduled = true;
          var until = time(timeout);
          queueResizeObserver(function() {
            var elementsHaveResized = false;
            try {
              elementsHaveResized = process();
            } finally {
              scheduled = false;
              timeout = until - time();
              if (!isWatching()) {
                return;
              }
              if (elementsHaveResized) {
                _this.run(1e3);
              } else if (timeout > 0) {
                _this.run(timeout);
              } else {
                _this.start();
              }
            }
          });
        };
        Scheduler2.prototype.schedule = function() {
          this.stop();
          this.run();
        };
        Scheduler2.prototype.observe = function() {
          var _this = this;
          var cb = function() {
            return _this.observer && _this.observer.observe(document.body, observerConfig);
          };
          document.body ? cb() : global$1.addEventListener("DOMContentLoaded", cb);
        };
        Scheduler2.prototype.start = function() {
          var _this = this;
          if (this.stopped) {
            this.stopped = false;
            this.observer = new MutationObserver(this.listener);
            this.observe();
            events.forEach(function(name) {
              return global$1.addEventListener(name, _this.listener, true);
            });
          }
        };
        Scheduler2.prototype.stop = function() {
          var _this = this;
          if (!this.stopped) {
            this.observer && this.observer.disconnect();
            events.forEach(function(name) {
              return global$1.removeEventListener(name, _this.listener, true);
            });
            this.stopped = true;
          }
        };
        return Scheduler2;
      })();
      var scheduler = new Scheduler();
      var updateCount = function(n) {
        !watching && n > 0 && scheduler.start();
        watching += n;
        !watching && scheduler.stop();
      };
      var skipNotifyOnElement = function(target) {
        return !isSVG(target) && !isReplacedElement(target) && getComputedStyle(target).display === "inline";
      };
      var ResizeObservation = (function() {
        function ResizeObservation2(target, observedBox) {
          this.target = target;
          this.observedBox = observedBox || ResizeObserverBoxOptions.CONTENT_BOX;
          this.lastReportedSize = {
            inlineSize: 0,
            blockSize: 0
          };
        }
        ResizeObservation2.prototype.isActive = function() {
          var size2 = calculateBoxSize(this.target, this.observedBox, true);
          if (skipNotifyOnElement(this.target)) {
            this.lastReportedSize = size2;
          }
          if (this.lastReportedSize.inlineSize !== size2.inlineSize || this.lastReportedSize.blockSize !== size2.blockSize) {
            return true;
          }
          return false;
        };
        return ResizeObservation2;
      })();
      var ResizeObserverDetail = (function() {
        function ResizeObserverDetail2(resizeObserver, callback) {
          this.activeTargets = [];
          this.skippedTargets = [];
          this.observationTargets = [];
          this.observer = resizeObserver;
          this.callback = callback;
        }
        return ResizeObserverDetail2;
      })();
      var observerMap = new WeakMap();
      var getObservationIndex = function(observationTargets, target) {
        for (var i = 0; i < observationTargets.length; i += 1) {
          if (observationTargets[i].target === target) {
            return i;
          }
        }
        return -1;
      };
      var ResizeObserverController = (function() {
        function ResizeObserverController2() {
        }
        ResizeObserverController2.connect = function(resizeObserver, callback) {
          var detail = new ResizeObserverDetail(resizeObserver, callback);
          observerMap.set(resizeObserver, detail);
        };
        ResizeObserverController2.observe = function(resizeObserver, target, options) {
          var detail = observerMap.get(resizeObserver);
          var firstObservation = detail.observationTargets.length === 0;
          if (getObservationIndex(detail.observationTargets, target) < 0) {
            firstObservation && resizeObservers.push(detail);
            detail.observationTargets.push(new ResizeObservation(target, options && options.box));
            updateCount(1);
            scheduler.schedule();
          }
        };
        ResizeObserverController2.unobserve = function(resizeObserver, target) {
          var detail = observerMap.get(resizeObserver);
          var index = getObservationIndex(detail.observationTargets, target);
          var lastObservation = detail.observationTargets.length === 1;
          if (index >= 0) {
            lastObservation && resizeObservers.splice(resizeObservers.indexOf(detail), 1);
            detail.observationTargets.splice(index, 1);
            updateCount(-1);
          }
        };
        ResizeObserverController2.disconnect = function(resizeObserver) {
          var _this = this;
          var detail = observerMap.get(resizeObserver);
          detail.observationTargets.slice().forEach(function(ot) {
            return _this.unobserve(resizeObserver, ot.target);
          });
          detail.activeTargets.splice(0, detail.activeTargets.length);
        };
        return ResizeObserverController2;
      })();
      var ResizeObserver = (function() {
        function ResizeObserver2(callback) {
          if (arguments.length === 0) {
            throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
          }
          if (typeof callback !== "function") {
            throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
          }
          ResizeObserverController.connect(this, callback);
        }
        ResizeObserver2.prototype.observe = function(target, options) {
          if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
          }
          if (!isElement(target)) {
            throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
          }
          ResizeObserverController.observe(this, target, options);
        };
        ResizeObserver2.prototype.unobserve = function(target) {
          if (arguments.length === 0) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
          }
          if (!isElement(target)) {
            throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
          }
          ResizeObserverController.unobserve(this, target);
        };
        ResizeObserver2.prototype.disconnect = function() {
          ResizeObserverController.disconnect(this);
        };
        ResizeObserver2.toString = function() {
          return "function ResizeObserver () { [polyfill code] }";
        };
        return ResizeObserver2;
      })();
      class ResizeObserverDelegate {
        constructor() {
          this.handleResize = this.handleResize.bind(this);
          this.observer = new (typeof window !== "undefined" && window.ResizeObserver || ResizeObserver)(this.handleResize);
          this.elHandlersMap = new Map();
        }
        handleResize(entries) {
          for (const entry of entries) {
            const handler = this.elHandlersMap.get(entry.target);
            if (handler !== void 0) {
              handler(entry);
            }
          }
        }
        registerHandler(el, handler) {
          this.elHandlersMap.set(el, handler);
          this.observer.observe(el);
        }
        unregisterHandler(el) {
          if (!this.elHandlersMap.has(el)) {
            return;
          }
          this.elHandlersMap.delete(el);
          this.observer.unobserve(el);
        }
      }
      const resizeObserverManager = new ResizeObserverDelegate();
      const VResizeObserver = vue.defineComponent({
        name: "ResizeObserver",
        props: {
          onResize: Function
        },
        setup(props) {
          let registered = false;
          const proxy = vue.getCurrentInstance().proxy;
          function handleResize(entry) {
            const { onResize } = props;
            if (onResize !== void 0)
              onResize(entry);
          }
          vue.onMounted(() => {
            const el = proxy.$el;
            if (el === void 0) {
              warn$1("resize-observer", "$el does not exist.");
              return;
            }
            if (el.nextElementSibling !== el.nextSibling) {
              if (el.nodeType === 3 && el.nodeValue !== "") {
                warn$1("resize-observer", "$el can not be observed (it may be a text node).");
                return;
              }
            }
            if (el.nextElementSibling !== null) {
              resizeObserverManager.registerHandler(el.nextElementSibling, handleResize);
              registered = true;
            }
          });
          vue.onBeforeUnmount(() => {
            if (registered) {
              resizeObserverManager.unregisterHandler(proxy.$el.nextElementSibling);
            }
          });
        },
        render() {
          return vue.renderSlot(this.$slots, "default");
        }
      });
      let maybeTouch;
      function ensureMaybeTouch() {
        if (typeof document === "undefined")
          return false;
        if (maybeTouch === void 0) {
          if ("matchMedia" in window) {
            maybeTouch = window.matchMedia("(pointer:coarse)").matches;
          } else {
            maybeTouch = false;
          }
        }
        return maybeTouch;
      }
      let wheelScale;
      function ensureWheelScale() {
        if (typeof document === "undefined")
          return 1;
        if (wheelScale === void 0) {
          wheelScale = "chrome" in window ? window.devicePixelRatio : 1;
        }
        return wheelScale;
      }
      const xScrollInjextionKey = "VVirtualListXScroll";
      function setupXScroll({ columnsRef, renderColRef, renderItemWithColsRef }) {
        const listWidthRef = vue.ref(0);
        const scrollLeftRef = vue.ref(0);
        const xFinweckTreeRef = vue.computed(() => {
          const columns = columnsRef.value;
          if (columns.length === 0) {
            return null;
          }
          const ft = new FinweckTree(columns.length, 0);
          columns.forEach((column, index) => {
            ft.add(index, column.width);
          });
          return ft;
        });
        const startIndexRef = useMemo(() => {
          const xFinweckTree = xFinweckTreeRef.value;
          if (xFinweckTree !== null) {
            return Math.max(xFinweckTree.getBound(scrollLeftRef.value) - 1, 0);
          } else {
            return 0;
          }
        });
        const getLeft = (index) => {
          const xFinweckTree = xFinweckTreeRef.value;
          if (xFinweckTree !== null) {
            return xFinweckTree.sum(index);
          } else {
            return 0;
          }
        };
        const endIndexRef = useMemo(() => {
          const xFinweckTree = xFinweckTreeRef.value;
          if (xFinweckTree !== null) {
            return Math.min(xFinweckTree.getBound(scrollLeftRef.value + listWidthRef.value) + 1, columnsRef.value.length - 1);
          } else {
            return 0;
          }
        });
        vue.provide(xScrollInjextionKey, {
          startIndexRef,
          endIndexRef,
          columnsRef,
          renderColRef,
          renderItemWithColsRef,
          getLeft
        });
        return {
          listWidthRef,
          scrollLeftRef
        };
      }
      const VirtualListRow = vue.defineComponent({
        name: "VirtualListRow",
        props: {
          index: { type: Number, required: true },
          item: {
            type: Object,
            required: true
          }
        },
        setup() {
          const { startIndexRef, endIndexRef, columnsRef, getLeft, renderColRef, renderItemWithColsRef } = (
vue.inject(xScrollInjextionKey)
          );
          return {
            startIndex: startIndexRef,
            endIndex: endIndexRef,
            columns: columnsRef,
            renderCol: renderColRef,
            renderItemWithCols: renderItemWithColsRef,
            getLeft
          };
        },
        render() {
          const { startIndex, endIndex, columns, renderCol, renderItemWithCols, getLeft, item } = this;
          if (renderItemWithCols != null) {
            return renderItemWithCols({
              itemIndex: this.index,
              startColIndex: startIndex,
              endColIndex: endIndex,
              allColumns: columns,
              item,
              getLeft
            });
          }
          if (renderCol != null) {
            const items = [];
            for (let i = startIndex; i <= endIndex; ++i) {
              const column = columns[i];
              items.push(renderCol({ column, left: getLeft(i), item }));
            }
            return items;
          }
          return null;
        }
      });
      const styles$1 = c(".v-vl", {
        maxHeight: "inherit",
        height: "100%",
        overflow: "auto",
        minWidth: "1px"
}, [
        c("&:not(.v-vl--show-scrollbar)", {
          scrollbarWidth: "none"
        }, [
          c("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", {
            width: 0,
            height: 0,
            display: "none"
          })
        ])
      ]);
      const VVirtualList = vue.defineComponent({
        name: "VirtualList",
        inheritAttrs: false,
        props: {
          showScrollbar: {
            type: Boolean,
            default: true
          },
          columns: {
            type: Array,
            default: () => []
          },
          renderCol: Function,
          renderItemWithCols: Function,
          items: {
            type: Array,
            default: () => []
          },
itemSize: {
            type: Number,
            required: true
          },
          itemResizable: Boolean,
          itemsStyle: [String, Object],
          visibleItemsTag: {
            type: [String, Object],
            default: "div"
          },
          visibleItemsProps: Object,
          ignoreItemResize: Boolean,
          onScroll: Function,
          onWheel: Function,
          onResize: Function,
          defaultScrollKey: [Number, String],
          defaultScrollIndex: Number,
          keyField: {
            type: String,
            default: "key"
          },


paddingTop: {
            type: [Number, String],
            default: 0
          },
          paddingBottom: {
            type: [Number, String],
            default: 0
          }
        },
        setup(props) {
          const ssrAdapter2 = useSsrAdapter();
          styles$1.mount({
            id: "vueuc/virtual-list",
            head: true,
            anchorMetaName: cssrAnchorMetaName$1,
            ssr: ssrAdapter2
          });
          vue.onMounted(() => {
            const { defaultScrollIndex, defaultScrollKey } = props;
            if (defaultScrollIndex !== void 0 && defaultScrollIndex !== null) {
              scrollTo({ index: defaultScrollIndex });
            } else if (defaultScrollKey !== void 0 && defaultScrollKey !== null) {
              scrollTo({ key: defaultScrollKey });
            }
          });
          let isDeactivated = false;
          let activateStateInitialized = false;
          vue.onActivated(() => {
            isDeactivated = false;
            if (!activateStateInitialized) {
              activateStateInitialized = true;
              return;
            }
            scrollTo({ top: scrollTopRef.value, left: scrollLeftRef.value });
          });
          vue.onDeactivated(() => {
            isDeactivated = true;
            if (!activateStateInitialized) {
              activateStateInitialized = true;
            }
          });
          const totalWidthRef = useMemo(() => {
            if (props.renderCol == null && props.renderItemWithCols == null) {
              return void 0;
            }
            if (props.columns.length === 0)
              return void 0;
            let width = 0;
            props.columns.forEach((column) => {
              width += column.width;
            });
            return width;
          });
          const keyIndexMapRef = vue.computed(() => {
            const map2 = new Map();
            const { keyField } = props;
            props.items.forEach((item, index) => {
              map2.set(item[keyField], index);
            });
            return map2;
          });
          const { scrollLeftRef, listWidthRef } = setupXScroll({
            columnsRef: vue.toRef(props, "columns"),
            renderColRef: vue.toRef(props, "renderCol"),
            renderItemWithColsRef: vue.toRef(props, "renderItemWithCols")
          });
          const listElRef = vue.ref(null);
          const listHeightRef = vue.ref(void 0);
          const keyToHeightOffset = new Map();
          const finweckTreeRef = vue.computed(() => {
            const { items, itemSize, keyField } = props;
            const ft = new FinweckTree(items.length, itemSize);
            items.forEach((item, index) => {
              const key = item[keyField];
              const heightOffset = keyToHeightOffset.get(key);
              if (heightOffset !== void 0) {
                ft.add(index, heightOffset);
              }
            });
            return ft;
          });
          const finweckTreeUpdateTrigger = vue.ref(0);
          const scrollTopRef = vue.ref(0);
          const startIndexRef = useMemo(() => {
            return Math.max(finweckTreeRef.value.getBound(scrollTopRef.value - depx(props.paddingTop)) - 1, 0);
          });
          const viewportItemsRef = vue.computed(() => {
            const { value: listHeight } = listHeightRef;
            if (listHeight === void 0)
              return [];
            const { items, itemSize } = props;
            const startIndex = startIndexRef.value;
            const endIndex = Math.min(startIndex + Math.ceil(listHeight / itemSize + 1), items.length - 1);
            const viewportItems = [];
            for (let i = startIndex; i <= endIndex; ++i) {
              viewportItems.push(items[i]);
            }
            return viewportItems;
          });
          const scrollTo = (options, y) => {
            if (typeof options === "number") {
              scrollToPosition(options, y, "auto");
              return;
            }
            const { left, top, index, key, position, behavior, debounce: debounce2 = true } = options;
            if (left !== void 0 || top !== void 0) {
              scrollToPosition(left, top, behavior);
            } else if (index !== void 0) {
              scrollToIndex(index, behavior, debounce2);
            } else if (key !== void 0) {
              const toIndex = keyIndexMapRef.value.get(key);
              if (toIndex !== void 0)
                scrollToIndex(toIndex, behavior, debounce2);
            } else if (position === "bottom") {
              scrollToPosition(0, Number.MAX_SAFE_INTEGER, behavior);
            } else if (position === "top") {
              scrollToPosition(0, 0, behavior);
            }
          };
          let anchorIndex;
          let anchorTimerId = null;
          function scrollToIndex(index, behavior, debounce2) {
            const { value: ft } = finweckTreeRef;
            const targetTop = ft.sum(index) + depx(props.paddingTop);
            if (!debounce2) {
              listElRef.value.scrollTo({
                left: 0,
                top: targetTop,
                behavior
              });
            } else {
              anchorIndex = index;
              if (anchorTimerId !== null) {
                window.clearTimeout(anchorTimerId);
              }
              anchorTimerId = window.setTimeout(() => {
                anchorIndex = void 0;
                anchorTimerId = null;
              }, 16);
              const { scrollTop, offsetHeight } = listElRef.value;
              if (targetTop > scrollTop) {
                const itemSize = ft.get(index);
                if (targetTop + itemSize <= scrollTop + offsetHeight) ;
                else {
                  listElRef.value.scrollTo({
                    left: 0,
                    top: targetTop + itemSize - offsetHeight,
                    behavior
                  });
                }
              } else {
                listElRef.value.scrollTo({
                  left: 0,
                  top: targetTop,
                  behavior
                });
              }
            }
          }
          function scrollToPosition(left, top, behavior) {
            listElRef.value.scrollTo({
              left,
              top,
              behavior
            });
          }
          function handleItemResize(key, entry) {
            var _a, _b, _c;
            if (isDeactivated)
              return;
            if (props.ignoreItemResize)
              return;
            if (isHideByVShow(entry.target))
              return;
            const { value: ft } = finweckTreeRef;
            const index = keyIndexMapRef.value.get(key);
            const previousHeight = ft.get(index);
            const height = (_c = (_b = (_a = entry.borderBoxSize) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.blockSize) !== null && _c !== void 0 ? _c : entry.contentRect.height;
            if (height === previousHeight)
              return;
            const offset = height - props.itemSize;
            if (offset === 0) {
              keyToHeightOffset.delete(key);
            } else {
              keyToHeightOffset.set(key, height - props.itemSize);
            }
            const delta = height - previousHeight;
            if (delta === 0)
              return;
            ft.add(index, delta);
            const listEl = listElRef.value;
            if (listEl != null) {
              if (anchorIndex === void 0) {
                const previousHeightSum = ft.sum(index);
                if (listEl.scrollTop > previousHeightSum) {
                  listEl.scrollBy(0, delta);
                }
              } else {
                if (index < anchorIndex) {
                  listEl.scrollBy(0, delta);
                } else if (index === anchorIndex) {
                  const previousHeightSum = ft.sum(index);
                  if (height + previousHeightSum >

listEl.scrollTop + listEl.offsetHeight) {
                    listEl.scrollBy(0, delta);
                  }
                }
              }
              syncViewport();
            }
            finweckTreeUpdateTrigger.value++;
          }
          const mayUseWheel = !ensureMaybeTouch();
          let wheelCatched = false;
          function handleListScroll(e) {
            var _a;
            (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
            if (!mayUseWheel || !wheelCatched) {
              syncViewport();
            }
          }
          function handleListWheel(e) {
            var _a;
            (_a = props.onWheel) === null || _a === void 0 ? void 0 : _a.call(props, e);
            if (mayUseWheel) {
              const listEl = listElRef.value;
              if (listEl != null) {
                if (e.deltaX === 0) {
                  if (listEl.scrollTop === 0 && e.deltaY <= 0) {
                    return;
                  }
                  if (listEl.scrollTop + listEl.offsetHeight >= listEl.scrollHeight && e.deltaY >= 0) {
                    return;
                  }
                }
                e.preventDefault();
                listEl.scrollTop += e.deltaY / ensureWheelScale();
                listEl.scrollLeft += e.deltaX / ensureWheelScale();
                syncViewport();
                wheelCatched = true;
                beforeNextFrameOnce(() => {
                  wheelCatched = false;
                });
              }
            }
          }
          function handleListResize(entry) {
            if (isDeactivated)
              return;
            if (isHideByVShow(entry.target))
              return;
            if (props.renderCol == null && props.renderItemWithCols == null) {
              if (entry.contentRect.height === listHeightRef.value)
                return;
            } else {
              if (entry.contentRect.height === listHeightRef.value && entry.contentRect.width === listWidthRef.value) {
                return;
              }
            }
            listHeightRef.value = entry.contentRect.height;
            listWidthRef.value = entry.contentRect.width;
            const { onResize } = props;
            if (onResize !== void 0)
              onResize(entry);
          }
          function syncViewport() {
            const { value: listEl } = listElRef;
            if (listEl == null)
              return;
            scrollTopRef.value = listEl.scrollTop;
            scrollLeftRef.value = listEl.scrollLeft;
          }
          function isHideByVShow(el) {
            let cursor = el;
            while (cursor !== null) {
              if (cursor.style.display === "none")
                return true;
              cursor = cursor.parentElement;
            }
            return false;
          }
          return {
            listHeight: listHeightRef,
            listStyle: {
              overflow: "auto"
            },
            keyToIndex: keyIndexMapRef,
            itemsStyle: vue.computed(() => {
              const { itemResizable } = props;
              const height = pxfy(finweckTreeRef.value.sum());
              finweckTreeUpdateTrigger.value;
              return [
                props.itemsStyle,
                {
                  boxSizing: "content-box",
                  width: pxfy(totalWidthRef.value),
                  height: itemResizable ? "" : height,
                  minHeight: itemResizable ? height : "",
                  paddingTop: pxfy(props.paddingTop),
                  paddingBottom: pxfy(props.paddingBottom)
                }
              ];
            }),
            visibleItemsStyle: vue.computed(() => {
              finweckTreeUpdateTrigger.value;
              return {
                transform: `translateY(${pxfy(finweckTreeRef.value.sum(startIndexRef.value))})`
              };
            }),
            viewportItems: viewportItemsRef,
            listElRef,
            itemsElRef: vue.ref(null),
            scrollTo,
            handleListResize,
            handleListScroll,
            handleListWheel,
            handleItemResize
          };
        },
        render() {
          const { itemResizable, keyField, keyToIndex, visibleItemsTag } = this;
          return vue.h(VResizeObserver, {
            onResize: this.handleListResize
          }, {
            default: () => {
              var _a, _b;
              return vue.h("div", vue.mergeProps(this.$attrs, {
                class: ["v-vl", this.showScrollbar && "v-vl--show-scrollbar"],
                onScroll: this.handleListScroll,
                onWheel: this.handleListWheel,
                ref: "listElRef"
              }), [
                this.items.length !== 0 ? vue.h("div", {
                  ref: "itemsElRef",
                  class: "v-vl-items",
                  style: this.itemsStyle
                }, [
                  vue.h(visibleItemsTag, Object.assign({
                    class: "v-vl-visible-items",
                    style: this.visibleItemsStyle
                  }, this.visibleItemsProps), {
                    default: () => {
                      const { renderCol, renderItemWithCols } = this;
                      return this.viewportItems.map((item) => {
                        const key = item[keyField];
                        const index = keyToIndex.get(key);
                        const renderedCols = renderCol != null ? vue.h(VirtualListRow, {
                          index,
                          item
                        }) : void 0;
                        const renderedItemWithCols = renderItemWithCols != null ? vue.h(VirtualListRow, {
                          index,
                          item
                        }) : void 0;
                        const itemVNode = this.$slots.default({
                          item,
                          renderedCols,
                          renderedItemWithCols,
                          index
                        })[0];
                        if (itemResizable) {
                          return vue.h(VResizeObserver, {
                            key,
                            onResize: (entry) => this.handleItemResize(key, entry)
                          }, {
                            default: () => itemVNode
                          });
                        }
                        itemVNode.key = key;
                        return itemVNode;
                      });
                    }
                  })
                ]) : (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a)
              ]);
            }
          });
        }
      });
      const styles = c(".v-x-scroll", {
        overflow: "auto",
        scrollbarWidth: "none"
      }, [
        c("&::-webkit-scrollbar", {
          width: 0,
          height: 0
        })
      ]);
      const VXScroll = vue.defineComponent({
        name: "XScroll",
        props: {
          disabled: Boolean,
          onScroll: Function
        },
        setup() {
          const selfRef = vue.ref(null);
          function handleWheel(e) {
            const preventYWheel = e.currentTarget.offsetWidth < e.currentTarget.scrollWidth;
            if (!preventYWheel || e.deltaY === 0)
              return;
            e.currentTarget.scrollLeft += e.deltaY + e.deltaX;
            e.preventDefault();
          }
          const ssrAdapter2 = useSsrAdapter();
          styles.mount({
            id: "vueuc/x-scroll",
            head: true,
            anchorMetaName: cssrAnchorMetaName$1,
            ssr: ssrAdapter2
          });
          const exposedMethods = {
            scrollTo(...args) {
              var _a;
              (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(...args);
            }
          };
          return Object.assign({
            selfRef,
            handleWheel
          }, exposedMethods);
        },
        render() {
          return vue.h("div", {
            ref: "selfRef",
            onScroll: this.onScroll,
            onWheel: this.disabled ? void 0 : this.handleWheel,
            class: "v-x-scroll"
          }, this.$slots);
        }
      });
      const hiddenAttr = "v-hidden";
      const style$y = c("[v-hidden]", {
        display: "none!important"
      });
      const VOverflow = vue.defineComponent({
        name: "Overflow",
        props: {
          getCounter: Function,
          getTail: Function,
          updateCounter: Function,
          onUpdateCount: Function,
          onUpdateOverflow: Function
        },
        setup(props, { slots }) {
          const selfRef = vue.ref(null);
          const counterRef = vue.ref(null);
          function deriveCounter(options) {
            const { value: self2 } = selfRef;
            const { getCounter, getTail } = props;
            let counter;
            if (getCounter !== void 0)
              counter = getCounter();
            else {
              counter = counterRef.value;
            }
            if (!self2 || !counter)
              return;
            if (counter.hasAttribute(hiddenAttr)) {
              counter.removeAttribute(hiddenAttr);
            }
            const { children } = self2;
            if (options.showAllItemsBeforeCalculate) {
              for (const child of children) {
                if (child.hasAttribute(hiddenAttr)) {
                  child.removeAttribute(hiddenAttr);
                }
              }
            }
            const containerWidth = self2.offsetWidth;
            const childWidths = [];
            const tail = slots.tail ? getTail === null || getTail === void 0 ? void 0 : getTail() : null;
            let childWidthSum = tail ? tail.offsetWidth : 0;
            let overflow = false;
            const len2 = self2.children.length - (slots.tail ? 1 : 0);
            for (let i = 0; i < len2 - 1; ++i) {
              if (i < 0)
                continue;
              const child = children[i];
              if (overflow) {
                if (!child.hasAttribute(hiddenAttr)) {
                  child.setAttribute(hiddenAttr, "");
                }
                continue;
              } else if (child.hasAttribute(hiddenAttr)) {
                child.removeAttribute(hiddenAttr);
              }
              const childWidth = child.offsetWidth;
              childWidthSum += childWidth;
              childWidths[i] = childWidth;
              if (childWidthSum > containerWidth) {
                const { updateCounter } = props;
                for (let j = i; j >= 0; --j) {
                  const restCount = len2 - 1 - j;
                  if (updateCounter !== void 0) {
                    updateCounter(restCount);
                  } else {
                    counter.textContent = `${restCount}`;
                  }
                  const counterWidth = counter.offsetWidth;
                  childWidthSum -= childWidths[j];
                  if (childWidthSum + counterWidth <= containerWidth || j === 0) {
                    overflow = true;
                    i = j - 1;
                    if (tail) {
                      if (i === -1) {
                        tail.style.maxWidth = `${containerWidth - counterWidth}px`;
                        tail.style.boxSizing = "border-box";
                      } else {
                        tail.style.maxWidth = "";
                      }
                    }
                    const { onUpdateCount } = props;
                    if (onUpdateCount)
                      onUpdateCount(restCount);
                    break;
                  }
                }
              }
            }
            const { onUpdateOverflow } = props;
            if (!overflow) {
              if (onUpdateOverflow !== void 0) {
                onUpdateOverflow(false);
              }
              counter.setAttribute(hiddenAttr, "");
            } else {
              if (onUpdateOverflow !== void 0) {
                onUpdateOverflow(true);
              }
            }
          }
          const ssrAdapter2 = useSsrAdapter();
          style$y.mount({
            id: "vueuc/overflow",
            head: true,
            anchorMetaName: cssrAnchorMetaName$1,
            ssr: ssrAdapter2
          });
          vue.onMounted(() => deriveCounter({
            showAllItemsBeforeCalculate: false
          }));
          return {
            selfRef,
            counterRef,
            sync: deriveCounter
          };
        },
        render() {
          const { $slots } = this;
          vue.nextTick(() => this.sync({
            showAllItemsBeforeCalculate: false
          }));
          return vue.h("div", {
            class: "v-overflow",
            ref: "selfRef"
          }, [
            vue.renderSlot($slots, "default"),
$slots.counter ? $slots.counter() : vue.h("span", {
              style: {
                display: "inline-block"
              },
              ref: "counterRef"
            }),
$slots.tail ? $slots.tail() : null
          ]);
        }
      });
      function isHTMLElement(node) {
        return node instanceof HTMLElement;
      }
      function focusFirstDescendant(node) {
        for (let i = 0; i < node.childNodes.length; i++) {
          const child = node.childNodes[i];
          if (isHTMLElement(child)) {
            if (attemptFocus(child) || focusFirstDescendant(child)) {
              return true;
            }
          }
        }
        return false;
      }
      function focusLastDescendant(element) {
        for (let i = element.childNodes.length - 1; i >= 0; i--) {
          const child = element.childNodes[i];
          if (isHTMLElement(child)) {
            if (attemptFocus(child) || focusLastDescendant(child)) {
              return true;
            }
          }
        }
        return false;
      }
      function attemptFocus(element) {
        if (!isFocusable(element)) {
          return false;
        }
        try {
          element.focus({ preventScroll: true });
        } catch (e) {
        }
        return document.activeElement === element;
      }
      function isFocusable(element) {
        if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null) {
          return true;
        }
        if (element.getAttribute("disabled")) {
          return false;
        }
        switch (element.nodeName) {
          case "A":
            return !!element.href && element.rel !== "ignore";
          case "INPUT":
            return element.type !== "hidden" && element.type !== "file";
          case "SELECT":
          case "TEXTAREA":
            return true;
          default:
            return false;
        }
      }
      let stack = [];
      const FocusTrap = vue.defineComponent({
        name: "FocusTrap",
        props: {
          disabled: Boolean,
          active: Boolean,
          autoFocus: {
            type: Boolean,
            default: true
          },
          onEsc: Function,
          initialFocusTo: [String, Function],
          finalFocusTo: [String, Function],
          returnFocusOnDeactivated: {
            type: Boolean,
            default: true
          }
        },
        setup(props) {
          const id = createId();
          const focusableStartRef = vue.ref(null);
          const focusableEndRef = vue.ref(null);
          let activated = false;
          let ignoreInternalFocusChange = false;
          const lastFocusedElement = typeof document === "undefined" ? null : document.activeElement;
          function isCurrentActive() {
            const currentActiveId = stack[stack.length - 1];
            return currentActiveId === id;
          }
          function handleDocumentKeydown(e) {
            var _a;
            if (e.code === "Escape") {
              if (isCurrentActive()) {
                (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props, e);
              }
            }
          }
          vue.onMounted(() => {
            vue.watch(() => props.active, (value) => {
              if (value) {
                activate();
                on("keydown", document, handleDocumentKeydown);
              } else {
                off("keydown", document, handleDocumentKeydown);
                if (activated) {
                  deactivate();
                }
              }
            }, {
              immediate: true
            });
          });
          vue.onBeforeUnmount(() => {
            off("keydown", document, handleDocumentKeydown);
            if (activated)
              deactivate();
          });
          function handleDocumentFocus(e) {
            if (ignoreInternalFocusChange)
              return;
            if (isCurrentActive()) {
              const mainEl = getMainEl();
              if (mainEl === null)
                return;
              if (mainEl.contains(getPreciseEventTarget(e)))
                return;
              resetFocusTo("first");
            }
          }
          function getMainEl() {
            const focusableStartEl = focusableStartRef.value;
            if (focusableStartEl === null)
              return null;
            let mainEl = focusableStartEl;
            while (true) {
              mainEl = mainEl.nextSibling;
              if (mainEl === null)
                break;
              if (mainEl instanceof Element && mainEl.tagName === "DIV") {
                break;
              }
            }
            return mainEl;
          }
          function activate() {
            var _a;
            if (props.disabled)
              return;
            stack.push(id);
            if (props.autoFocus) {
              const { initialFocusTo } = props;
              if (initialFocusTo === void 0) {
                resetFocusTo("first");
              } else {
                (_a = resolveTo(initialFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
              }
            }
            activated = true;
            document.addEventListener("focus", handleDocumentFocus, true);
          }
          function deactivate() {
            var _a;
            if (props.disabled)
              return;
            document.removeEventListener("focus", handleDocumentFocus, true);
            stack = stack.filter((idInStack) => idInStack !== id);
            if (isCurrentActive())
              return;
            const { finalFocusTo } = props;
            if (finalFocusTo !== void 0) {
              (_a = resolveTo(finalFocusTo)) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
            } else if (props.returnFocusOnDeactivated) {
              if (lastFocusedElement instanceof HTMLElement) {
                ignoreInternalFocusChange = true;
                lastFocusedElement.focus({ preventScroll: true });
                ignoreInternalFocusChange = false;
              }
            }
          }
          function resetFocusTo(target) {
            if (!isCurrentActive())
              return;
            if (props.active) {
              const focusableStartEl = focusableStartRef.value;
              const focusableEndEl = focusableEndRef.value;
              if (focusableStartEl !== null && focusableEndEl !== null) {
                const mainEl = getMainEl();
                if (mainEl == null || mainEl === focusableEndEl) {
                  ignoreInternalFocusChange = true;
                  focusableStartEl.focus({ preventScroll: true });
                  ignoreInternalFocusChange = false;
                  return;
                }
                ignoreInternalFocusChange = true;
                const focused = target === "first" ? focusFirstDescendant(mainEl) : focusLastDescendant(mainEl);
                ignoreInternalFocusChange = false;
                if (!focused) {
                  ignoreInternalFocusChange = true;
                  focusableStartEl.focus({ preventScroll: true });
                  ignoreInternalFocusChange = false;
                }
              }
            }
          }
          function handleStartFocus(e) {
            if (ignoreInternalFocusChange)
              return;
            const mainEl = getMainEl();
            if (mainEl === null)
              return;
            if (e.relatedTarget !== null && mainEl.contains(e.relatedTarget)) {
              resetFocusTo("last");
            } else {
              resetFocusTo("first");
            }
          }
          function handleEndFocus(e) {
            if (ignoreInternalFocusChange)
              return;
            if (e.relatedTarget !== null && e.relatedTarget === focusableStartRef.value) {
              resetFocusTo("last");
            } else {
              resetFocusTo("first");
            }
          }
          return {
            focusableStartRef,
            focusableEndRef,
            focusableStyle: "position: absolute; height: 0; width: 0;",
            handleStartFocus,
            handleEndFocus
          };
        },
        render() {
          const { default: defaultSlot } = this.$slots;
          if (defaultSlot === void 0)
            return null;
          if (this.disabled)
            return defaultSlot();
          const { active, focusableStyle } = this;
          return vue.h(vue.Fragment, null, [
            vue.h("div", {
              "aria-hidden": "true",
              tabindex: active ? "0" : "-1",
              ref: "focusableStartRef",
              style: focusableStyle,
              onFocus: this.handleStartFocus
            }),
            defaultSlot(),
            vue.h("div", {
              "aria-hidden": "true",
              style: focusableStyle,
              ref: "focusableEndRef",
              tabindex: active ? "0" : "-1",
              onFocus: this.handleEndFocus
            })
          ]);
        }
      });
      function useOnResize(elRef, onResize) {
        if (onResize) {
          vue.onMounted(() => {
            const {
              value: el
            } = elRef;
            if (el) {
              resizeObserverManager.registerHandler(el, onResize);
            }
          });
          vue.watch(elRef, (_, oldEl) => {
            if (oldEl) {
              resizeObserverManager.unregisterHandler(oldEl);
            }
          }, {
            deep: false
          });
          vue.onBeforeUnmount(() => {
            const {
              value: el
            } = elRef;
            if (el) {
              resizeObserverManager.unregisterHandler(el);
            }
          });
        }
      }
      function color2Class(color) {
        return color.replace(/#|\(|\)|,|\s|\./g, "_");
      }
      const pureNumberRegex = /^(\d|\.)+$/;
      const numberRegex = /(\d|\.)+/;
      function formatLength(length, {
        c: c2 = 1,
        offset = 0,
        attachPx = true
      } = {}) {
        if (typeof length === "number") {
          const result = (length + offset) * c2;
          if (result === 0) return "0";
          return `${result}px`;
        } else if (typeof length === "string") {
          if (pureNumberRegex.test(length)) {
            const result = (Number(length) + offset) * c2;
            if (attachPx) {
              if (result === 0) return "0";
              return `${result}px`;
            } else {
              return `${result}`;
            }
          } else {
            const result = numberRegex.exec(length);
            if (!result) return length;
            return length.replace(numberRegex, String((Number(result[0]) + offset) * c2));
          }
        }
        return length;
      }
      function rtlInset(inset) {
        const {
          left,
          right,
          top,
          bottom
        } = getMargin(inset);
        return `${top} ${left} ${bottom} ${right}`;
      }
      function download(url, name) {
        if (!url) return;
        const a = document.createElement("a");
        a.href = url;
        if (name !== void 0) {
          a.download = name;
        }
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
      }
      let _isJsdom;
      function isJsdom() {
        if (_isJsdom === void 0) {
          _isJsdom = navigator.userAgent.includes("Node.js") || navigator.userAgent.includes("jsdom");
        }
        return _isJsdom;
      }
      const eventSet = new WeakSet();
      function markEventEffectPerformed(event) {
        eventSet.add(event);
      }
      function eventEffectNotPerformed(event) {
        return !eventSet.has(event);
      }
      function getTitleAttribute(value) {
        switch (typeof value) {
          case "string":
            return value || void 0;
          case "number":
            return String(value);
          default:
            return void 0;
        }
      }
      const smallerSizeMap = {
        tiny: "mini",
        small: "tiny",
        medium: "small",
        large: "medium",
        huge: "large"
      };
      function smallerSize(size2) {
        const result = smallerSizeMap[size2];
        if (result === void 0) {
          throw new Error(`${size2} has no smaller size.`);
        }
        return result;
      }
      function warn(location, message2) {
        console.error(`[naive/${location}]: ${message2}`);
      }
      function throwError(location, message2) {
        throw new Error(`[naive/${location}]: ${message2}`);
      }
      function call(funcs, ...args) {
        if (Array.isArray(funcs)) {
          funcs.forEach((func) => call(func, ...args));
        } else {
          return funcs(...args);
        }
      }
      function createRefSetter(ref2) {
        return (inst) => {
          if (inst) {
            ref2.value = inst.$el;
          } else {
            ref2.value = null;
          }
        };
      }
      function flatten$2(vNodes, filterCommentNode = true, result = []) {
        vNodes.forEach((vNode) => {
          if (vNode === null) return;
          if (typeof vNode !== "object") {
            if (typeof vNode === "string" || typeof vNode === "number") {
              result.push(vue.createTextVNode(String(vNode)));
            }
            return;
          }
          if (Array.isArray(vNode)) {
            flatten$2(vNode, filterCommentNode, result);
            return;
          }
          if (vNode.type === vue.Fragment) {
            if (vNode.children === null) return;
            if (Array.isArray(vNode.children)) {
              flatten$2(vNode.children, filterCommentNode, result);
            }
          } else {
            if (vNode.type === vue.Comment && filterCommentNode) return;
            result.push(vNode);
          }
        });
        return result;
      }
      function getFirstSlotVNode(slots, slotName = "default", props = void 0) {
        const slot = slots[slotName];
        if (!slot) {
          warn("getFirstSlotVNode", `slot[${slotName}] is empty`);
          return null;
        }
        const slotContent = flatten$2(slot(props));
        if (slotContent.length === 1) {
          return slotContent[0];
        } else {
          warn("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
          return null;
        }
      }
      function getFirstSlotVNodeWithTypedProps(slotName, slot, props) {
        if (!slot) {
          return null;
        }
        const slotContent = flatten$2(slot(props));
        if (slotContent.length === 1) {
          return slotContent[0];
        } else {
          warn("getFirstSlotVNode", `slot[${slotName}] should have exactly one child`);
          return null;
        }
      }
      function getSlot(instance, slotName = "default", fallback = []) {
        const slots = instance.$slots;
        const slot = slots[slotName];
        if (slot === void 0) return fallback;
        return slot();
      }
      function keep(object, keys2 = [], rest) {
        const keepedObject = {};
        keys2.forEach((key) => {
          keepedObject[key] = object[key];
        });
        return Object.assign(keepedObject, rest);
      }
      function keysOf(obj) {
        return Object.keys(obj);
      }
      function mergeEventHandlers(handlers) {
        const filteredHandlers = handlers.filter((handler) => handler !== void 0);
        if (filteredHandlers.length === 0) return void 0;
        if (filteredHandlers.length === 1) return filteredHandlers[0];
        return (e) => {
          handlers.forEach((handler) => {
            if (handler) {
              handler(e);
            }
          });
        };
      }
      function omit(object, keys2 = [], rest) {
        const omitedObject = {};
        const originalKeys = Object.getOwnPropertyNames(object);
        originalKeys.forEach((originalKey) => {
          if (!keys2.includes(originalKey)) {
            omitedObject[originalKey] = object[originalKey];
          }
        });
        return Object.assign(omitedObject, rest);
      }
      function render(r, ...args) {
        if (typeof r === "function") {
          return r(...args);
        } else if (typeof r === "string") {
          return vue.createTextVNode(r);
        } else if (typeof r === "number") {
          return vue.createTextVNode(String(r));
        } else {
          return null;
        }
      }
      function ensureValidVNode(vnodes) {
        return vnodes.some((child) => {
          if (!vue.isVNode(child)) {
            return true;
          }
          if (child.type === vue.Comment) {
            return false;
          }
          if (child.type === vue.Fragment && !ensureValidVNode(child.children)) {
            return false;
          }
          return true;
        }) ? vnodes : null;
      }
      function resolveSlot(slot, fallback) {
        return slot && ensureValidVNode(slot()) || fallback();
      }
      function resolveSlotWithTypedProps(slot, props, fallback) {
        return slot && ensureValidVNode(slot(props)) || fallback(props);
      }
      function resolveWrappedSlot(slot, wrapper) {
        const children = slot && ensureValidVNode(slot());
        return wrapper(children || null);
      }
      function isSlotEmpty(slot) {
        return !(slot && ensureValidVNode(slot()));
      }
      const Wrapper = vue.defineComponent({
        render() {
          var _a, _b;
          return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
        }
      });
      const configProviderInjectionKey = createInjectionKey("n-config-provider");
      const defaultClsPrefix = "n";
      function useConfig(props = {}, options = {
        defaultBordered: true
      }) {
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        return {
inlineThemeDisabled: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled,
          mergedRtlRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef,
          mergedComponentPropsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef,
          mergedBreakpointsRef: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef,
          mergedBorderedRef: vue.computed(() => {
            var _a, _b;
            const {
              bordered
            } = props;
            if (bordered !== void 0) return bordered;
            return (_b = (_a = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value) !== null && _a !== void 0 ? _a : options.defaultBordered) !== null && _b !== void 0 ? _b : true;
          }),
          mergedClsPrefixRef: NConfigProvider2 ? NConfigProvider2.mergedClsPrefixRef : vue.shallowRef(defaultClsPrefix),
          namespaceRef: vue.computed(() => NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value)
        };
      }
      function useMergedClsPrefix() {
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        return NConfigProvider2 ? NConfigProvider2.mergedClsPrefixRef : vue.shallowRef(defaultClsPrefix);
      }
      function useThemeClass(componentName, hashRef, cssVarsRef, props) {
        if (!cssVarsRef) throwError("useThemeClass", "cssVarsRef is not passed");
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        const mergedThemeHashRef = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeHashRef;
        const styleMountTarget = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget;
        const themeClassRef = vue.ref("");
        const ssrAdapter2 = useSsrAdapter();
        let renderCallback;
        const hashClassPrefix = `__${componentName}`;
        const mountStyle = () => {
          let finalThemeHash = hashClassPrefix;
          const hashValue = hashRef ? hashRef.value : void 0;
          const themeHash = mergedThemeHashRef === null || mergedThemeHashRef === void 0 ? void 0 : mergedThemeHashRef.value;
          if (themeHash) finalThemeHash += `-${themeHash}`;
          if (hashValue) finalThemeHash += `-${hashValue}`;
          const {
            themeOverrides,
            builtinThemeOverrides
          } = props;
          if (themeOverrides) {
            finalThemeHash += `-${murmur2(JSON.stringify(themeOverrides))}`;
          }
          if (builtinThemeOverrides) {
            finalThemeHash += `-${murmur2(JSON.stringify(builtinThemeOverrides))}`;
          }
          themeClassRef.value = finalThemeHash;
          renderCallback = () => {
            const cssVars = cssVarsRef.value;
            let style2 = "";
            for (const key in cssVars) {
              style2 += `${key}: ${cssVars[key]};`;
            }
            c$1(`.${finalThemeHash}`, style2).mount({
              id: finalThemeHash,
              ssr: ssrAdapter2,
              parent: styleMountTarget
            });
            renderCallback = void 0;
          };
        };
        vue.watchEffect(() => {
          mountStyle();
        });
        return {
          themeClass: themeClassRef,
          onRender: () => {
            renderCallback === null || renderCallback === void 0 ? void 0 : renderCallback();
          }
        };
      }
      const formItemInjectionKey = createInjectionKey("n-form-item");
      function useFormItem(props, {
        defaultSize = "medium",
        mergedSize,
        mergedDisabled
      } = {}) {
        const NFormItem2 = vue.inject(formItemInjectionKey, null);
        vue.provide(formItemInjectionKey, null);
        const mergedSizeRef = vue.computed(mergedSize ? () => mergedSize(NFormItem2) : () => {
          const {
            size: size2
          } = props;
          if (size2) return size2;
          if (NFormItem2) {
            const {
              mergedSize: mergedSize2
            } = NFormItem2;
            if (mergedSize2.value !== void 0) {
              return mergedSize2.value;
            }
          }
          return defaultSize;
        });
        const mergedDisabledRef = vue.computed(mergedDisabled ? () => mergedDisabled(NFormItem2) : () => {
          const {
            disabled
          } = props;
          if (disabled !== void 0) {
            return disabled;
          }
          if (NFormItem2) {
            return NFormItem2.disabled.value;
          }
          return false;
        });
        const mergedStatusRef = vue.computed(() => {
          const {
            status
          } = props;
          if (status) return status;
          return NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.mergedValidationStatus.value;
        });
        vue.onBeforeUnmount(() => {
          if (NFormItem2) {
            NFormItem2.restoreValidation();
          }
        });
        return {
          mergedSizeRef,
          mergedDisabledRef,
          mergedStatusRef,
          nTriggerFormBlur() {
            if (NFormItem2) {
              NFormItem2.handleContentBlur();
            }
          },
          nTriggerFormChange() {
            if (NFormItem2) {
              NFormItem2.handleContentChange();
            }
          },
          nTriggerFormFocus() {
            if (NFormItem2) {
              NFormItem2.handleContentFocus();
            }
          },
          nTriggerFormInput() {
            if (NFormItem2) {
              NFormItem2.handleContentInput();
            }
          }
        };
      }
      const enUS$1 = {
        name: "en-US",
        global: {
          undo: "Undo",
          redo: "Redo",
          confirm: "Confirm",
          clear: "Clear"
        },
        Popconfirm: {
          positiveText: "Confirm",
          negativeText: "Cancel"
        },
        Cascader: {
          placeholder: "Please Select",
          loading: "Loading",
          loadingRequiredMessage: (label) => `Please load all ${label}'s descendants before checking it.`
        },
        Time: {
          dateFormat: "yyyy-MM-dd",
          dateTimeFormat: "yyyy-MM-dd HH:mm:ss"
        },
        DatePicker: {
          yearFormat: "yyyy",
          monthFormat: "MMM",
          dayFormat: "eeeeee",
          yearTypeFormat: "yyyy",
          monthTypeFormat: "yyyy-MM",
          dateFormat: "yyyy-MM-dd",
          dateTimeFormat: "yyyy-MM-dd HH:mm:ss",
          quarterFormat: "yyyy-qqq",
          weekFormat: "YYYY-w",
          clear: "Clear",
          now: "Now",
          confirm: "Confirm",
          selectTime: "Select Time",
          selectDate: "Select Date",
          datePlaceholder: "Select Date",
          datetimePlaceholder: "Select Date and Time",
          monthPlaceholder: "Select Month",
          yearPlaceholder: "Select Year",
          quarterPlaceholder: "Select Quarter",
          weekPlaceholder: "Select Week",
          startDatePlaceholder: "Start Date",
          endDatePlaceholder: "End Date",
          startDatetimePlaceholder: "Start Date and Time",
          endDatetimePlaceholder: "End Date and Time",
          startMonthPlaceholder: "Start Month",
          endMonthPlaceholder: "End Month",
          monthBeforeYear: true,
          firstDayOfWeek: 6,
          today: "Today"
        },
        DataTable: {
          checkTableAll: "Select all in the table",
          uncheckTableAll: "Unselect all in the table",
          confirm: "Confirm",
          clear: "Clear"
        },
        LegacyTransfer: {
          sourceTitle: "Source",
          targetTitle: "Target"
        },
        Transfer: {
          selectAll: "Select all",
          unselectAll: "Unselect all",
          clearAll: "Clear",
          total: (num) => `Total ${num} items`,
          selected: (num) => `${num} items selected`
        },
        Empty: {
          description: "No Data"
        },
        Select: {
          placeholder: "Please Select"
        },
        TimePicker: {
          placeholder: "Select Time",
          positiveText: "OK",
          negativeText: "Cancel",
          now: "Now",
          clear: "Clear"
        },
        Pagination: {
          goto: "Goto",
          selectionSuffix: "page"
        },
        DynamicTags: {
          add: "Add"
        },
        Log: {
          loading: "Loading"
        },
        Input: {
          placeholder: "Please Input"
        },
        InputNumber: {
          placeholder: "Please Input"
        },
        DynamicInput: {
          create: "Create"
        },
        ThemeEditor: {
          title: "Theme Editor",
          clearAllVars: "Clear All Variables",
          clearSearch: "Clear Search",
          filterCompName: "Filter Component Name",
          filterVarName: "Filter Variable Name",
          import: "Import",
          export: "Export",
          restore: "Reset to Default"
        },
        Image: {
          tipPrevious: "Previous picture (←)",
          tipNext: "Next picture (→)",
          tipCounterclockwise: "Counterclockwise",
          tipClockwise: "Clockwise",
          tipZoomOut: "Zoom out",
          tipZoomIn: "Zoom in",
          tipDownload: "Download",
          tipClose: "Close (Esc)",
tipOriginalSize: "Zoom to original size"
        },
        Heatmap: {
          less: "less",
          more: "more",
          monthFormat: "MMM",
          weekdayFormat: "eee"
        }
      };
      function buildFormatLongFn(args) {
        return (options = {}) => {
          const width = options.width ? String(options.width) : args.defaultWidth;
          const format2 = args.formats[width] || args.formats[args.defaultWidth];
          return format2;
        };
      }
      function buildLocalizeFn(args) {
        return (value, options) => {
          const context = options?.context ? String(options.context) : "standalone";
          let valuesArray;
          if (context === "formatting" && args.formattingValues) {
            const defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
            const width = options?.width ? String(options.width) : defaultWidth;
            valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
          } else {
            const defaultWidth = args.defaultWidth;
            const width = options?.width ? String(options.width) : args.defaultWidth;
            valuesArray = args.values[width] || args.values[defaultWidth];
          }
          const index = args.argumentCallback ? args.argumentCallback(value) : value;
          return valuesArray[index];
        };
      }
      function buildMatchFn(args) {
        return (string2, options = {}) => {
          const width = options.width;
          const matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
          const matchResult = string2.match(matchPattern);
          if (!matchResult) {
            return null;
          }
          const matchedString = matchResult[0];
          const parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
          const key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, (pattern) => pattern.test(matchedString)) : (
findKey(parsePatterns, (pattern) => pattern.test(matchedString))
          );
          let value;
          value = args.valueCallback ? args.valueCallback(key) : key;
          value = options.valueCallback ? (
options.valueCallback(value)
          ) : value;
          const rest = string2.slice(matchedString.length);
          return { value, rest };
        };
      }
      function findKey(object, predicate) {
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key) && predicate(object[key])) {
            return key;
          }
        }
        return void 0;
      }
      function findIndex(array, predicate) {
        for (let key = 0; key < array.length; key++) {
          if (predicate(array[key])) {
            return key;
          }
        }
        return void 0;
      }
      function buildMatchPatternFn(args) {
        return (string2, options = {}) => {
          const matchResult = string2.match(args.matchPattern);
          if (!matchResult) return null;
          const matchedString = matchResult[0];
          const parseResult = string2.match(args.parsePattern);
          if (!parseResult) return null;
          let value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
          value = options.valueCallback ? options.valueCallback(value) : value;
          const rest = string2.slice(matchedString.length);
          return { value, rest };
        };
      }
      const formatDistanceLocale = {
        lessThanXSeconds: {
          one: "less than a second",
          other: "less than {{count}} seconds"
        },
        xSeconds: {
          one: "1 second",
          other: "{{count}} seconds"
        },
        halfAMinute: "half a minute",
        lessThanXMinutes: {
          one: "less than a minute",
          other: "less than {{count}} minutes"
        },
        xMinutes: {
          one: "1 minute",
          other: "{{count}} minutes"
        },
        aboutXHours: {
          one: "about 1 hour",
          other: "about {{count}} hours"
        },
        xHours: {
          one: "1 hour",
          other: "{{count}} hours"
        },
        xDays: {
          one: "1 day",
          other: "{{count}} days"
        },
        aboutXWeeks: {
          one: "about 1 week",
          other: "about {{count}} weeks"
        },
        xWeeks: {
          one: "1 week",
          other: "{{count}} weeks"
        },
        aboutXMonths: {
          one: "about 1 month",
          other: "about {{count}} months"
        },
        xMonths: {
          one: "1 month",
          other: "{{count}} months"
        },
        aboutXYears: {
          one: "about 1 year",
          other: "about {{count}} years"
        },
        xYears: {
          one: "1 year",
          other: "{{count}} years"
        },
        overXYears: {
          one: "over 1 year",
          other: "over {{count}} years"
        },
        almostXYears: {
          one: "almost 1 year",
          other: "almost {{count}} years"
        }
      };
      const formatDistance = (token, count, options) => {
        let result;
        const tokenValue = formatDistanceLocale[token];
        if (typeof tokenValue === "string") {
          result = tokenValue;
        } else if (count === 1) {
          result = tokenValue.one;
        } else {
          result = tokenValue.other.replace("{{count}}", count.toString());
        }
        if (options?.addSuffix) {
          if (options.comparison && options.comparison > 0) {
            return "in " + result;
          } else {
            return result + " ago";
          }
        }
        return result;
      };
      const formatRelativeLocale = {
        lastWeek: "'last' eeee 'at' p",
        yesterday: "'yesterday at' p",
        today: "'today at' p",
        tomorrow: "'tomorrow at' p",
        nextWeek: "eeee 'at' p",
        other: "P"
      };
      const formatRelative = (token, _date, _baseDate, _options) => formatRelativeLocale[token];
      const eraValues = {
        narrow: ["B", "A"],
        abbreviated: ["BC", "AD"],
        wide: ["Before Christ", "Anno Domini"]
      };
      const quarterValues = {
        narrow: ["1", "2", "3", "4"],
        abbreviated: ["Q1", "Q2", "Q3", "Q4"],
        wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
      };
      const monthValues = {
        narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
        abbreviated: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec"
        ],
        wide: [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December"
        ]
      };
      const dayValues = {
        narrow: ["S", "M", "T", "W", "T", "F", "S"],
        short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        wide: [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday"
        ]
      };
      const dayPeriodValues = {
        narrow: {
          am: "a",
          pm: "p",
          midnight: "mi",
          noon: "n",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        },
        abbreviated: {
          am: "AM",
          pm: "PM",
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        },
        wide: {
          am: "a.m.",
          pm: "p.m.",
          midnight: "midnight",
          noon: "noon",
          morning: "morning",
          afternoon: "afternoon",
          evening: "evening",
          night: "night"
        }
      };
      const formattingDayPeriodValues = {
        narrow: {
          am: "a",
          pm: "p",
          midnight: "mi",
          noon: "n",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        },
        abbreviated: {
          am: "AM",
          pm: "PM",
          midnight: "midnight",
          noon: "noon",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        },
        wide: {
          am: "a.m.",
          pm: "p.m.",
          midnight: "midnight",
          noon: "noon",
          morning: "in the morning",
          afternoon: "in the afternoon",
          evening: "in the evening",
          night: "at night"
        }
      };
      const ordinalNumber = (dirtyNumber, _options) => {
        const number = Number(dirtyNumber);
        const rem100 = number % 100;
        if (rem100 > 20 || rem100 < 10) {
          switch (rem100 % 10) {
            case 1:
              return number + "st";
            case 2:
              return number + "nd";
            case 3:
              return number + "rd";
          }
        }
        return number + "th";
      };
      const localize = {
        ordinalNumber,
        era: buildLocalizeFn({
          values: eraValues,
          defaultWidth: "wide"
        }),
        quarter: buildLocalizeFn({
          values: quarterValues,
          defaultWidth: "wide",
          argumentCallback: (quarter) => quarter - 1
        }),
        month: buildLocalizeFn({
          values: monthValues,
          defaultWidth: "wide"
        }),
        day: buildLocalizeFn({
          values: dayValues,
          defaultWidth: "wide"
        }),
        dayPeriod: buildLocalizeFn({
          values: dayPeriodValues,
          defaultWidth: "wide",
          formattingValues: formattingDayPeriodValues,
          defaultFormattingWidth: "wide"
        })
      };
      const matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
      const parseOrdinalNumberPattern = /\d+/i;
      const matchEraPatterns = {
        narrow: /^(b|a)/i,
        abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
        wide: /^(before christ|before common era|anno domini|common era)/i
      };
      const parseEraPatterns = {
        any: [/^b/i, /^(a|c)/i]
      };
      const matchQuarterPatterns = {
        narrow: /^[1234]/i,
        abbreviated: /^q[1234]/i,
        wide: /^[1234](th|st|nd|rd)? quarter/i
      };
      const parseQuarterPatterns = {
        any: [/1/i, /2/i, /3/i, /4/i]
      };
      const matchMonthPatterns = {
        narrow: /^[jfmasond]/i,
        abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
        wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
      };
      const parseMonthPatterns = {
        narrow: [
          /^j/i,
          /^f/i,
          /^m/i,
          /^a/i,
          /^m/i,
          /^j/i,
          /^j/i,
          /^a/i,
          /^s/i,
          /^o/i,
          /^n/i,
          /^d/i
        ],
        any: [
          /^ja/i,
          /^f/i,
          /^mar/i,
          /^ap/i,
          /^may/i,
          /^jun/i,
          /^jul/i,
          /^au/i,
          /^s/i,
          /^o/i,
          /^n/i,
          /^d/i
        ]
      };
      const matchDayPatterns = {
        narrow: /^[smtwf]/i,
        short: /^(su|mo|tu|we|th|fr|sa)/i,
        abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
        wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
      };
      const parseDayPatterns = {
        narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
        any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
      };
      const matchDayPeriodPatterns = {
        narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
        any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
      };
      const parseDayPeriodPatterns = {
        any: {
          am: /^a/i,
          pm: /^p/i,
          midnight: /^mi/i,
          noon: /^no/i,
          morning: /morning/i,
          afternoon: /afternoon/i,
          evening: /evening/i,
          night: /night/i
        }
      };
      const match = {
        ordinalNumber: buildMatchPatternFn({
          matchPattern: matchOrdinalNumberPattern,
          parsePattern: parseOrdinalNumberPattern,
          valueCallback: (value) => parseInt(value, 10)
        }),
        era: buildMatchFn({
          matchPatterns: matchEraPatterns,
          defaultMatchWidth: "wide",
          parsePatterns: parseEraPatterns,
          defaultParseWidth: "any"
        }),
        quarter: buildMatchFn({
          matchPatterns: matchQuarterPatterns,
          defaultMatchWidth: "wide",
          parsePatterns: parseQuarterPatterns,
          defaultParseWidth: "any",
          valueCallback: (index) => index + 1
        }),
        month: buildMatchFn({
          matchPatterns: matchMonthPatterns,
          defaultMatchWidth: "wide",
          parsePatterns: parseMonthPatterns,
          defaultParseWidth: "any"
        }),
        day: buildMatchFn({
          matchPatterns: matchDayPatterns,
          defaultMatchWidth: "wide",
          parsePatterns: parseDayPatterns,
          defaultParseWidth: "any"
        }),
        dayPeriod: buildMatchFn({
          matchPatterns: matchDayPeriodPatterns,
          defaultMatchWidth: "any",
          parsePatterns: parseDayPeriodPatterns,
          defaultParseWidth: "any"
        })
      };
      const dateFormats = {
        full: "EEEE, MMMM do, y",
        long: "MMMM do, y",
        medium: "MMM d, y",
        short: "MM/dd/yyyy"
      };
      const timeFormats = {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
      };
      const dateTimeFormats = {
        full: "{{date}} 'at' {{time}}",
        long: "{{date}} 'at' {{time}}",
        medium: "{{date}}, {{time}}",
        short: "{{date}}, {{time}}"
      };
      const formatLong = {
        date: buildFormatLongFn({
          formats: dateFormats,
          defaultWidth: "full"
        }),
        time: buildFormatLongFn({
          formats: timeFormats,
          defaultWidth: "full"
        }),
        dateTime: buildFormatLongFn({
          formats: dateTimeFormats,
          defaultWidth: "full"
        })
      };
      const enUS = {
        code: "en-US",
        formatDistance,
        formatLong,
        formatRelative,
        localize,
        match,
        options: {
          weekStartsOn: 0,
          firstWeekContainsDate: 1
        }
      };
      const dateEnUs = {
        name: "en-US",
        locale: enUS
      };
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var Symbol$1 = root.Symbol;
      var objectProto$e = Object.prototype;
      var hasOwnProperty$b = objectProto$e.hasOwnProperty;
      var nativeObjectToString$1 = objectProto$e.toString;
      var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function getRawTag(value) {
        var isOwn = hasOwnProperty$b.call(value, symToStringTag$1), tag = value[symToStringTag$1];
        try {
          value[symToStringTag$1] = void 0;
          var unmasked = true;
        } catch (e) {
        }
        var result = nativeObjectToString$1.call(value);
        if (unmasked) {
          if (isOwn) {
            value[symToStringTag$1] = tag;
          } else {
            delete value[symToStringTag$1];
          }
        }
        return result;
      }
      var objectProto$d = Object.prototype;
      var nativeObjectToString = objectProto$d.toString;
      function objectToString(value) {
        return nativeObjectToString.call(value);
      }
      var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
      var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : void 0;
      function baseGetTag(value) {
        if (value == null) {
          return value === void 0 ? undefinedTag : nullTag;
        }
        return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
      }
      function isObjectLike(value) {
        return value != null && typeof value == "object";
      }
      var symbolTag$1 = "[object Symbol]";
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag$1;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      var isArray = Array.isArray;
      var symbolProto$1 = Symbol$1 ? Symbol$1.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
      function baseToString(value) {
        if (typeof value == "string") {
          return value;
        }
        if (isArray(value)) {
          return arrayMap(value, baseToString) + "";
        }
        if (isSymbol(value)) {
          return symbolToString ? symbolToString.call(value) : "";
        }
        var result = value + "";
        return result == "0" && 1 / value == -Infinity ? "-0" : result;
      }
      var reWhitespace = /\s/;
      function trimmedEndIndex(string2) {
        var index = string2.length;
        while (index-- && reWhitespace.test(string2.charAt(index))) {
        }
        return index;
      }
      var reTrimStart = /^\s+/;
      function baseTrim(string2) {
        return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
      }
      function isObject(value) {
        var type = typeof value;
        return value != null && (type == "object" || type == "function");
      }
      var NAN = 0 / 0;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = baseTrim(value);
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      function identity(value) {
        return value;
      }
      var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
      function isFunction(value) {
        if (!isObject(value)) {
          return false;
        }
        var tag = baseGetTag(value);
        return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
      }
      var coreJsData = root["__core-js_shared__"];
      var maskSrcKey = (function() {
        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
        return uid ? "Symbol(src)_1." + uid : "";
      })();
      function isMasked(func) {
        return !!maskSrcKey && maskSrcKey in func;
      }
      var funcProto$2 = Function.prototype;
      var funcToString$2 = funcProto$2.toString;
      function toSource(func) {
        if (func != null) {
          try {
            return funcToString$2.call(func);
          } catch (e) {
          }
          try {
            return func + "";
          } catch (e) {
          }
        }
        return "";
      }
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var funcProto$1 = Function.prototype, objectProto$c = Object.prototype;
      var funcToString$1 = funcProto$1.toString;
      var hasOwnProperty$a = objectProto$c.hasOwnProperty;
      var reIsNative = RegExp(
        "^" + funcToString$1.call(hasOwnProperty$a).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      );
      function baseIsNative(value) {
        if (!isObject(value) || isMasked(value)) {
          return false;
        }
        var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
        return pattern.test(toSource(value));
      }
      function getValue$1(object, key) {
        return object == null ? void 0 : object[key];
      }
      function getNative(object, key) {
        var value = getValue$1(object, key);
        return baseIsNative(value) ? value : void 0;
      }
      var WeakMap$1 = getNative(root, "WeakMap");
      var objectCreate = Object.create;
      var baseCreate = (function() {
        function object() {
        }
        return function(proto) {
          if (!isObject(proto)) {
            return {};
          }
          if (objectCreate) {
            return objectCreate(proto);
          }
          object.prototype = proto;
          var result = new object();
          object.prototype = void 0;
          return result;
        };
      })();
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function copyArray(source, array) {
        var index = -1, length = source.length;
        array || (array = Array(length));
        while (++index < length) {
          array[index] = source[index];
        }
        return array;
      }
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var nativeNow = Date.now;
      function shortOut(func) {
        var count = 0, lastCalled = 0;
        return function() {
          var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
          lastCalled = stamp;
          if (remaining > 0) {
            if (++count >= HOT_COUNT) {
              return arguments[0];
            }
          } else {
            count = 0;
          }
          return func.apply(void 0, arguments);
        };
      }
      function constant(value) {
        return function() {
          return value;
        };
      }
      var defineProperty = (function() {
        try {
          var func = getNative(Object, "defineProperty");
          func({}, "", {});
          return func;
        } catch (e) {
        }
      })();
      var baseSetToString = !defineProperty ? identity : function(func, string2) {
        return defineProperty(func, "toString", {
          "configurable": true,
          "enumerable": false,
          "value": constant(string2),
          "writable": true
        });
      };
      var setToString = shortOut(baseSetToString);
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      var MAX_SAFE_INTEGER$1 = 9007199254740991;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      function isIndex(value, length) {
        var type = typeof value;
        length = length == null ? MAX_SAFE_INTEGER$1 : length;
        return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
      }
      function baseAssignValue(object, key, value) {
        if (key == "__proto__" && defineProperty) {
          defineProperty(object, key, {
            "configurable": true,
            "enumerable": true,
            "value": value,
            "writable": true
          });
        } else {
          object[key] = value;
        }
      }
      function eq(value, other) {
        return value === other || value !== value && other !== other;
      }
      var objectProto$b = Object.prototype;
      var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
      function assignValue(object, key, value) {
        var objValue = object[key];
        if (!(hasOwnProperty$9.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function copyObject(source, props, object, customizer) {
        var isNew = !object;
        object || (object = {});
        var index = -1, length = props.length;
        while (++index < length) {
          var key = props[index];
          var newValue = void 0;
          if (newValue === void 0) {
            newValue = source[key];
          }
          if (isNew) {
            baseAssignValue(object, key, newValue);
          } else {
            assignValue(object, key, newValue);
          }
        }
        return object;
      }
      var nativeMax$1 = Math.max;
      function overRest(func, start, transform) {
        start = nativeMax$1(start === void 0 ? func.length - 1 : start, 0);
        return function() {
          var args = arguments, index = -1, length = nativeMax$1(args.length - start, 0), array = Array(length);
          while (++index < length) {
            array[index] = args[start + index];
          }
          index = -1;
          var otherArgs = Array(start + 1);
          while (++index < start) {
            otherArgs[index] = args[index];
          }
          otherArgs[start] = transform(array);
          return apply(func, this, otherArgs);
        };
      }
      function baseRest(func, start) {
        return setToString(overRest(func, start, identity), func + "");
      }
      var MAX_SAFE_INTEGER = 9007199254740991;
      function isLength(value) {
        return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
      }
      function isArrayLike(value) {
        return value != null && isLength(value.length) && !isFunction(value);
      }
      function isIterateeCall(value, index, object) {
        if (!isObject(object)) {
          return false;
        }
        var type = typeof index;
        if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
          return eq(object[index], value);
        }
        return false;
      }
      function createAssigner(assigner) {
        return baseRest(function(object, sources) {
          var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
          customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            customizer = length < 3 ? void 0 : customizer;
            length = 1;
          }
          object = Object(object);
          while (++index < length) {
            var source = sources[index];
            if (source) {
              assigner(object, source, index, customizer);
            }
          }
          return object;
        });
      }
      var objectProto$a = Object.prototype;
      function isPrototype(value) {
        var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$a;
        return value === proto;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      var argsTag$2 = "[object Arguments]";
      function baseIsArguments(value) {
        return isObjectLike(value) && baseGetTag(value) == argsTag$2;
      }
      var objectProto$9 = Object.prototype;
      var hasOwnProperty$8 = objectProto$9.hasOwnProperty;
      var propertyIsEnumerable$1 = objectProto$9.propertyIsEnumerable;
      var isArguments = baseIsArguments( (function() {
        return arguments;
      })()) ? baseIsArguments : function(value) {
        return isObjectLike(value) && hasOwnProperty$8.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
      };
      function stubFalse() {
        return false;
      }
      var freeExports$2 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$2 = freeExports$2 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$2 = freeModule$2 && freeModule$2.exports === freeExports$2;
      var Buffer$1 = moduleExports$2 ? root.Buffer : void 0;
      var nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : void 0;
      var isBuffer = nativeIsBuffer || stubFalse;
      var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", funcTag = "[object Function]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", objectTag$3 = "[object Object]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", weakMapTag$1 = "[object WeakMap]";
      var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$3] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
      function baseIsTypedArray(value) {
        return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      var freeExports$1 = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule$1 = freeExports$1 && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports$1 = freeModule$1 && freeModule$1.exports === freeExports$1;
      var freeProcess = moduleExports$1 && freeGlobal.process;
      var nodeUtil = (function() {
        try {
          var types2 = freeModule$1 && freeModule$1.require && freeModule$1.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      })();
      var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
      var objectProto$8 = Object.prototype;
      var hasOwnProperty$7 = objectProto$8.hasOwnProperty;
      function arrayLikeKeys(value, inherited) {
        var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
        for (var key in value) {
          if ((inherited || hasOwnProperty$7.call(value, key)) && !(skipIndexes &&
(key == "length" ||
isBuff && (key == "offset" || key == "parent") ||
isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") ||
isIndex(key, length)))) {
            result.push(key);
          }
        }
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      var nativeKeys = overArg(Object.keys, Object);
      var objectProto$7 = Object.prototype;
      var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
      function baseKeys(object) {
        if (!isPrototype(object)) {
          return nativeKeys(object);
        }
        var result = [];
        for (var key in Object(object)) {
          if (hasOwnProperty$6.call(object, key) && key != "constructor") {
            result.push(key);
          }
        }
        return result;
      }
      function keys(object) {
        return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
      }
      function nativeKeysIn(object) {
        var result = [];
        if (object != null) {
          for (var key in Object(object)) {
            result.push(key);
          }
        }
        return result;
      }
      var objectProto$6 = Object.prototype;
      var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
      function baseKeysIn(object) {
        if (!isObject(object)) {
          return nativeKeysIn(object);
        }
        var isProto = isPrototype(object), result = [];
        for (var key in object) {
          if (!(key == "constructor" && (isProto || !hasOwnProperty$5.call(object, key)))) {
            result.push(key);
          }
        }
        return result;
      }
      function keysIn(object) {
        return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
      }
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
      function isKey(value, object) {
        if (isArray(value)) {
          return false;
        }
        var type = typeof value;
        if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
          return true;
        }
        return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
      }
      var nativeCreate = getNative(Object, "create");
      function hashClear() {
        this.__data__ = nativeCreate ? nativeCreate(null) : {};
        this.size = 0;
      }
      function hashDelete(key) {
        var result = this.has(key) && delete this.__data__[key];
        this.size -= result ? 1 : 0;
        return result;
      }
      var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
      var objectProto$5 = Object.prototype;
      var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
      function hashGet(key) {
        var data = this.__data__;
        if (nativeCreate) {
          var result = data[key];
          return result === HASH_UNDEFINED$2 ? void 0 : result;
        }
        return hasOwnProperty$4.call(data, key) ? data[key] : void 0;
      }
      var objectProto$4 = Object.prototype;
      var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
      function hashHas(key) {
        var data = this.__data__;
        return nativeCreate ? data[key] !== void 0 : hasOwnProperty$3.call(data, key);
      }
      var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
      function hashSet(key, value) {
        var data = this.__data__;
        this.size += this.has(key) ? 0 : 1;
        data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
        return this;
      }
      function Hash(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      Hash.prototype.clear = hashClear;
      Hash.prototype["delete"] = hashDelete;
      Hash.prototype.get = hashGet;
      Hash.prototype.has = hashHas;
      Hash.prototype.set = hashSet;
      function listCacheClear() {
        this.__data__ = [];
        this.size = 0;
      }
      function assocIndexOf(array, key) {
        var length = array.length;
        while (length--) {
          if (eq(array[length][0], key)) {
            return length;
          }
        }
        return -1;
      }
      var arrayProto = Array.prototype;
      var splice = arrayProto.splice;
      function listCacheDelete(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          return false;
        }
        var lastIndex = data.length - 1;
        if (index == lastIndex) {
          data.pop();
        } else {
          splice.call(data, index, 1);
        }
        --this.size;
        return true;
      }
      function listCacheGet(key) {
        var data = this.__data__, index = assocIndexOf(data, key);
        return index < 0 ? void 0 : data[index][1];
      }
      function listCacheHas(key) {
        return assocIndexOf(this.__data__, key) > -1;
      }
      function listCacheSet(key, value) {
        var data = this.__data__, index = assocIndexOf(data, key);
        if (index < 0) {
          ++this.size;
          data.push([key, value]);
        } else {
          data[index][1] = value;
        }
        return this;
      }
      function ListCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      ListCache.prototype.clear = listCacheClear;
      ListCache.prototype["delete"] = listCacheDelete;
      ListCache.prototype.get = listCacheGet;
      ListCache.prototype.has = listCacheHas;
      ListCache.prototype.set = listCacheSet;
      var Map$1 = getNative(root, "Map");
      function mapCacheClear() {
        this.size = 0;
        this.__data__ = {
          "hash": new Hash(),
          "map": new (Map$1 || ListCache)(),
          "string": new Hash()
        };
      }
      function isKeyable(value) {
        var type = typeof value;
        return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
      }
      function getMapData(map2, key) {
        var data = map2.__data__;
        return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
      }
      function mapCacheDelete(key) {
        var result = getMapData(this, key)["delete"](key);
        this.size -= result ? 1 : 0;
        return result;
      }
      function mapCacheGet(key) {
        return getMapData(this, key).get(key);
      }
      function mapCacheHas(key) {
        return getMapData(this, key).has(key);
      }
      function mapCacheSet(key, value) {
        var data = getMapData(this, key), size2 = data.size;
        data.set(key, value);
        this.size += data.size == size2 ? 0 : 1;
        return this;
      }
      function MapCache(entries) {
        var index = -1, length = entries == null ? 0 : entries.length;
        this.clear();
        while (++index < length) {
          var entry = entries[index];
          this.set(entry[0], entry[1]);
        }
      }
      MapCache.prototype.clear = mapCacheClear;
      MapCache.prototype["delete"] = mapCacheDelete;
      MapCache.prototype.get = mapCacheGet;
      MapCache.prototype.has = mapCacheHas;
      MapCache.prototype.set = mapCacheSet;
      var FUNC_ERROR_TEXT$2 = "Expected a function";
      function memoize(func, resolver) {
        if (typeof func != "function" || resolver != null && typeof resolver != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$2);
        }
        var memoized = function() {
          var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
          if (cache2.has(key)) {
            return cache2.get(key);
          }
          var result = func.apply(this, args);
          memoized.cache = cache2.set(key, result) || cache2;
          return result;
        };
        memoized.cache = new (memoize.Cache || MapCache)();
        return memoized;
      }
      memoize.Cache = MapCache;
      var MAX_MEMOIZE_SIZE = 500;
      function memoizeCapped(func) {
        var result = memoize(func, function(key) {
          if (cache2.size === MAX_MEMOIZE_SIZE) {
            cache2.clear();
          }
          return key;
        });
        var cache2 = result.cache;
        return result;
      }
      var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reEscapeChar = /\\(\\)?/g;
      var stringToPath = memoizeCapped(function(string2) {
        var result = [];
        if (string2.charCodeAt(0) === 46) {
          result.push("");
        }
        string2.replace(rePropName, function(match2, number, quote, subString) {
          result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match2);
        });
        return result;
      });
      function toString(value) {
        return value == null ? "" : baseToString(value);
      }
      function castPath(value, object) {
        if (isArray(value)) {
          return value;
        }
        return isKey(value, object) ? [value] : stringToPath(toString(value));
      }
      function toKey(value) {
        if (typeof value == "string" || isSymbol(value)) {
          return value;
        }
        var result = value + "";
        return result == "0" && 1 / value == -Infinity ? "-0" : result;
      }
      function baseGet(object, path) {
        path = castPath(path, object);
        var index = 0, length = path.length;
        while (object != null && index < length) {
          object = object[toKey(path[index++])];
        }
        return index && index == length ? object : void 0;
      }
      function get(object, path, defaultValue) {
        var result = object == null ? void 0 : baseGet(object, path);
        return result === void 0 ? defaultValue : result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      var getPrototype = overArg(Object.getPrototypeOf, Object);
      var objectTag$2 = "[object Object]";
      var funcProto = Function.prototype, objectProto$3 = Object.prototype;
      var funcToString = funcProto.toString;
      var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
      var objectCtorString = funcToString.call(Object);
      function isPlainObject(value) {
        if (!isObjectLike(value) || baseGetTag(value) != objectTag$2) {
          return false;
        }
        var proto = getPrototype(value);
        if (proto === null) {
          return true;
        }
        var Ctor = hasOwnProperty$2.call(proto, "constructor") && proto.constructor;
        return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
      }
      function baseSlice(array, start, end) {
        var index = -1, length = array.length;
        if (start < 0) {
          start = -start > length ? 0 : length + start;
        }
        end = end > length ? length : end;
        if (end < 0) {
          end += length;
        }
        length = start > end ? 0 : end - start >>> 0;
        start >>>= 0;
        var result = Array(length);
        while (++index < length) {
          result[index] = array[index + start];
        }
        return result;
      }
      function castSlice(array, start, end) {
        var length = array.length;
        end = end === void 0 ? length : end;
        return !start && end >= length ? array : baseSlice(array, start, end);
      }
      var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
      var rsZWJ$1 = "\\u200d";
      var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
      function hasUnicode(string2) {
        return reHasUnicode.test(string2);
      }
      function asciiToArray(string2) {
        return string2.split("");
      }
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
      var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
      var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      function unicodeToArray(string2) {
        return string2.match(reUnicode) || [];
      }
      function stringToArray(string2) {
        return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
      }
      function createCaseFirst(methodName) {
        return function(string2) {
          string2 = toString(string2);
          var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
          var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
          var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
          return chr[methodName]() + trailing;
        };
      }
      var upperFirst = createCaseFirst("toUpperCase");
      function stackClear() {
        this.__data__ = new ListCache();
        this.size = 0;
      }
      function stackDelete(key) {
        var data = this.__data__, result = data["delete"](key);
        this.size = data.size;
        return result;
      }
      function stackGet(key) {
        return this.__data__.get(key);
      }
      function stackHas(key) {
        return this.__data__.has(key);
      }
      var LARGE_ARRAY_SIZE = 200;
      function stackSet(key, value) {
        var data = this.__data__;
        if (data instanceof ListCache) {
          var pairs = data.__data__;
          if (!Map$1 || pairs.length < LARGE_ARRAY_SIZE - 1) {
            pairs.push([key, value]);
            this.size = ++data.size;
            return this;
          }
          data = this.__data__ = new MapCache(pairs);
        }
        data.set(key, value);
        this.size = data.size;
        return this;
      }
      function Stack(entries) {
        var data = this.__data__ = new ListCache(entries);
        this.size = data.size;
      }
      Stack.prototype.clear = stackClear;
      Stack.prototype["delete"] = stackDelete;
      Stack.prototype.get = stackGet;
      Stack.prototype.has = stackHas;
      Stack.prototype.set = stackSet;
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var Buffer2 = moduleExports ? root.Buffer : void 0;
      Buffer2 ? Buffer2.allocUnsafe : void 0;
      function cloneBuffer(buffer, isDeep) {
        {
          return buffer.slice();
        }
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function stubArray() {
        return [];
      }
      var objectProto$2 = Object.prototype;
      var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
      var nativeGetSymbols = Object.getOwnPropertySymbols;
      var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
        if (object == null) {
          return [];
        }
        object = Object(object);
        return arrayFilter(nativeGetSymbols(object), function(symbol) {
          return propertyIsEnumerable.call(object, symbol);
        });
      };
      function baseGetAllKeys(object, keysFunc, symbolsFunc) {
        var result = keysFunc(object);
        return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
      }
      function getAllKeys(object) {
        return baseGetAllKeys(object, keys, getSymbols);
      }
      var DataView = getNative(root, "DataView");
      var Promise$1 = getNative(root, "Promise");
      var Set$1 = getNative(root, "Set");
      var mapTag$1 = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag$1 = "[object Set]", weakMapTag = "[object WeakMap]";
      var dataViewTag$1 = "[object DataView]";
      var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$1), weakMapCtorString = toSource(WeakMap$1);
      var getTag = baseGetTag;
      if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag$1 || Map$1 && getTag(new Map$1()) != mapTag$1 || Promise$1 && getTag(Promise$1.resolve()) != promiseTag || Set$1 && getTag(new Set$1()) != setTag$1 || WeakMap$1 && getTag(new WeakMap$1()) != weakMapTag) {
        getTag = function(value) {
          var result = baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
          if (ctorString) {
            switch (ctorString) {
              case dataViewCtorString:
                return dataViewTag$1;
              case mapCtorString:
                return mapTag$1;
              case promiseCtorString:
                return promiseTag;
              case setCtorString:
                return setTag$1;
              case weakMapCtorString:
                return weakMapTag;
            }
          }
          return result;
        };
      }
      var Uint8Array2 = root.Uint8Array;
      function cloneArrayBuffer(arrayBuffer) {
        var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
        new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
        return result;
      }
      function cloneTypedArray(typedArray, isDeep) {
        var buffer = cloneArrayBuffer(typedArray.buffer);
        return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
      }
      function initCloneObject(object) {
        return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
      }
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      function setCacheAdd(value) {
        this.__data__.set(value, HASH_UNDEFINED);
        return this;
      }
      function setCacheHas(value) {
        return this.__data__.has(value);
      }
      function SetCache(values) {
        var index = -1, length = values == null ? 0 : values.length;
        this.__data__ = new MapCache();
        while (++index < length) {
          this.add(values[index]);
        }
      }
      SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
      SetCache.prototype.has = setCacheHas;
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      function cacheHas(cache2, key) {
        return cache2.has(key);
      }
      var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
      function equalArrays(array, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array.length, othLength = other.length;
        if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
          return false;
        }
        var arrStacked = stack2.get(array);
        var othStacked = stack2.get(other);
        if (arrStacked && othStacked) {
          return arrStacked == other && othStacked == array;
        }
        var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache() : void 0;
        stack2.set(array, other);
        stack2.set(other, array);
        while (++index < arrLength) {
          var arrValue = array[index], othValue = other[index];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
          }
          if (compared !== void 0) {
            if (compared) {
              continue;
            }
            result = false;
            break;
          }
          if (seen) {
            if (!arraySome(other, function(othValue2, othIndex) {
              if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                return seen.push(othIndex);
              }
            })) {
              result = false;
              break;
            }
          } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
            result = false;
            break;
          }
        }
        stack2["delete"](array);
        stack2["delete"](other);
        return result;
      }
      function mapToArray(map2) {
        var index = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
      var boolTag = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", mapTag = "[object Map]", numberTag = "[object Number]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]";
      var symbolProto = Symbol$1 ? Symbol$1.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
      function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack2) {
        switch (tag) {
          case dataViewTag:
            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
              return false;
            }
            object = object.buffer;
            other = other.buffer;
          case arrayBufferTag:
            if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
              return false;
            }
            return true;
          case boolTag:
          case dateTag:
          case numberTag:
            return eq(+object, +other);
          case errorTag:
            return object.name == other.name && object.message == other.message;
          case regexpTag:
          case stringTag:
            return object == other + "";
          case mapTag:
            var convert = mapToArray;
          case setTag:
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
            convert || (convert = setToArray);
            if (object.size != other.size && !isPartial) {
              return false;
            }
            var stacked = stack2.get(object);
            if (stacked) {
              return stacked == other;
            }
            bitmask |= COMPARE_UNORDERED_FLAG$2;
            stack2.set(object, other);
            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
            stack2["delete"](object);
            return result;
          case symbolTag:
            if (symbolValueOf) {
              return symbolValueOf.call(object) == symbolValueOf.call(other);
            }
        }
        return false;
      }
      var COMPARE_PARTIAL_FLAG$3 = 1;
      var objectProto$1 = Object.prototype;
      var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
      function equalObjects(object, other, bitmask, customizer, equalFunc, stack2) {
        var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
        if (objLength != othLength && !isPartial) {
          return false;
        }
        var index = objLength;
        while (index--) {
          var key = objProps[index];
          if (!(isPartial ? key in other : hasOwnProperty$1.call(other, key))) {
            return false;
          }
        }
        var objStacked = stack2.get(object);
        var othStacked = stack2.get(other);
        if (objStacked && othStacked) {
          return objStacked == other && othStacked == object;
        }
        var result = true;
        stack2.set(object, other);
        stack2.set(other, object);
        var skipCtor = isPartial;
        while (++index < objLength) {
          key = objProps[index];
          var objValue = object[key], othValue = other[key];
          if (customizer) {
            var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
          }
          if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
            result = false;
            break;
          }
          skipCtor || (skipCtor = key == "constructor");
        }
        if (result && !skipCtor) {
          var objCtor = object.constructor, othCtor = other.constructor;
          if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
            result = false;
          }
        }
        stack2["delete"](object);
        stack2["delete"](other);
        return result;
      }
      var COMPARE_PARTIAL_FLAG$2 = 1;
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
      var objectProto = Object.prototype;
      var hasOwnProperty = objectProto.hasOwnProperty;
      function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack2) {
        var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
        objTag = objTag == argsTag ? objectTag : objTag;
        othTag = othTag == argsTag ? objectTag : othTag;
        var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
        if (isSameTag && isBuffer(object)) {
          if (!isBuffer(other)) {
            return false;
          }
          objIsArr = true;
          objIsObj = false;
        }
        if (isSameTag && !objIsObj) {
          stack2 || (stack2 = new Stack());
          return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack2);
        }
        if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
          var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
          if (objIsWrapped || othIsWrapped) {
            var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
            stack2 || (stack2 = new Stack());
            return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
          }
        }
        if (!isSameTag) {
          return false;
        }
        stack2 || (stack2 = new Stack());
        return equalObjects(object, other, bitmask, customizer, equalFunc, stack2);
      }
      function baseIsEqual(value, other, bitmask, customizer, stack2) {
        if (value === other) {
          return true;
        }
        if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
          return value !== value && other !== other;
        }
        return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack2);
      }
      var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
      function baseIsMatch(object, source, matchData, customizer) {
        var index = matchData.length, length = index;
        if (object == null) {
          return !length;
        }
        object = Object(object);
        while (index--) {
          var data = matchData[index];
          if (data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
            return false;
          }
        }
        while (++index < length) {
          data = matchData[index];
          var key = data[0], objValue = object[key], srcValue = data[1];
          if (data[2]) {
            if (objValue === void 0 && !(key in object)) {
              return false;
            }
          } else {
            var stack2 = new Stack();
            var result;
            if (!(result === void 0 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack2) : result)) {
              return false;
            }
          }
        }
        return true;
      }
      function isStrictComparable(value) {
        return value === value && !isObject(value);
      }
      function getMatchData(object) {
        var result = keys(object), length = result.length;
        while (length--) {
          var key = result[length], value = object[key];
          result[length] = [key, value, isStrictComparable(value)];
        }
        return result;
      }
      function matchesStrictComparable(key, srcValue) {
        return function(object) {
          if (object == null) {
            return false;
          }
          return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
        };
      }
      function baseMatches(source) {
        var matchData = getMatchData(source);
        if (matchData.length == 1 && matchData[0][2]) {
          return matchesStrictComparable(matchData[0][0], matchData[0][1]);
        }
        return function(object) {
          return object === source || baseIsMatch(object, source, matchData);
        };
      }
      function baseHasIn(object, key) {
        return object != null && key in Object(object);
      }
      function hasPath(object, path, hasFunc) {
        path = castPath(path, object);
        var index = -1, length = path.length, result = false;
        while (++index < length) {
          var key = toKey(path[index]);
          if (!(result = object != null && hasFunc(object, key))) {
            break;
          }
          object = object[key];
        }
        if (result || ++index != length) {
          return result;
        }
        length = object == null ? 0 : object.length;
        return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
      }
      function hasIn(object, path) {
        return object != null && hasPath(object, path, baseHasIn);
      }
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      function baseMatchesProperty(path, srcValue) {
        if (isKey(path) && isStrictComparable(srcValue)) {
          return matchesStrictComparable(toKey(path), srcValue);
        }
        return function(object) {
          var objValue = get(object, path);
          return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
        };
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? void 0 : object[key];
        };
      }
      function basePropertyDeep(path) {
        return function(object) {
          return baseGet(object, path);
        };
      }
      function property(path) {
        return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
      }
      function baseIteratee(value) {
        if (typeof value == "function") {
          return value;
        }
        if (value == null) {
          return identity;
        }
        if (typeof value == "object") {
          return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
        }
        return property(value);
      }
      function createBaseFor(fromRight) {
        return function(object, iteratee, keysFunc) {
          var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
          while (length--) {
            var key = props[++index];
            if (iteratee(iterable[key], key, iterable) === false) {
              break;
            }
          }
          return object;
        };
      }
      var baseFor = createBaseFor();
      function baseForOwn(object, iteratee) {
        return object && baseFor(object, iteratee, keys);
      }
      function createBaseEach(eachFunc, fromRight) {
        return function(collection, iteratee) {
          if (collection == null) {
            return collection;
          }
          if (!isArrayLike(collection)) {
            return eachFunc(collection, iteratee);
          }
          var length = collection.length, index = -1, iterable = Object(collection);
          while (++index < length) {
            if (iteratee(iterable[index], index, iterable) === false) {
              break;
            }
          }
          return collection;
        };
      }
      var baseEach = createBaseEach(baseForOwn);
      var now = function() {
        return root.Date.now();
      };
      var FUNC_ERROR_TEXT$1 = "Expected a function";
      var nativeMax = Math.max, nativeMin = Math.min;
      function debounce(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT$1);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time2) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time2;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time2) {
          lastInvokeTime = time2;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time2) : result;
        }
        function remainingWait(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
          return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
        }
        function shouldInvoke(time2) {
          var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time2 = now();
          if (shouldInvoke(time2)) {
            return trailingEdge(time2);
          }
          timerId = setTimeout(timerExpired, remainingWait(time2));
        }
        function trailingEdge(time2) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time2);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time2 = now(), isInvoking = shouldInvoke(time2);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time2;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              clearTimeout(timerId);
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function assignMergeValue(object, key, value) {
        if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
          baseAssignValue(object, key, value);
        }
      }
      function isArrayLikeObject(value) {
        return isObjectLike(value) && isArrayLike(value);
      }
      function safeGet(object, key) {
        if (key === "constructor" && typeof object[key] === "function") {
          return;
        }
        if (key == "__proto__") {
          return;
        }
        return object[key];
      }
      function toPlainObject(value) {
        return copyObject(value, keysIn(value));
      }
      function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
        var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack2.get(srcValue);
        if (stacked) {
          assignMergeValue(object, key, stacked);
          return;
        }
        var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : void 0;
        var isCommon = newValue === void 0;
        if (isCommon) {
          var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
          newValue = srcValue;
          if (isArr || isBuff || isTyped) {
            if (isArray(objValue)) {
              newValue = objValue;
            } else if (isArrayLikeObject(objValue)) {
              newValue = copyArray(objValue);
            } else if (isBuff) {
              isCommon = false;
              newValue = cloneBuffer(srcValue);
            } else if (isTyped) {
              isCommon = false;
              newValue = cloneTypedArray(srcValue);
            } else {
              newValue = [];
            }
          } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
            newValue = objValue;
            if (isArguments(objValue)) {
              newValue = toPlainObject(objValue);
            } else if (!isObject(objValue) || isFunction(objValue)) {
              newValue = initCloneObject(srcValue);
            }
          } else {
            isCommon = false;
          }
        }
        if (isCommon) {
          stack2.set(srcValue, newValue);
          mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
          stack2["delete"](srcValue);
        }
        assignMergeValue(object, key, newValue);
      }
      function baseMerge(object, source, srcIndex, customizer, stack2) {
        if (object === source) {
          return;
        }
        baseFor(source, function(srcValue, key) {
          stack2 || (stack2 = new Stack());
          if (isObject(srcValue)) {
            baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack2);
          } else {
            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack2) : void 0;
            if (newValue === void 0) {
              newValue = srcValue;
            }
            assignMergeValue(object, key, newValue);
          }
        }, keysIn);
      }
      function castFunction(value) {
        return typeof value == "function" ? value : identity;
      }
      function forEach(collection, iteratee) {
        var func = isArray(collection) ? arrayEach : baseEach;
        return func(collection, castFunction(iteratee));
      }
      function baseMap(collection, iteratee) {
        var index = -1, result = isArrayLike(collection) ? Array(collection.length) : [];
        baseEach(collection, function(value, key, collection2) {
          result[++index] = iteratee(value, key, collection2);
        });
        return result;
      }
      function map(collection, iteratee) {
        var func = isArray(collection) ? arrayMap : baseMap;
        return func(collection, baseIteratee(iteratee));
      }
      var merge$1 = createAssigner(function(object, source, srcIndex) {
        baseMerge(object, source, srcIndex);
      });
      var FUNC_ERROR_TEXT = "Expected a function";
      function throttle$1(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function useLocale(ns) {
        const {
          mergedLocaleRef,
          mergedDateLocaleRef
        } = vue.inject(configProviderInjectionKey, null) || {};
        const localeRef = vue.computed(() => {
          var _a, _b;
          return (_b = (_a = mergedLocaleRef === null || mergedLocaleRef === void 0 ? void 0 : mergedLocaleRef.value) === null || _a === void 0 ? void 0 : _a[ns]) !== null && _b !== void 0 ? _b : enUS$1[ns];
        });
        const dateLocaleRef = vue.computed(() => {
          var _a;
          return (_a = mergedDateLocaleRef === null || mergedDateLocaleRef === void 0 ? void 0 : mergedDateLocaleRef.value) !== null && _a !== void 0 ? _a : dateEnUs;
        });
        return {
          dateLocaleRef,
          localeRef
        };
      }
      const cssrAnchorMetaName = "naive-ui-style";
      function useRtl(mountId, rtlStateRef, clsPrefixRef) {
        if (!rtlStateRef) return void 0;
        const ssrAdapter2 = useSsrAdapter();
        const componentRtlStateRef = vue.computed(() => {
          const {
            value: rtlState
          } = rtlStateRef;
          if (!rtlState) {
            return void 0;
          }
          const componentRtlState = rtlState[mountId];
          if (!componentRtlState) {
            return void 0;
          }
          return componentRtlState;
        });
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        const mountStyle = () => {
          vue.watchEffect(() => {
            const {
              value: clsPrefix
            } = clsPrefixRef;
            const id = `${clsPrefix}${mountId}Rtl`;
            if (exists(id, ssrAdapter2)) return;
            const {
              value: componentRtlState
            } = componentRtlStateRef;
            if (!componentRtlState) return;
            componentRtlState.style.mount({
              id,
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              props: {
                bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
              },
              ssr: ssrAdapter2,
              parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
            });
          });
        };
        if (ssrAdapter2) {
          mountStyle();
        } else {
          vue.onBeforeMount(mountStyle);
        }
        return componentRtlStateRef;
      }
      const commonVariables$e = {
        fontFamily: 'v-sans, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol"',
        fontFamilyMono: "v-mono, SFMono-Regular, Menlo, Consolas, Courier, monospace",
        fontWeight: "400",
        fontWeightStrong: "500",
        cubicBezierEaseInOut: "cubic-bezier(.4, 0, .2, 1)",
        cubicBezierEaseOut: "cubic-bezier(0, 0, .2, 1)",
        cubicBezierEaseIn: "cubic-bezier(.4, 0, 1, 1)",
        borderRadius: "3px",
        borderRadiusSmall: "2px",
        fontSize: "14px",
        fontSizeMini: "12px",
        fontSizeTiny: "12px",
        fontSizeSmall: "14px",
        fontSizeMedium: "14px",
        fontSizeLarge: "15px",
        fontSizeHuge: "16px",
        lineHeight: "1.6",
        heightMini: "16px",
heightTiny: "22px",
        heightSmall: "28px",
        heightMedium: "34px",
        heightLarge: "40px",
        heightHuge: "46px"
      };
      const {
        fontSize,
        fontFamily,
        lineHeight
      } = commonVariables$e;
      const globalStyle = c$1("body", `
 margin: 0;
 font-size: ${fontSize};
 font-family: ${fontFamily};
 line-height: ${lineHeight};
 -webkit-text-size-adjust: 100%;
 -webkit-tap-highlight-color: transparent;
`, [c$1("input", `
 font-family: inherit;
 font-size: inherit;
 `)]);
      function useStyle(mountId, style2, clsPrefixRef) {
        if (!style2) {
          return;
        }
        const ssrAdapter2 = useSsrAdapter();
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        const mountStyle = () => {
          const clsPrefix = clsPrefixRef.value;
          style2.mount({
            id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
            head: true,
            anchorMetaName: cssrAnchorMetaName,
            props: {
              bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
            },
            ssr: ssrAdapter2,
            parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
          });
          if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
            globalStyle.mount({
              id: "n-global",
              head: true,
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter2,
              parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
            });
          }
        };
        if (ssrAdapter2) {
          mountStyle();
        } else {
          vue.onBeforeMount(mountStyle);
        }
      }
      function createTheme(theme) {
        return theme;
      }
      function useTheme(resolveId, mountId, style2, defaultTheme, props, clsPrefixRef) {
        const ssrAdapter2 = useSsrAdapter();
        const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
        if (style2) {
          const mountStyle = () => {
            const clsPrefix = clsPrefixRef === null || clsPrefixRef === void 0 ? void 0 : clsPrefixRef.value;
            style2.mount({
              id: clsPrefix === void 0 ? mountId : clsPrefix + mountId,
              head: true,
              props: {
                bPrefix: clsPrefix ? `.${clsPrefix}-` : void 0
              },
              anchorMetaName: cssrAnchorMetaName,
              ssr: ssrAdapter2,
              parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
            });
            if (!(NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled)) {
              globalStyle.mount({
                id: "n-global",
                head: true,
                anchorMetaName: cssrAnchorMetaName,
                ssr: ssrAdapter2,
                parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
              });
            }
          };
          if (ssrAdapter2) {
            mountStyle();
          } else {
            vue.onBeforeMount(mountStyle);
          }
        }
        const mergedThemeRef = vue.computed(() => {
          var _a;
          const {
            theme: {
              common: selfCommon,
              self: self2,
              peers = {}
            } = {},
            themeOverrides: selfOverrides = {},
            builtinThemeOverrides: builtinOverrides = {}
          } = props;
          const {
            common: selfCommonOverrides,
            peers: peersOverrides
          } = selfOverrides;
          const {
            common: globalCommon = void 0,
            [resolveId]: {
              common: globalSelfCommon = void 0,
              self: globalSelf = void 0,
              peers: globalPeers = {}
            } = {}
          } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value) || {};
          const {
            common: globalCommonOverrides = void 0,
            [resolveId]: globalSelfOverrides = {}
          } = (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value) || {};
          const {
            common: globalSelfCommonOverrides,
            peers: globalPeersOverrides = {}
          } = globalSelfOverrides;
          const mergedCommon = merge$1({}, selfCommon || globalSelfCommon || globalCommon || defaultTheme.common, globalCommonOverrides, globalSelfCommonOverrides, selfCommonOverrides);
          const mergedSelf = merge$1(
(_a = self2 || globalSelf || defaultTheme.self) === null || _a === void 0 ? void 0 : _a(mergedCommon),
            builtinOverrides,
            globalSelfOverrides,
            selfOverrides
          );
          return {
            common: mergedCommon,
            self: mergedSelf,
            peers: merge$1({}, defaultTheme.peers, globalPeers, peers),
            peerOverrides: merge$1({}, builtinOverrides.peers, globalPeersOverrides, peersOverrides)
          };
        });
        return mergedThemeRef;
      }
      useTheme.props = {
        theme: Object,
        themeOverrides: Object,
        builtinThemeOverrides: Object
      };
      const style$x = cB("base-icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
`, [c$1("svg", `
 height: 1em;
 width: 1em;
 `)]);
      const NBaseIcon = vue.defineComponent({
        name: "BaseIcon",
        props: {
          role: String,
          ariaLabel: String,
          ariaDisabled: {
            type: Boolean,
            default: void 0
          },
          ariaHidden: {
            type: Boolean,
            default: void 0
          },
          clsPrefix: {
            type: String,
            required: true
          },
          onClick: Function,
          onMousedown: Function,
          onMouseup: Function
        },
        setup(props) {
          useStyle("-base-icon", style$x, vue.toRef(props, "clsPrefix"));
        },
        render() {
          return vue.h("i", {
            class: `${this.clsPrefix}-base-icon`,
            onClick: this.onClick,
            onMousedown: this.onMousedown,
            onMouseup: this.onMouseup,
            role: this.role,
            "aria-label": this.ariaLabel,
            "aria-hidden": this.ariaHidden,
            "aria-disabled": this.ariaDisabled
          }, this.$slots);
        }
      });
      const NIconSwitchTransition = vue.defineComponent({
        name: "BaseIconSwitchTransition",
        setup(_, {
          slots
        }) {
          const isMountedRef = isMounted();
          return () => vue.h(vue.Transition, {
            name: "icon-switch-transition",
            appear: isMountedRef.value
          }, slots);
        }
      });
      const AddIcon = vue.defineComponent({
        name: "Add",
        render() {
          return vue.h("svg", {
            width: "512",
            height: "512",
            viewBox: "0 0 512 512",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("path", {
            d: "M256 112V400M400 256H112",
            stroke: "currentColor",
            "stroke-width": "32",
            "stroke-linecap": "round",
            "stroke-linejoin": "round"
          }));
        }
      });
      const ArrowDownIcon = vue.defineComponent({
        name: "ArrowDown",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 28 28",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("g", {
            stroke: "none",
            "stroke-width": "1",
            "fill-rule": "evenodd"
          }, vue.h("g", {
            "fill-rule": "nonzero"
          }, vue.h("path", {
            d: "M23.7916,15.2664 C24.0788,14.9679 24.0696,14.4931 23.7711,14.206 C23.4726,13.9188 22.9978,13.928 22.7106,14.2265 L14.7511,22.5007 L14.7511,3.74792 C14.7511,3.33371 14.4153,2.99792 14.0011,2.99792 C13.5869,2.99792 13.2511,3.33371 13.2511,3.74793 L13.2511,22.4998 L5.29259,14.2265 C5.00543,13.928 4.53064,13.9188 4.23213,14.206 C3.93361,14.4931 3.9244,14.9679 4.21157,15.2664 L13.2809,24.6944 C13.6743,25.1034 14.3289,25.1034 14.7223,24.6944 L23.7916,15.2664 Z"
          }))));
        }
      });
      function replaceable(name, icon) {
        const IconComponent = vue.defineComponent({
          render() {
            return icon();
          }
        });
        return vue.defineComponent({
          name: upperFirst(name),
          setup() {
            var _a;
            const mergedIconsRef = (_a = vue.inject(configProviderInjectionKey, null)) === null || _a === void 0 ? void 0 : _a.mergedIconsRef;
            return () => {
              var _a2;
              const iconOverride = (_a2 = mergedIconsRef === null || mergedIconsRef === void 0 ? void 0 : mergedIconsRef.value) === null || _a2 === void 0 ? void 0 : _a2[name];
              return iconOverride ? iconOverride() : vue.h(IconComponent, null);
            };
          }
        });
      }
      const BackwardIcon = vue.defineComponent({
        name: "Backward",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 20 20",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("path", {
            d: "M12.2674 15.793C11.9675 16.0787 11.4927 16.0672 11.2071 15.7673L6.20572 10.5168C5.9298 10.2271 5.9298 9.7719 6.20572 9.48223L11.2071 4.23177C11.4927 3.93184 11.9675 3.92031 12.2674 4.206C12.5673 4.49169 12.5789 4.96642 12.2932 5.26634L7.78458 9.99952L12.2932 14.7327C12.5789 15.0326 12.5673 15.5074 12.2674 15.793Z",
            fill: "currentColor"
          }));
        }
      });
      const FinishedIcon = vue.defineComponent({
        name: "Checkmark",
        render() {
          return vue.h("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 16 16"
          }, vue.h("g", {
            fill: "none"
          }, vue.h("path", {
            d: "M14.046 3.486a.75.75 0 0 1-.032 1.06l-7.93 7.474a.85.85 0 0 1-1.188-.022l-2.68-2.72a.75.75 0 1 1 1.068-1.053l2.234 2.267l7.468-7.038a.75.75 0 0 1 1.06.032z",
            fill: "currentColor"
          })));
        }
      });
      const ChevronDownIcon = vue.defineComponent({
        name: "ChevronDown",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 16 16",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("path", {
            d: "M3.14645 5.64645C3.34171 5.45118 3.65829 5.45118 3.85355 5.64645L8 9.79289L12.1464 5.64645C12.3417 5.45118 12.6583 5.45118 12.8536 5.64645C13.0488 5.84171 13.0488 6.15829 12.8536 6.35355L8.35355 10.8536C8.15829 11.0488 7.84171 11.0488 7.64645 10.8536L3.14645 6.35355C2.95118 6.15829 2.95118 5.84171 3.14645 5.64645Z",
            fill: "currentColor"
          }));
        }
      });
      const ChevronRightIcon = vue.defineComponent({
        name: "ChevronRight",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 16 16",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("path", {
            d: "M5.64645 3.14645C5.45118 3.34171 5.45118 3.65829 5.64645 3.85355L9.79289 8L5.64645 12.1464C5.45118 12.3417 5.45118 12.6583 5.64645 12.8536C5.84171 13.0488 6.15829 13.0488 6.35355 12.8536L10.8536 8.35355C11.0488 8.15829 11.0488 7.84171 10.8536 7.64645L6.35355 3.14645C6.15829 2.95118 5.84171 2.95118 5.64645 3.14645Z",
            fill: "currentColor"
          }));
        }
      });
      const ClearIcon = replaceable("clear", () => vue.h("svg", {
        viewBox: "0 0 16 16",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M8,2 C11.3137085,2 14,4.6862915 14,8 C14,11.3137085 11.3137085,14 8,14 C4.6862915,14 2,11.3137085 2,8 C2,4.6862915 4.6862915,2 8,2 Z M6.5343055,5.83859116 C6.33943736,5.70359511 6.07001296,5.72288026 5.89644661,5.89644661 L5.89644661,5.89644661 L5.83859116,5.9656945 C5.70359511,6.16056264 5.72288026,6.42998704 5.89644661,6.60355339 L5.89644661,6.60355339 L7.293,8 L5.89644661,9.39644661 L5.83859116,9.4656945 C5.70359511,9.66056264 5.72288026,9.92998704 5.89644661,10.1035534 L5.89644661,10.1035534 L5.9656945,10.1614088 C6.16056264,10.2964049 6.42998704,10.2771197 6.60355339,10.1035534 L6.60355339,10.1035534 L8,8.707 L9.39644661,10.1035534 L9.4656945,10.1614088 C9.66056264,10.2964049 9.92998704,10.2771197 10.1035534,10.1035534 L10.1035534,10.1035534 L10.1614088,10.0343055 C10.2964049,9.83943736 10.2771197,9.57001296 10.1035534,9.39644661 L10.1035534,9.39644661 L8.707,8 L10.1035534,6.60355339 L10.1614088,6.5343055 C10.2964049,6.33943736 10.2771197,6.07001296 10.1035534,5.89644661 L10.1035534,5.89644661 L10.0343055,5.83859116 C9.83943736,5.70359511 9.57001296,5.72288026 9.39644661,5.89644661 L9.39644661,5.89644661 L8,7.293 L6.60355339,5.89644661 Z"
      })))));
      const ErrorIcon$1 = replaceable("close", () => vue.h("svg", {
        viewBox: "0 0 12 12",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        "aria-hidden": true
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        fill: "none",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        fill: "currentColor",
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M2.08859116,2.2156945 L2.14644661,2.14644661 C2.32001296,1.97288026 2.58943736,1.95359511 2.7843055,2.08859116 L2.85355339,2.14644661 L6,5.293 L9.14644661,2.14644661 C9.34170876,1.95118446 9.65829124,1.95118446 9.85355339,2.14644661 C10.0488155,2.34170876 10.0488155,2.65829124 9.85355339,2.85355339 L6.707,6 L9.85355339,9.14644661 C10.0271197,9.32001296 10.0464049,9.58943736 9.91140884,9.7843055 L9.85355339,9.85355339 C9.67998704,10.0271197 9.41056264,10.0464049 9.2156945,9.91140884 L9.14644661,9.85355339 L6,6.707 L2.85355339,9.85355339 C2.65829124,10.0488155 2.34170876,10.0488155 2.14644661,9.85355339 C1.95118446,9.65829124 1.95118446,9.34170876 2.14644661,9.14644661 L5.293,6 L2.14644661,2.85355339 C1.97288026,2.67998704 1.95359511,2.41056264 2.08859116,2.2156945 L2.14644661,2.14644661 L2.08859116,2.2156945 Z"
      })))));
      const EmptyIcon = vue.defineComponent({
        name: "Empty",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 28 28",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("path", {
            d: "M26 7.5C26 11.0899 23.0899 14 19.5 14C15.9101 14 13 11.0899 13 7.5C13 3.91015 15.9101 1 19.5 1C23.0899 1 26 3.91015 26 7.5ZM16.8536 4.14645C16.6583 3.95118 16.3417 3.95118 16.1464 4.14645C15.9512 4.34171 15.9512 4.65829 16.1464 4.85355L18.7929 7.5L16.1464 10.1464C15.9512 10.3417 15.9512 10.6583 16.1464 10.8536C16.3417 11.0488 16.6583 11.0488 16.8536 10.8536L19.5 8.20711L22.1464 10.8536C22.3417 11.0488 22.6583 11.0488 22.8536 10.8536C23.0488 10.6583 23.0488 10.3417 22.8536 10.1464L20.2071 7.5L22.8536 4.85355C23.0488 4.65829 23.0488 4.34171 22.8536 4.14645C22.6583 3.95118 22.3417 3.95118 22.1464 4.14645L19.5 6.79289L16.8536 4.14645Z",
            fill: "currentColor"
          }), vue.h("path", {
            d: "M25 22.75V12.5991C24.5572 13.0765 24.053 13.4961 23.5 13.8454V16H17.5L17.3982 16.0068C17.0322 16.0565 16.75 16.3703 16.75 16.75C16.75 18.2688 15.5188 19.5 14 19.5C12.4812 19.5 11.25 18.2688 11.25 16.75L11.2432 16.6482C11.1935 16.2822 10.8797 16 10.5 16H4.5V7.25C4.5 6.2835 5.2835 5.5 6.25 5.5H12.2696C12.4146 4.97463 12.6153 4.47237 12.865 4H6.25C4.45507 4 3 5.45507 3 7.25V22.75C3 24.5449 4.45507 26 6.25 26H21.75C23.5449 26 25 24.5449 25 22.75ZM4.5 22.75V17.5H9.81597L9.85751 17.7041C10.2905 19.5919 11.9808 21 14 21L14.215 20.9947C16.2095 20.8953 17.842 19.4209 18.184 17.5H23.5V22.75C23.5 23.7165 22.7165 24.5 21.75 24.5H6.25C5.2835 24.5 4.5 23.7165 4.5 22.75Z",
            fill: "currentColor"
          }));
        }
      });
      const ErrorIcon = replaceable("error", () => vue.h("svg", {
        viewBox: "0 0 48 48",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M17.8838835,16.1161165 L17.7823881,16.0249942 C17.3266086,15.6583353 16.6733914,15.6583353 16.2176119,16.0249942 L16.1161165,16.1161165 L16.0249942,16.2176119 C15.6583353,16.6733914 15.6583353,17.3266086 16.0249942,17.7823881 L16.1161165,17.8838835 L22.233,24 L16.1161165,30.1161165 L16.0249942,30.2176119 C15.6583353,30.6733914 15.6583353,31.3266086 16.0249942,31.7823881 L16.1161165,31.8838835 L16.2176119,31.9750058 C16.6733914,32.3416647 17.3266086,32.3416647 17.7823881,31.9750058 L17.8838835,31.8838835 L24,25.767 L30.1161165,31.8838835 L30.2176119,31.9750058 C30.6733914,32.3416647 31.3266086,32.3416647 31.7823881,31.9750058 L31.8838835,31.8838835 L31.9750058,31.7823881 C32.3416647,31.3266086 32.3416647,30.6733914 31.9750058,30.2176119 L31.8838835,30.1161165 L25.767,24 L31.8838835,17.8838835 L31.9750058,17.7823881 C32.3416647,17.3266086 32.3416647,16.6733914 31.9750058,16.2176119 L31.8838835,16.1161165 L31.7823881,16.0249942 C31.3266086,15.6583353 30.6733914,15.6583353 30.2176119,16.0249942 L30.1161165,16.1161165 L24,22.233 L17.8838835,16.1161165 L17.7823881,16.0249942 L17.8838835,16.1161165 Z"
      })))));
      const EyeIcon = vue.defineComponent({
        name: "Eye",
        render() {
          return vue.h("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512"
          }, vue.h("path", {
            d: "M255.66 112c-77.94 0-157.89 45.11-220.83 135.33a16 16 0 0 0-.27 17.77C82.92 340.8 161.8 400 255.66 400c92.84 0 173.34-59.38 221.79-135.25a16.14 16.14 0 0 0 0-17.47C428.89 172.28 347.8 112 255.66 112z",
            fill: "none",
            stroke: "currentColor",
            "stroke-linecap": "round",
            "stroke-linejoin": "round",
            "stroke-width": "32"
          }), vue.h("circle", {
            cx: "256",
            cy: "256",
            r: "80",
            fill: "none",
            stroke: "currentColor",
            "stroke-miterlimit": "10",
            "stroke-width": "32"
          }));
        }
      });
      const EyeOffIcon = vue.defineComponent({
        name: "EyeOff",
        render() {
          return vue.h("svg", {
            xmlns: "http://www.w3.org/2000/svg",
            viewBox: "0 0 512 512"
          }, vue.h("path", {
            d: "M432 448a15.92 15.92 0 0 1-11.31-4.69l-352-352a16 16 0 0 1 22.62-22.62l352 352A16 16 0 0 1 432 448z",
            fill: "currentColor"
          }), vue.h("path", {
            d: "M255.66 384c-41.49 0-81.5-12.28-118.92-36.5c-34.07-22-64.74-53.51-88.7-91v-.08c19.94-28.57 41.78-52.73 65.24-72.21a2 2 0 0 0 .14-2.94L93.5 161.38a2 2 0 0 0-2.71-.12c-24.92 21-48.05 46.76-69.08 76.92a31.92 31.92 0 0 0-.64 35.54c26.41 41.33 60.4 76.14 98.28 100.65C162 402 207.9 416 255.66 416a239.13 239.13 0 0 0 75.8-12.58a2 2 0 0 0 .77-3.31l-21.58-21.58a4 4 0 0 0-3.83-1a204.8 204.8 0 0 1-51.16 6.47z",
            fill: "currentColor"
          }), vue.h("path", {
            d: "M490.84 238.6c-26.46-40.92-60.79-75.68-99.27-100.53C349 110.55 302 96 255.66 96a227.34 227.34 0 0 0-74.89 12.83a2 2 0 0 0-.75 3.31l21.55 21.55a4 4 0 0 0 3.88 1a192.82 192.82 0 0 1 50.21-6.69c40.69 0 80.58 12.43 118.55 37c34.71 22.4 65.74 53.88 89.76 91a.13.13 0 0 1 0 .16a310.72 310.72 0 0 1-64.12 72.73a2 2 0 0 0-.15 2.95l19.9 19.89a2 2 0 0 0 2.7.13a343.49 343.49 0 0 0 68.64-78.48a32.2 32.2 0 0 0-.1-34.78z",
            fill: "currentColor"
          }), vue.h("path", {
            d: "M256 160a95.88 95.88 0 0 0-21.37 2.4a2 2 0 0 0-1 3.38l112.59 112.56a2 2 0 0 0 3.38-1A96 96 0 0 0 256 160z",
            fill: "currentColor"
          }), vue.h("path", {
            d: "M165.78 233.66a2 2 0 0 0-3.38 1a96 96 0 0 0 115 115a2 2 0 0 0 1-3.38z",
            fill: "currentColor"
          }));
        }
      });
      const FastBackwardIcon = vue.defineComponent({
        name: "FastBackward",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 20 20",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("g", {
            stroke: "none",
            "stroke-width": "1",
            fill: "none",
            "fill-rule": "evenodd"
          }, vue.h("g", {
            fill: "currentColor",
            "fill-rule": "nonzero"
          }, vue.h("path", {
            d: "M8.73171,16.7949 C9.03264,17.0795 9.50733,17.0663 9.79196,16.7654 C10.0766,16.4644 10.0634,15.9897 9.76243,15.7051 L4.52339,10.75 L17.2471,10.75 C17.6613,10.75 17.9971,10.4142 17.9971,10 C17.9971,9.58579 17.6613,9.25 17.2471,9.25 L4.52112,9.25 L9.76243,4.29275 C10.0634,4.00812 10.0766,3.53343 9.79196,3.2325 C9.50733,2.93156 9.03264,2.91834 8.73171,3.20297 L2.31449,9.27241 C2.14819,9.4297 2.04819,9.62981 2.01448,9.8386 C2.00308,9.89058 1.99707,9.94459 1.99707,10 C1.99707,10.0576 2.00356,10.1137 2.01585,10.1675 C2.05084,10.3733 2.15039,10.5702 2.31449,10.7254 L8.73171,16.7949 Z"
          }))));
        }
      });
      const FastForwardIcon = vue.defineComponent({
        name: "FastForward",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 20 20",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("g", {
            stroke: "none",
            "stroke-width": "1",
            fill: "none",
            "fill-rule": "evenodd"
          }, vue.h("g", {
            fill: "currentColor",
            "fill-rule": "nonzero"
          }, vue.h("path", {
            d: "M11.2654,3.20511 C10.9644,2.92049 10.4897,2.93371 10.2051,3.23464 C9.92049,3.53558 9.93371,4.01027 10.2346,4.29489 L15.4737,9.25 L2.75,9.25 C2.33579,9.25 2,9.58579 2,10.0000012 C2,10.4142 2.33579,10.75 2.75,10.75 L15.476,10.75 L10.2346,15.7073 C9.93371,15.9919 9.92049,16.4666 10.2051,16.7675 C10.4897,17.0684 10.9644,17.0817 11.2654,16.797 L17.6826,10.7276 C17.8489,10.5703 17.9489,10.3702 17.9826,10.1614 C17.994,10.1094 18,10.0554 18,10.0000012 C18,9.94241 17.9935,9.88633 17.9812,9.83246 C17.9462,9.62667 17.8467,9.42976 17.6826,9.27455 L11.2654,3.20511 Z"
          }))));
        }
      });
      const FilterIcon = vue.defineComponent({
        name: "Filter",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 28 28",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("g", {
            stroke: "none",
            "stroke-width": "1",
            "fill-rule": "evenodd"
          }, vue.h("g", {
            "fill-rule": "nonzero"
          }, vue.h("path", {
            d: "M17,19 C17.5522847,19 18,19.4477153 18,20 C18,20.5522847 17.5522847,21 17,21 L11,21 C10.4477153,21 10,20.5522847 10,20 C10,19.4477153 10.4477153,19 11,19 L17,19 Z M21,13 C21.5522847,13 22,13.4477153 22,14 C22,14.5522847 21.5522847,15 21,15 L7,15 C6.44771525,15 6,14.5522847 6,14 C6,13.4477153 6.44771525,13 7,13 L21,13 Z M24,7 C24.5522847,7 25,7.44771525 25,8 C25,8.55228475 24.5522847,9 24,9 L4,9 C3.44771525,9 3,8.55228475 3,8 C3,7.44771525 3.44771525,7 4,7 L24,7 Z"
          }))));
        }
      });
      const ForwardIcon = vue.defineComponent({
        name: "Forward",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 20 20",
            fill: "none",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("path", {
            d: "M7.73271 4.20694C8.03263 3.92125 8.50737 3.93279 8.79306 4.23271L13.7944 9.48318C14.0703 9.77285 14.0703 10.2281 13.7944 10.5178L8.79306 15.7682C8.50737 16.0681 8.03263 16.0797 7.73271 15.794C7.43279 15.5083 7.42125 15.0336 7.70694 14.7336L12.2155 10.0005L7.70694 5.26729C7.42125 4.96737 7.43279 4.49264 7.73271 4.20694Z",
            fill: "currentColor"
          }));
        }
      });
      const InfoIcon = replaceable("info", () => vue.h("svg", {
        viewBox: "0 0 28 28",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M14,2 C20.6274,2 26,7.37258 26,14 C26,20.6274 20.6274,26 14,26 C7.37258,26 2,20.6274 2,14 C2,7.37258 7.37258,2 14,2 Z M14,11 C13.4477,11 13,11.4477 13,12 L13,12 L13,20 C13,20.5523 13.4477,21 14,21 C14.5523,21 15,20.5523 15,20 L15,20 L15,12 C15,11.4477 14.5523,11 14,11 Z M14,6.75 C13.3096,6.75 12.75,7.30964 12.75,8 C12.75,8.69036 13.3096,9.25 14,9.25 C14.6904,9.25 15.25,8.69036 15.25,8 C15.25,7.30964 14.6904,6.75 14,6.75 Z"
      })))));
      const MoreIcon = vue.defineComponent({
        name: "More",
        render() {
          return vue.h("svg", {
            viewBox: "0 0 16 16",
            version: "1.1",
            xmlns: "http://www.w3.org/2000/svg"
          }, vue.h("g", {
            stroke: "none",
            "stroke-width": "1",
            fill: "none",
            "fill-rule": "evenodd"
          }, vue.h("g", {
            fill: "currentColor",
            "fill-rule": "nonzero"
          }, vue.h("path", {
            d: "M4,7 C4.55228,7 5,7.44772 5,8 C5,8.55229 4.55228,9 4,9 C3.44772,9 3,8.55229 3,8 C3,7.44772 3.44772,7 4,7 Z M8,7 C8.55229,7 9,7.44772 9,8 C9,8.55229 8.55229,9 8,9 C7.44772,9 7,8.55229 7,8 C7,7.44772 7.44772,7 8,7 Z M12,7 C12.5523,7 13,7.44772 13,8 C13,8.55229 12.5523,9 12,9 C11.4477,9 11,8.55229 11,8 C11,7.44772 11.4477,7 12,7 Z"
          }))));
        }
      });
      const SuccessIcon = replaceable("success", () => vue.h("svg", {
        viewBox: "0 0 48 48",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M24,4 C35.045695,4 44,12.954305 44,24 C44,35.045695 35.045695,44 24,44 C12.954305,44 4,35.045695 4,24 C4,12.954305 12.954305,4 24,4 Z M32.6338835,17.6161165 C32.1782718,17.1605048 31.4584514,17.1301307 30.9676119,17.5249942 L30.8661165,17.6161165 L20.75,27.732233 L17.1338835,24.1161165 C16.6457281,23.6279612 15.8542719,23.6279612 15.3661165,24.1161165 C14.9105048,24.5717282 14.8801307,25.2915486 15.2749942,25.7823881 L15.3661165,25.8838835 L19.8661165,30.3838835 C20.3217282,30.8394952 21.0415486,30.8698693 21.5323881,30.4750058 L21.6338835,30.3838835 L32.6338835,19.3838835 C33.1220388,18.8957281 33.1220388,18.1042719 32.6338835,17.6161165 Z"
      })))));
      const WarningIcon = replaceable("warning", () => vue.h("svg", {
        viewBox: "0 0 24 24",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg"
      }, vue.h("g", {
        stroke: "none",
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, vue.h("g", {
        "fill-rule": "nonzero"
      }, vue.h("path", {
        d: "M12,2 C17.523,2 22,6.478 22,12 C22,17.522 17.523,22 12,22 C6.477,22 2,17.522 2,12 C2,6.478 6.477,2 12,2 Z M12.0018002,15.0037242 C11.450254,15.0037242 11.0031376,15.4508407 11.0031376,16.0023869 C11.0031376,16.553933 11.450254,17.0010495 12.0018002,17.0010495 C12.5533463,17.0010495 13.0004628,16.553933 13.0004628,16.0023869 C13.0004628,15.4508407 12.5533463,15.0037242 12.0018002,15.0037242 Z M11.99964,7 C11.4868042,7.00018474 11.0642719,7.38637706 11.0066858,7.8837365 L11,8.00036004 L11.0018003,13.0012393 L11.00857,13.117858 C11.0665141,13.6151758 11.4893244,14.0010638 12.0021602,14.0008793 C12.514996,14.0006946 12.9375283,13.6145023 12.9951144,13.1171428 L13.0018002,13.0005193 L13,7.99964009 L12.9932303,7.8830214 C12.9352861,7.38570354 12.5124758,6.99981552 11.99964,7 Z"
      })))));
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut$4
      } = commonVariables$e;
      function iconSwitchTransition({
        originalTransform = "",
        left = 0,
        top = 0,
        transition = `all .3s ${cubicBezierEaseInOut$4} !important`
      } = {}) {
        return [c$1("&.icon-switch-transition-enter-from, &.icon-switch-transition-leave-to", {
          transform: `${originalTransform} scale(0.75)`,
          left,
          top,
          opacity: 0
        }), c$1("&.icon-switch-transition-enter-to, &.icon-switch-transition-leave-from", {
          transform: `scale(1) ${originalTransform}`,
          left,
          top,
          opacity: 1
        }), c$1("&.icon-switch-transition-enter-active, &.icon-switch-transition-leave-active", {
          transformOrigin: "center",
          position: "absolute",
          left,
          top,
          transition
        })];
      }
      const style$w = cB("base-clear", `
 flex-shrink: 0;
 height: 1em;
 width: 1em;
 position: relative;
`, [c$1(">", [cE("clear", `
 font-size: var(--n-clear-size);
 height: 1em;
 width: 1em;
 cursor: pointer;
 color: var(--n-clear-color);
 transition: color .3s var(--n-bezier);
 display: flex;
 `, [c$1("&:hover", `
 color: var(--n-clear-color-hover)!important;
 `), c$1("&:active", `
 color: var(--n-clear-color-pressed)!important;
 `)]), cE("placeholder", `
 display: flex;
 `), cE("clear, placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
        originalTransform: "translateX(-50%) translateY(-50%)",
        left: "50%",
        top: "50%"
      })])])]);
      const NBaseClear = vue.defineComponent({
        name: "BaseClear",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          show: Boolean,
          onClear: Function
        },
        setup(props) {
          useStyle("-base-clear", style$w, vue.toRef(props, "clsPrefix"));
          return {
            handleMouseDown(e) {
              e.preventDefault();
            }
          };
        },
        render() {
          const {
            clsPrefix
          } = this;
          return vue.h("div", {
            class: `${clsPrefix}-base-clear`
          }, vue.h(NIconSwitchTransition, null, {
            default: () => {
              var _a, _b;
              return this.show ? vue.h("div", {
                key: "dismiss",
                class: `${clsPrefix}-base-clear__clear`,
                onClick: this.onClear,
                onMousedown: this.handleMouseDown,
                "data-clear": true
              }, resolveSlot(this.$slots.icon, () => [vue.h(NBaseIcon, {
                clsPrefix
              }, {
                default: () => vue.h(ClearIcon, null)
              })])) : vue.h("div", {
                key: "icon",
                class: `${clsPrefix}-base-clear__placeholder`
              }, (_b = (_a = this.$slots).placeholder) === null || _b === void 0 ? void 0 : _b.call(_a));
            }
          }));
        }
      });
      const style$v = cB("base-close", `
 display: flex;
 align-items: center;
 justify-content: center;
 cursor: pointer;
 background-color: transparent;
 color: var(--n-close-icon-color);
 border-radius: var(--n-close-border-radius);
 height: var(--n-close-size);
 width: var(--n-close-size);
 font-size: var(--n-close-icon-size);
 outline: none;
 border: none;
 position: relative;
 padding: 0;
`, [cM("absolute", `
 height: var(--n-close-icon-size);
 width: var(--n-close-icon-size);
 `), c$1("&::before", `
 content: "";
 position: absolute;
 width: var(--n-close-size);
 height: var(--n-close-size);
 left: 50%;
 top: 50%;
 transform: translateY(-50%) translateX(-50%);
 transition: inherit;
 border-radius: inherit;
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c$1("&:hover::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:focus::before", `
 background-color: var(--n-close-color-hover);
 `), c$1("&:active", `
 color: var(--n-close-icon-color-pressed);
 `), c$1("&:active::before", `
 background-color: var(--n-close-color-pressed);
 `)]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-close-icon-color-disabled);
 background-color: transparent;
 `), cM("round", [c$1("&::before", `
 border-radius: 50%;
 `)])]);
      const NBaseClose = vue.defineComponent({
        name: "BaseClose",
        props: {
          isButtonTag: {
            type: Boolean,
            default: true
          },
          clsPrefix: {
            type: String,
            required: true
          },
          disabled: {
            type: Boolean,
            default: void 0
          },
          focusable: {
            type: Boolean,
            default: true
          },
          round: Boolean,
          onClick: Function,
          absolute: Boolean
        },
        setup(props) {
          useStyle("-base-close", style$v, vue.toRef(props, "clsPrefix"));
          return () => {
            const {
              clsPrefix,
              disabled,
              absolute,
              round,
              isButtonTag
            } = props;
            const Tag = isButtonTag ? "button" : "div";
            return vue.h(Tag, {
              type: isButtonTag ? "button" : void 0,
              tabindex: disabled || !props.focusable ? -1 : 0,
              "aria-disabled": disabled,
              "aria-label": "close",
              role: isButtonTag ? void 0 : "button",
              disabled,
              class: [`${clsPrefix}-base-close`, absolute && `${clsPrefix}-base-close--absolute`, disabled && `${clsPrefix}-base-close--disabled`, round && `${clsPrefix}-base-close--round`],
              onMousedown: (e) => {
                if (!props.focusable) {
                  e.preventDefault();
                }
              },
              onClick: props.onClick
            }, vue.h(NBaseIcon, {
              clsPrefix
            }, {
              default: () => vue.h(ErrorIcon$1, null)
            }));
          };
        }
      });
      const NFadeInExpandTransition = vue.defineComponent({
        name: "FadeInExpandTransition",
        props: {
          appear: Boolean,
          group: Boolean,
          mode: String,
          onLeave: Function,
          onAfterLeave: Function,
          onAfterEnter: Function,
          width: Boolean,

reverse: Boolean
        },
        setup(props, {
          slots
        }) {
          function handleBeforeLeave(el) {
            if (props.width) {
              el.style.maxWidth = `${el.offsetWidth}px`;
            } else {
              el.style.maxHeight = `${el.offsetHeight}px`;
            }
            void el.offsetWidth;
          }
          function handleLeave(el) {
            if (props.width) {
              el.style.maxWidth = "0";
            } else {
              el.style.maxHeight = "0";
            }
            void el.offsetWidth;
            const {
              onLeave
            } = props;
            if (onLeave) onLeave();
          }
          function handleAfterLeave(el) {
            if (props.width) {
              el.style.maxWidth = "";
            } else {
              el.style.maxHeight = "";
            }
            const {
              onAfterLeave
            } = props;
            if (onAfterLeave) onAfterLeave();
          }
          function handleEnter(el) {
            el.style.transition = "none";
            if (props.width) {
              const memorizedWidth = el.offsetWidth;
              el.style.maxWidth = "0";
              void el.offsetWidth;
              el.style.transition = "";
              el.style.maxWidth = `${memorizedWidth}px`;
            } else {
              if (props.reverse) {
                el.style.maxHeight = `${el.offsetHeight}px`;
                void el.offsetHeight;
                el.style.transition = "";
                el.style.maxHeight = "0";
              } else {
                const memorizedHeight = el.offsetHeight;
                el.style.maxHeight = "0";
                void el.offsetWidth;
                el.style.transition = "";
                el.style.maxHeight = `${memorizedHeight}px`;
              }
            }
            void el.offsetWidth;
          }
          function handleAfterEnter(el) {
            var _a;
            if (props.width) {
              el.style.maxWidth = "";
            } else {
              if (!props.reverse) {
                el.style.maxHeight = "";
              }
            }
            (_a = props.onAfterEnter) === null || _a === void 0 ? void 0 : _a.call(props);
          }
          return () => {
            const {
              group,
              width,
              appear,
              mode
            } = props;
            const type = group ? vue.TransitionGroup : vue.Transition;
            const resolvedProps = {
              name: width ? "fade-in-width-expand-transition" : "fade-in-height-expand-transition",
              appear,
              onEnter: handleEnter,
              onAfterEnter: handleAfterEnter,
              onBeforeLeave: handleBeforeLeave,
              onLeave: handleLeave,
              onAfterLeave: handleAfterLeave
            };
            if (!group) {
              resolvedProps.mode = mode;
            }
            return vue.h(type, resolvedProps, slots);
          };
        }
      });
      const FocusDetector = vue.defineComponent({
        props: {
          onFocus: Function,
          onBlur: Function
        },
        setup(props) {
          return () => vue.h("div", {
            style: "width: 0; height: 0",
            tabindex: 0,
            onFocus: props.onFocus,
            onBlur: props.onBlur
          });
        }
      });
      const style$u = c$1([c$1("@keyframes rotator", `
 0% {
 -webkit-transform: rotate(0deg);
 transform: rotate(0deg);
 }
 100% {
 -webkit-transform: rotate(360deg);
 transform: rotate(360deg);
 }`), cB("base-loading", `
 position: relative;
 line-height: 0;
 width: 1em;
 height: 1em;
 `, [cE("transition-wrapper", `
 position: absolute;
 width: 100%;
 height: 100%;
 `, [iconSwitchTransition()]), cE("placeholder", `
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 `, [iconSwitchTransition({
        left: "50%",
        top: "50%",
        originalTransform: "translateX(-50%) translateY(-50%)"
      })]), cE("container", `
 animation: rotator 3s linear infinite both;
 `, [cE("icon", `
 height: 1em;
 width: 1em;
 `)])])]);
      const duration = "1.6s";
      const exposedLoadingProps = {
        strokeWidth: {
          type: Number,
          default: 28
        },
        stroke: {
          type: String,
          default: void 0
        }
      };
      const NBaseLoading = vue.defineComponent({
        name: "BaseLoading",
        props: Object.assign({
          clsPrefix: {
            type: String,
            required: true
          },
          show: {
            type: Boolean,
            default: true
          },
          scale: {
            type: Number,
            default: 1
          },
          radius: {
            type: Number,
            default: 100
          }
        }, exposedLoadingProps),
        setup(props) {
          useStyle("-base-loading", style$u, vue.toRef(props, "clsPrefix"));
        },
        render() {
          const {
            clsPrefix,
            radius,
            strokeWidth,
            stroke,
            scale
          } = this;
          const scaledRadius = radius / scale;
          return vue.h("div", {
            class: `${clsPrefix}-base-loading`,
            role: "img",
            "aria-label": "loading"
          }, vue.h(NIconSwitchTransition, null, {
            default: () => this.show ? vue.h("div", {
              key: "icon",
              class: `${clsPrefix}-base-loading__transition-wrapper`
            }, vue.h("div", {
              class: `${clsPrefix}-base-loading__container`
            }, vue.h("svg", {
              class: `${clsPrefix}-base-loading__icon`,
              viewBox: `0 0 ${2 * scaledRadius} ${2 * scaledRadius}`,
              xmlns: "http://www.w3.org/2000/svg",
              style: {
                color: stroke
              }
            }, vue.h("g", null, vue.h("animateTransform", {
              attributeName: "transform",
              type: "rotate",
              values: `0 ${scaledRadius} ${scaledRadius};270 ${scaledRadius} ${scaledRadius}`,
              begin: "0s",
              dur: duration,
              fill: "freeze",
              repeatCount: "indefinite"
            }), vue.h("circle", {
              class: `${clsPrefix}-base-loading__icon`,
              fill: "none",
              stroke: "currentColor",
              "stroke-width": strokeWidth,
              "stroke-linecap": "round",
              cx: scaledRadius,
              cy: scaledRadius,
              r: radius - strokeWidth / 2,
              "stroke-dasharray": 5.67 * radius,
              "stroke-dashoffset": 18.48 * radius
            }, vue.h("animateTransform", {
              attributeName: "transform",
              type: "rotate",
              values: `0 ${scaledRadius} ${scaledRadius};135 ${scaledRadius} ${scaledRadius};450 ${scaledRadius} ${scaledRadius}`,
              begin: "0s",
              dur: duration,
              fill: "freeze",
              repeatCount: "indefinite"
            }), vue.h("animate", {
              attributeName: "stroke-dashoffset",
              values: `${5.67 * radius};${1.42 * radius};${5.67 * radius}`,
              begin: "0s",
              dur: duration,
              fill: "freeze",
              repeatCount: "indefinite"
            })))))) : vue.h("div", {
              key: "placeholder",
              class: `${clsPrefix}-base-loading__placeholder`
            }, this.$slots)
          }));
        }
      });
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut$3
      } = commonVariables$e;
      function fadeInTransition({
        name = "fade-in",
        enterDuration = "0.2s",
        leaveDuration = "0.2s",
        enterCubicBezier = cubicBezierEaseInOut$3,
        leaveCubicBezier = cubicBezierEaseInOut$3
      } = {}) {
        return [c$1(`&.${name}-transition-enter-active`, {
          transition: `all ${enterDuration} ${enterCubicBezier}!important`
        }), c$1(`&.${name}-transition-leave-active`, {
          transition: `all ${leaveDuration} ${leaveCubicBezier}!important`
        }), c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
          opacity: 0
        }), c$1(`&.${name}-transition-leave-from, &.${name}-transition-enter-to`, {
          opacity: 1
        })];
      }
      const base = {
        neutralBase: "#FFF",
        neutralInvertBase: "#000",
        neutralTextBase: "#000",
        neutralPopover: "#fff",
        neutralCard: "#fff",
        neutralModal: "#fff",
        neutralBody: "#fff",
        alpha1: "0.82",
        alpha2: "0.72",
        alpha3: "0.38",
        alpha4: "0.24",
alpha5: "0.18",
alphaClose: "0.6",
        alphaDisabled: "0.5",
        alphaAvatar: "0.2",
        alphaProgressRail: ".08",
        alphaInput: "0",
        alphaScrollbar: "0.25",
        alphaScrollbarHover: "0.4",
primaryHover: "#36ad6a",
        primaryDefault: "#18a058",
        primaryActive: "#0c7a43",
        primarySuppl: "#36ad6a",
infoHover: "#4098fc",
        infoDefault: "#2080f0",
        infoActive: "#1060c9",
        infoSuppl: "#4098fc",
errorHover: "#de576d",
        errorDefault: "#d03050",
        errorActive: "#ab1f3f",
        errorSuppl: "#de576d",
warningHover: "#fcb040",
        warningDefault: "#f0a020",
        warningActive: "#c97c10",
        warningSuppl: "#fcb040",
successHover: "#36ad6a",
        successDefault: "#18a058",
        successActive: "#0c7a43",
        successSuppl: "#36ad6a"
      };
      const baseBackgroundRgb = rgba(base.neutralBase);
      const baseInvertBackgroundRgb = rgba(base.neutralInvertBase);
      const overlayPrefix = `rgba(${baseInvertBackgroundRgb.slice(0, 3).join(", ")}, `;
      function overlay(alpha) {
        return `${overlayPrefix + String(alpha)})`;
      }
      function neutral(alpha) {
        const overlayRgba = Array.from(baseInvertBackgroundRgb);
        overlayRgba[3] = Number(alpha);
        return composite(baseBackgroundRgb, overlayRgba);
      }
      const derived = Object.assign(Object.assign({
        name: "common"
      }, commonVariables$e), {
        baseColor: base.neutralBase,
primaryColor: base.primaryDefault,
        primaryColorHover: base.primaryHover,
        primaryColorPressed: base.primaryActive,
        primaryColorSuppl: base.primarySuppl,
infoColor: base.infoDefault,
        infoColorHover: base.infoHover,
        infoColorPressed: base.infoActive,
        infoColorSuppl: base.infoSuppl,
successColor: base.successDefault,
        successColorHover: base.successHover,
        successColorPressed: base.successActive,
        successColorSuppl: base.successSuppl,
warningColor: base.warningDefault,
        warningColorHover: base.warningHover,
        warningColorPressed: base.warningActive,
        warningColorSuppl: base.warningSuppl,
errorColor: base.errorDefault,
        errorColorHover: base.errorHover,
        errorColorPressed: base.errorActive,
        errorColorSuppl: base.errorSuppl,
textColorBase: base.neutralTextBase,
        textColor1: "rgb(31, 34, 37)",
        textColor2: "rgb(51, 54, 57)",
        textColor3: "rgb(118, 124, 130)",

textColorDisabled: neutral(base.alpha4),
        placeholderColor: neutral(base.alpha4),
        placeholderColorDisabled: neutral(base.alpha5),
        iconColor: neutral(base.alpha4),
        iconColorHover: scaleColor(neutral(base.alpha4), {
          lightness: 0.75
        }),
        iconColorPressed: scaleColor(neutral(base.alpha4), {
          lightness: 0.9
        }),
        iconColorDisabled: neutral(base.alpha5),
        opacity1: base.alpha1,
        opacity2: base.alpha2,
        opacity3: base.alpha3,
        opacity4: base.alpha4,
        opacity5: base.alpha5,
        dividerColor: "rgb(239, 239, 245)",
        borderColor: "rgb(224, 224, 230)",
closeIconColor: neutral(Number(base.alphaClose)),
        closeIconColorHover: neutral(Number(base.alphaClose)),
        closeIconColorPressed: neutral(Number(base.alphaClose)),
        closeColorHover: "rgba(0, 0, 0, .09)",
        closeColorPressed: "rgba(0, 0, 0, .13)",
clearColor: neutral(base.alpha4),
        clearColorHover: scaleColor(neutral(base.alpha4), {
          lightness: 0.75
        }),
        clearColorPressed: scaleColor(neutral(base.alpha4), {
          lightness: 0.9
        }),
        scrollbarColor: overlay(base.alphaScrollbar),
        scrollbarColorHover: overlay(base.alphaScrollbarHover),
        scrollbarWidth: "5px",
        scrollbarHeight: "5px",
        scrollbarBorderRadius: "5px",
        progressRailColor: neutral(base.alphaProgressRail),
        railColor: "rgb(219, 219, 223)",
        popoverColor: base.neutralPopover,
        tableColor: base.neutralCard,
        cardColor: base.neutralCard,
        modalColor: base.neutralModal,
        bodyColor: base.neutralBody,
        tagColor: "#eee",
        avatarColor: neutral(base.alphaAvatar),
        invertedColor: "rgb(0, 20, 40)",
        inputColor: neutral(base.alphaInput),
        codeColor: "rgb(244, 244, 248)",
        tabColor: "rgb(247, 247, 250)",
        actionColor: "rgb(250, 250, 252)",
        tableHeaderColor: "rgb(250, 250, 252)",
        hoverColor: "rgb(243, 243, 245)",
tableColorHover: "rgba(0, 0, 100, 0.03)",
        tableColorStriped: "rgba(0, 0, 100, 0.02)",
        pressedColor: "rgb(237, 237, 239)",
        opacityDisabled: base.alphaDisabled,
        inputColorDisabled: "rgb(250, 250, 252)",

buttonColor2: "rgba(46, 51, 56, .05)",
        buttonColor2Hover: "rgba(46, 51, 56, .09)",
        buttonColor2Pressed: "rgba(46, 51, 56, .13)",
        boxShadow1: "0 1px 2px -2px rgba(0, 0, 0, .08), 0 3px 6px 0 rgba(0, 0, 0, .06), 0 5px 12px 4px rgba(0, 0, 0, .04)",
        boxShadow2: "0 3px 6px -4px rgba(0, 0, 0, .12), 0 6px 16px 0 rgba(0, 0, 0, .08), 0 9px 28px 8px rgba(0, 0, 0, .05)",
        boxShadow3: "0 6px 16px -9px rgba(0, 0, 0, .08), 0 9px 28px 0 rgba(0, 0, 0, .05), 0 12px 48px 16px rgba(0, 0, 0, .03)"
      });
      const commonVars$8 = {
        railInsetHorizontalBottom: "auto 2px 4px 2px",
        railInsetHorizontalTop: "4px 2px auto 2px",
        railInsetVerticalRight: "2px 4px 2px auto",
        railInsetVerticalLeft: "2px auto 2px 4px",
        railColor: "transparent"
      };
      function self$t(vars) {
        const {
          scrollbarColor,
          scrollbarColorHover,
          scrollbarHeight,
          scrollbarWidth,
          scrollbarBorderRadius
        } = vars;
        return Object.assign(Object.assign({}, commonVars$8), {
          height: scrollbarHeight,
          width: scrollbarWidth,
          borderRadius: scrollbarBorderRadius,
          color: scrollbarColor,
          colorHover: scrollbarColorHover
        });
      }
      const scrollbarLight = {
        name: "Scrollbar",
        common: derived,
        self: self$t
      };
      const style$t = cB("scrollbar", `
 overflow: hidden;
 position: relative;
 z-index: auto;
 height: 100%;
 width: 100%;
`, [c$1(">", [cB("scrollbar-container", `
 width: 100%;
 overflow: scroll;
 height: 100%;
 min-height: inherit;
 max-height: inherit;
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1(">", [
cB("scrollbar-content", `
 box-sizing: border-box;
 min-width: 100%;
 `)
      ])])]), c$1(">, +", [cB("scrollbar-rail", `
 position: absolute;
 pointer-events: none;
 user-select: none;
 background: var(--n-scrollbar-rail-color);
 -webkit-user-select: none;
 `, [cM("horizontal", `
 height: var(--n-scrollbar-height);
 `, [c$1(">", [cE("scrollbar", `
 height: var(--n-scrollbar-height);
 border-radius: var(--n-scrollbar-border-radius);
 right: 0;
 `)])]), cM("horizontal--top", `
 top: var(--n-scrollbar-rail-top-horizontal-top); 
 right: var(--n-scrollbar-rail-right-horizontal-top); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-top); 
 left: var(--n-scrollbar-rail-left-horizontal-top); 
 `), cM("horizontal--bottom", `
 top: var(--n-scrollbar-rail-top-horizontal-bottom); 
 right: var(--n-scrollbar-rail-right-horizontal-bottom); 
 bottom: var(--n-scrollbar-rail-bottom-horizontal-bottom); 
 left: var(--n-scrollbar-rail-left-horizontal-bottom); 
 `), cM("vertical", `
 width: var(--n-scrollbar-width);
 `, [c$1(">", [cE("scrollbar", `
 width: var(--n-scrollbar-width);
 border-radius: var(--n-scrollbar-border-radius);
 bottom: 0;
 `)])]), cM("vertical--left", `
 top: var(--n-scrollbar-rail-top-vertical-left); 
 right: var(--n-scrollbar-rail-right-vertical-left); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-left); 
 left: var(--n-scrollbar-rail-left-vertical-left); 
 `), cM("vertical--right", `
 top: var(--n-scrollbar-rail-top-vertical-right); 
 right: var(--n-scrollbar-rail-right-vertical-right); 
 bottom: var(--n-scrollbar-rail-bottom-vertical-right); 
 left: var(--n-scrollbar-rail-left-vertical-right); 
 `), cM("disabled", [c$1(">", [cE("scrollbar", "pointer-events: none;")])]), c$1(">", [cE("scrollbar", `
 z-index: 1;
 position: absolute;
 cursor: pointer;
 pointer-events: all;
 background-color: var(--n-scrollbar-color);
 transition: background-color .2s var(--n-scrollbar-bezier);
 `, [fadeInTransition(), c$1("&:hover", "background-color: var(--n-scrollbar-color-hover);")])])])])]);
      const scrollbarProps = Object.assign(Object.assign({}, useTheme.props), {
        duration: {
          type: Number,
          default: 0
        },
        scrollable: {
          type: Boolean,
          default: true
        },
        xScrollable: Boolean,
        trigger: {
          type: String,
          default: "hover"
        },
        useUnifiedContainer: Boolean,
        triggerDisplayManually: Boolean,
container: Function,
        content: Function,
        containerClass: String,
        containerStyle: [String, Object],
        contentClass: [String, Array],
        contentStyle: [String, Object],
        horizontalRailStyle: [String, Object],
        verticalRailStyle: [String, Object],
        onScroll: Function,
        onWheel: Function,
        onResize: Function,
        internalOnUpdateScrollLeft: Function,
        internalHoistYRail: Boolean,
        yPlacement: {
          type: String,
          default: "right"
        },
        xPlacement: {
          type: String,
          default: "bottom"
        }
      });
      const Scrollbar = vue.defineComponent({
        name: "Scrollbar",
        props: scrollbarProps,
        inheritAttrs: false,
        setup(props) {
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const rtlEnabledRef = useRtl("Scrollbar", mergedRtlRef, mergedClsPrefixRef);
          const wrapperRef = vue.ref(null);
          const containerRef = vue.ref(null);
          const contentRef = vue.ref(null);
          const yRailRef = vue.ref(null);
          const xRailRef = vue.ref(null);
          const contentHeightRef = vue.ref(null);
          const contentWidthRef = vue.ref(null);
          const containerHeightRef = vue.ref(null);
          const containerWidthRef = vue.ref(null);
          const yRailSizeRef = vue.ref(null);
          const xRailSizeRef = vue.ref(null);
          const containerScrollTopRef = vue.ref(0);
          const containerScrollLeftRef = vue.ref(0);
          const isShowXBarRef = vue.ref(false);
          const isShowYBarRef = vue.ref(false);
          let yBarPressed = false;
          let xBarPressed = false;
          let xBarVanishTimerId;
          let yBarVanishTimerId;
          let memoYTop = 0;
          let memoXLeft = 0;
          let memoMouseX = 0;
          let memoMouseY = 0;
          const isIos2 = useIsIos();
          const themeRef = useTheme("Scrollbar", "-scrollbar", style$t, scrollbarLight, props, mergedClsPrefixRef);
          const yBarSizeRef = vue.computed(() => {
            const {
              value: containerHeight
            } = containerHeightRef;
            const {
              value: contentHeight
            } = contentHeightRef;
            const {
              value: yRailSize
            } = yRailSizeRef;
            if (containerHeight === null || contentHeight === null || yRailSize === null) {
              return 0;
            } else {
              return Math.min(containerHeight, yRailSize * containerHeight / contentHeight + depx(themeRef.value.self.width) * 1.5);
            }
          });
          const yBarSizePxRef = vue.computed(() => {
            return `${yBarSizeRef.value}px`;
          });
          const xBarSizeRef = vue.computed(() => {
            const {
              value: containerWidth
            } = containerWidthRef;
            const {
              value: contentWidth
            } = contentWidthRef;
            const {
              value: xRailSize
            } = xRailSizeRef;
            if (containerWidth === null || contentWidth === null || xRailSize === null) {
              return 0;
            } else {
              return xRailSize * containerWidth / contentWidth + depx(themeRef.value.self.height) * 1.5;
            }
          });
          const xBarSizePxRef = vue.computed(() => {
            return `${xBarSizeRef.value}px`;
          });
          const yBarTopRef = vue.computed(() => {
            const {
              value: containerHeight
            } = containerHeightRef;
            const {
              value: containerScrollTop
            } = containerScrollTopRef;
            const {
              value: contentHeight
            } = contentHeightRef;
            const {
              value: yRailSize
            } = yRailSizeRef;
            if (containerHeight === null || contentHeight === null || yRailSize === null) {
              return 0;
            } else {
              const heightDiff = contentHeight - containerHeight;
              if (!heightDiff) return 0;
              return containerScrollTop / heightDiff * (yRailSize - yBarSizeRef.value);
            }
          });
          const yBarTopPxRef = vue.computed(() => {
            return `${yBarTopRef.value}px`;
          });
          const xBarLeftRef = vue.computed(() => {
            const {
              value: containerWidth
            } = containerWidthRef;
            const {
              value: containerScrollLeft
            } = containerScrollLeftRef;
            const {
              value: contentWidth
            } = contentWidthRef;
            const {
              value: xRailSize
            } = xRailSizeRef;
            if (containerWidth === null || contentWidth === null || xRailSize === null) {
              return 0;
            } else {
              const widthDiff = contentWidth - containerWidth;
              if (!widthDiff) return 0;
              return containerScrollLeft / widthDiff * (xRailSize - xBarSizeRef.value);
            }
          });
          const xBarLeftPxRef = vue.computed(() => {
            return `${xBarLeftRef.value}px`;
          });
          const needYBarRef = vue.computed(() => {
            const {
              value: containerHeight
            } = containerHeightRef;
            const {
              value: contentHeight
            } = contentHeightRef;
            return containerHeight !== null && contentHeight !== null && contentHeight > containerHeight;
          });
          const needXBarRef = vue.computed(() => {
            const {
              value: containerWidth
            } = containerWidthRef;
            const {
              value: contentWidth
            } = contentWidthRef;
            return containerWidth !== null && contentWidth !== null && contentWidth > containerWidth;
          });
          const mergedShowXBarRef = vue.computed(() => {
            const {
              trigger: trigger2
            } = props;
            return trigger2 === "none" || isShowXBarRef.value;
          });
          const mergedShowYBarRef = vue.computed(() => {
            const {
              trigger: trigger2
            } = props;
            return trigger2 === "none" || isShowYBarRef.value;
          });
          const mergedContainerRef = vue.computed(() => {
            const {
              container
            } = props;
            if (container) return container();
            return containerRef.value;
          });
          const mergedContentRef = vue.computed(() => {
            const {
              content
            } = props;
            if (content) return content();
            return contentRef.value;
          });
          const scrollTo = (options, y) => {
            if (!props.scrollable) return;
            if (typeof options === "number") {
              scrollToPosition(options, y !== null && y !== void 0 ? y : 0, 0, false, "auto");
              return;
            }
            const {
              left,
              top,
              index,
              elSize,
              position,
              behavior,
              el,
              debounce: debounce2 = true
            } = options;
            if (left !== void 0 || top !== void 0) {
              scrollToPosition(left !== null && left !== void 0 ? left : 0, top !== null && top !== void 0 ? top : 0, 0, false, behavior);
            }
            if (el !== void 0) {
              scrollToPosition(0, el.offsetTop, el.offsetHeight, debounce2, behavior);
            } else if (index !== void 0 && elSize !== void 0) {
              scrollToPosition(0, index * elSize, elSize, debounce2, behavior);
            } else if (position === "bottom") {
              scrollToPosition(0, Number.MAX_SAFE_INTEGER, 0, false, behavior);
            } else if (position === "top") {
              scrollToPosition(0, 0, 0, false, behavior);
            }
          };
          const activateState = useReactivated(() => {
            if (!props.container) {
              scrollTo({
                top: containerScrollTopRef.value,
                left: containerScrollLeftRef.value
              });
            }
          });
          const handleContentResize = () => {
            if (activateState.isDeactivated) return;
            sync();
          };
          const handleContainerResize = (e) => {
            if (activateState.isDeactivated) return;
            const {
              onResize
            } = props;
            if (onResize) onResize(e);
            sync();
          };
          const scrollBy = (options, y) => {
            if (!props.scrollable) return;
            const {
              value: container
            } = mergedContainerRef;
            if (!container) return;
            if (typeof options === "object") {
              container.scrollBy(options);
            } else {
              container.scrollBy(options, y || 0);
            }
          };
          function scrollToPosition(left, top, elSize, debounce2, behavior) {
            const {
              value: container
            } = mergedContainerRef;
            if (!container) return;
            if (debounce2) {
              const {
                scrollTop,
                offsetHeight
              } = container;
              if (top > scrollTop) {
                if (top + elSize <= scrollTop + offsetHeight) ;
                else {
                  container.scrollTo({
                    left,
                    top: top + elSize - offsetHeight,
                    behavior
                  });
                }
                return;
              }
            }
            container.scrollTo({
              left,
              top,
              behavior
            });
          }
          function handleMouseEnterWrapper() {
            showXBar();
            showYBar();
            sync();
          }
          function handleMouseLeaveWrapper() {
            hideBar();
          }
          function hideBar() {
            hideYBar();
            hideXBar();
          }
          function hideYBar() {
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            yBarVanishTimerId = window.setTimeout(() => {
              isShowYBarRef.value = false;
            }, props.duration);
          }
          function hideXBar() {
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            xBarVanishTimerId = window.setTimeout(() => {
              isShowXBarRef.value = false;
            }, props.duration);
          }
          function showXBar() {
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            isShowXBarRef.value = true;
          }
          function showYBar() {
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            isShowYBarRef.value = true;
          }
          function handleScroll(e) {
            const {
              onScroll
            } = props;
            if (onScroll) onScroll(e);
            syncScrollState();
          }
          function syncScrollState() {
            const {
              value: container
            } = mergedContainerRef;
            if (container) {
              containerScrollTopRef.value = container.scrollTop;
              containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
            }
          }
          function syncPositionState() {
            const {
              value: content
            } = mergedContentRef;
            if (content) {
              contentHeightRef.value = content.offsetHeight;
              contentWidthRef.value = content.offsetWidth;
            }
            const {
              value: container
            } = mergedContainerRef;
            if (container) {
              containerHeightRef.value = container.offsetHeight;
              containerWidthRef.value = container.offsetWidth;
            }
            const {
              value: xRailEl
            } = xRailRef;
            const {
              value: yRailEl
            } = yRailRef;
            if (xRailEl) {
              xRailSizeRef.value = xRailEl.offsetWidth;
            }
            if (yRailEl) {
              yRailSizeRef.value = yRailEl.offsetHeight;
            }
          }
          function syncUnifiedContainer() {
            const {
              value: container
            } = mergedContainerRef;
            if (container) {
              containerScrollTopRef.value = container.scrollTop;
              containerScrollLeftRef.value = container.scrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
              containerHeightRef.value = container.offsetHeight;
              containerWidthRef.value = container.offsetWidth;
              contentHeightRef.value = container.scrollHeight;
              contentWidthRef.value = container.scrollWidth;
            }
            const {
              value: xRailEl
            } = xRailRef;
            const {
              value: yRailEl
            } = yRailRef;
            if (xRailEl) {
              xRailSizeRef.value = xRailEl.offsetWidth;
            }
            if (yRailEl) {
              yRailSizeRef.value = yRailEl.offsetHeight;
            }
          }
          function sync() {
            if (!props.scrollable) return;
            if (props.useUnifiedContainer) {
              syncUnifiedContainer();
            } else {
              syncPositionState();
              syncScrollState();
            }
          }
          function isMouseUpAway(e) {
            var _a;
            return !((_a = wrapperRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e)));
          }
          function handleXScrollMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            xBarPressed = true;
            on("mousemove", window, handleXScrollMouseMove, true);
            on("mouseup", window, handleXScrollMouseUp, true);
            memoXLeft = containerScrollLeftRef.value;
            memoMouseX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX : e.clientX;
          }
          function handleXScrollMouseMove(e) {
            if (!xBarPressed) return;
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            const {
              value: containerWidth
            } = containerWidthRef;
            const {
              value: contentWidth
            } = contentWidthRef;
            const {
              value: xBarSize
            } = xBarSizeRef;
            if (containerWidth === null || contentWidth === null) return;
            const dX = (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? window.innerWidth - e.clientX - memoMouseX : e.clientX - memoMouseX;
            const dScrollLeft = dX * (contentWidth - containerWidth) / (containerWidth - xBarSize);
            const toScrollLeftUpperBound = contentWidth - containerWidth;
            let toScrollLeft = memoXLeft + dScrollLeft;
            toScrollLeft = Math.min(toScrollLeftUpperBound, toScrollLeft);
            toScrollLeft = Math.max(toScrollLeft, 0);
            const {
              value: container
            } = mergedContainerRef;
            if (container) {
              container.scrollLeft = toScrollLeft * ((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? -1 : 1);
              const {
                internalOnUpdateScrollLeft
              } = props;
              if (internalOnUpdateScrollLeft) internalOnUpdateScrollLeft(toScrollLeft);
            }
          }
          function handleXScrollMouseUp(e) {
            e.preventDefault();
            e.stopPropagation();
            off("mousemove", window, handleXScrollMouseMove, true);
            off("mouseup", window, handleXScrollMouseUp, true);
            xBarPressed = false;
            sync();
            if (isMouseUpAway(e)) {
              hideBar();
            }
          }
          function handleYScrollMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            yBarPressed = true;
            on("mousemove", window, handleYScrollMouseMove, true);
            on("mouseup", window, handleYScrollMouseUp, true);
            memoYTop = containerScrollTopRef.value;
            memoMouseY = e.clientY;
          }
          function handleYScrollMouseMove(e) {
            if (!yBarPressed) return;
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            const {
              value: containerHeight
            } = containerHeightRef;
            const {
              value: contentHeight
            } = contentHeightRef;
            const {
              value: yBarSize
            } = yBarSizeRef;
            if (containerHeight === null || contentHeight === null) return;
            const dY = e.clientY - memoMouseY;
            const dScrollTop = dY * (contentHeight - containerHeight) / (containerHeight - yBarSize);
            const toScrollTopUpperBound = contentHeight - containerHeight;
            let toScrollTop = memoYTop + dScrollTop;
            toScrollTop = Math.min(toScrollTopUpperBound, toScrollTop);
            toScrollTop = Math.max(toScrollTop, 0);
            const {
              value: container
            } = mergedContainerRef;
            if (container) {
              container.scrollTop = toScrollTop;
            }
          }
          function handleYScrollMouseUp(e) {
            e.preventDefault();
            e.stopPropagation();
            off("mousemove", window, handleYScrollMouseMove, true);
            off("mouseup", window, handleYScrollMouseUp, true);
            yBarPressed = false;
            sync();
            if (isMouseUpAway(e)) {
              hideBar();
            }
          }
          vue.watchEffect(() => {
            const {
              value: needXBar
            } = needXBarRef;
            const {
              value: needYBar
            } = needYBarRef;
            const {
              value: mergedClsPrefix
            } = mergedClsPrefixRef;
            const {
              value: xRailEl
            } = xRailRef;
            const {
              value: yRailEl
            } = yRailRef;
            if (xRailEl) {
              if (!needXBar) {
                xRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
              } else {
                xRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
              }
            }
            if (yRailEl) {
              if (!needYBar) {
                yRailEl.classList.add(`${mergedClsPrefix}-scrollbar-rail--disabled`);
              } else {
                yRailEl.classList.remove(`${mergedClsPrefix}-scrollbar-rail--disabled`);
              }
            }
          });
          vue.onMounted(() => {
            if (props.container) return;
            sync();
          });
          vue.onBeforeUnmount(() => {
            if (xBarVanishTimerId !== void 0) {
              window.clearTimeout(xBarVanishTimerId);
            }
            if (yBarVanishTimerId !== void 0) {
              window.clearTimeout(yBarVanishTimerId);
            }
            off("mousemove", window, handleYScrollMouseMove, true);
            off("mouseup", window, handleYScrollMouseUp, true);
          });
          const cssVarsRef = vue.computed(() => {
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                color,
                colorHover,
                height,
                width,
                borderRadius,
                railInsetHorizontalTop,
                railInsetHorizontalBottom,
                railInsetVerticalRight,
                railInsetVerticalLeft,
                railColor
              }
            } = themeRef.value;
            const {
              top: railTopHorizontalTop,
              right: railRightHorizontalTop,
              bottom: railBottomHorizontalTop,
              left: railLeftHorizontalTop
            } = getMargin(railInsetHorizontalTop);
            const {
              top: railTopHorizontalBottom,
              right: railRightHorizontalBottom,
              bottom: railBottomHorizontalBottom,
              left: railLeftHorizontalBottom
            } = getMargin(railInsetHorizontalBottom);
            const {
              top: railTopVerticalRight,
              right: railRightVerticalRight,
              bottom: railBottomVerticalRight,
              left: railLeftVerticalRight
            } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalRight) : railInsetVerticalRight);
            const {
              top: railTopVerticalLeft,
              right: railRightVerticalLeft,
              bottom: railBottomVerticalLeft,
              left: railLeftVerticalLeft
            } = getMargin((rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) ? rtlInset(railInsetVerticalLeft) : railInsetVerticalLeft);
            return {
              "--n-scrollbar-bezier": cubicBezierEaseInOut2,
              "--n-scrollbar-color": color,
              "--n-scrollbar-color-hover": colorHover,
              "--n-scrollbar-border-radius": borderRadius,
              "--n-scrollbar-width": width,
              "--n-scrollbar-height": height,
              "--n-scrollbar-rail-top-horizontal-top": railTopHorizontalTop,
              "--n-scrollbar-rail-right-horizontal-top": railRightHorizontalTop,
              "--n-scrollbar-rail-bottom-horizontal-top": railBottomHorizontalTop,
              "--n-scrollbar-rail-left-horizontal-top": railLeftHorizontalTop,
              "--n-scrollbar-rail-top-horizontal-bottom": railTopHorizontalBottom,
              "--n-scrollbar-rail-right-horizontal-bottom": railRightHorizontalBottom,
              "--n-scrollbar-rail-bottom-horizontal-bottom": railBottomHorizontalBottom,
              "--n-scrollbar-rail-left-horizontal-bottom": railLeftHorizontalBottom,
              "--n-scrollbar-rail-top-vertical-right": railTopVerticalRight,
              "--n-scrollbar-rail-right-vertical-right": railRightVerticalRight,
              "--n-scrollbar-rail-bottom-vertical-right": railBottomVerticalRight,
              "--n-scrollbar-rail-left-vertical-right": railLeftVerticalRight,
              "--n-scrollbar-rail-top-vertical-left": railTopVerticalLeft,
              "--n-scrollbar-rail-right-vertical-left": railRightVerticalLeft,
              "--n-scrollbar-rail-bottom-vertical-left": railBottomVerticalLeft,
              "--n-scrollbar-rail-left-vertical-left": railLeftVerticalLeft,
              "--n-scrollbar-rail-color": railColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("scrollbar", void 0, cssVarsRef, props) : void 0;
          const exposedMethods = {
            scrollTo,
            scrollBy,
            sync,
            syncUnifiedContainer,
            handleMouseEnterWrapper,
            handleMouseLeaveWrapper
          };
          return Object.assign(Object.assign({}, exposedMethods), {
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            containerScrollTop: containerScrollTopRef,
            wrapperRef,
            containerRef,
            contentRef,
            yRailRef,
            xRailRef,
            needYBar: needYBarRef,
            needXBar: needXBarRef,
            yBarSizePx: yBarSizePxRef,
            xBarSizePx: xBarSizePxRef,
            yBarTopPx: yBarTopPxRef,
            xBarLeftPx: xBarLeftPxRef,
            isShowXBar: mergedShowXBarRef,
            isShowYBar: mergedShowYBarRef,
            isIos: isIos2,
            handleScroll,
            handleContentResize,
            handleContainerResize,
            handleYScrollMouseDown,
            handleXScrollMouseDown,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a;
          const {
            $slots,
            mergedClsPrefix,
            triggerDisplayManually,
            rtlEnabled,
            internalHoistYRail,
            yPlacement,
            xPlacement,
            xScrollable
          } = this;
          if (!this.scrollable) return (_a = $slots.default) === null || _a === void 0 ? void 0 : _a.call($slots);
          const triggerIsNone = this.trigger === "none";
          const createYRail = (className, style2) => {
            return vue.h("div", {
              ref: "yRailRef",
              class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--vertical`, `${mergedClsPrefix}-scrollbar-rail--vertical--${yPlacement}`, className],
              "data-scrollbar-rail": true,
              style: [style2 || "", this.verticalRailStyle],
              "aria-hidden": true
            }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : {
              name: "fade-in-transition"
            }, {
              default: () => this.needYBar && this.isShowYBar && !this.isIos ? vue.h("div", {
                class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
                style: {
                  height: this.yBarSizePx,
                  top: this.yBarTopPx
                },
                onMousedown: this.handleYScrollMouseDown
              }) : null
            }));
          };
          const createChildren = () => {
            var _a2, _b;
            (_a2 = this.onRender) === null || _a2 === void 0 ? void 0 : _a2.call(this);
            return vue.h("div", vue.mergeProps(this.$attrs, {
              role: "none",
              ref: "wrapperRef",
              class: [`${mergedClsPrefix}-scrollbar`, this.themeClass, rtlEnabled && `${mergedClsPrefix}-scrollbar--rtl`],
              style: this.cssVars,
              onMouseenter: triggerDisplayManually ? void 0 : this.handleMouseEnterWrapper,
              onMouseleave: triggerDisplayManually ? void 0 : this.handleMouseLeaveWrapper
            }), [this.container ? (_b = $slots.default) === null || _b === void 0 ? void 0 : _b.call($slots) : vue.h("div", {
              role: "none",
              ref: "containerRef",
              class: [`${mergedClsPrefix}-scrollbar-container`, this.containerClass],
              style: this.containerStyle,
              onScroll: this.handleScroll,
              onWheel: this.onWheel
            }, vue.h(VResizeObserver, {
              onResize: this.handleContentResize
            }, {
              default: () => vue.h("div", {
                ref: "contentRef",
                role: "none",
                style: [{
                  width: this.xScrollable ? "fit-content" : null
                }, this.contentStyle],
                class: [`${mergedClsPrefix}-scrollbar-content`, this.contentClass]
              }, $slots)
            })), internalHoistYRail ? null : createYRail(void 0, void 0), xScrollable && vue.h("div", {
              ref: "xRailRef",
              class: [`${mergedClsPrefix}-scrollbar-rail`, `${mergedClsPrefix}-scrollbar-rail--horizontal`, `${mergedClsPrefix}-scrollbar-rail--horizontal--${xPlacement}`],
              style: this.horizontalRailStyle,
              "data-scrollbar-rail": true,
              "aria-hidden": true
            }, vue.h(triggerIsNone ? Wrapper : vue.Transition, triggerIsNone ? null : {
              name: "fade-in-transition"
            }, {
              default: () => this.needXBar && this.isShowXBar && !this.isIos ? vue.h("div", {
                class: `${mergedClsPrefix}-scrollbar-rail__scrollbar`,
                style: {
                  width: this.xBarSizePx,
                  right: rtlEnabled ? this.xBarLeftPx : void 0,
                  left: rtlEnabled ? void 0 : this.xBarLeftPx
                },
                onMousedown: this.handleXScrollMouseDown
              }) : null
            }))]);
          };
          const scrollbarNode = this.container ? createChildren() : vue.h(VResizeObserver, {
            onResize: this.handleContainerResize
          }, {
            default: createChildren
          });
          if (internalHoistYRail) {
            return vue.h(vue.Fragment, null, scrollbarNode, createYRail(this.themeClass, this.cssVars));
          } else {
            return scrollbarNode;
          }
        }
      });
      const XScrollbar = Scrollbar;
      function toArray(arg) {
        if (Array.isArray(arg))
          return arg;
        return [arg];
      }
      const TRAVERSE_COMMAND = {
        STOP: "STOP"
      };
      function traverseWithCb(treeNode, callback) {
        const command = callback(treeNode);
        if (treeNode.children !== void 0 && command !== TRAVERSE_COMMAND.STOP) {
          treeNode.children.forEach((childNode) => traverseWithCb(childNode, callback));
        }
      }
      function getNonLeafKeys(treeNodes, options = {}) {
        const { preserveGroup = false } = options;
        const keys2 = [];
        const cb = preserveGroup ? (node) => {
          if (!node.isLeaf) {
            keys2.push(node.key);
            traverse(node.children);
          }
        } : (node) => {
          if (!node.isLeaf) {
            if (!node.isGroup)
              keys2.push(node.key);
            traverse(node.children);
          }
        };
        function traverse(nodes) {
          nodes.forEach(cb);
        }
        traverse(treeNodes);
        return keys2;
      }
      function isLeaf(rawNode, getChildren) {
        const { isLeaf: isLeaf2 } = rawNode;
        if (isLeaf2 !== void 0)
          return isLeaf2;
        else if (!getChildren(rawNode))
          return true;
        return false;
      }
      function defaultGetChildren(node) {
        return node.children;
      }
      function defaultGetKey(node) {
        return node.key;
      }
      function isIgnored() {
        return false;
      }
      function isShallowLoaded(rawNode, getChildren) {
        const { isLeaf: isLeaf2 } = rawNode;
        if (isLeaf2 === false && !Array.isArray(getChildren(rawNode)))
          return false;
        return true;
      }
      function isDisabled(rawNode) {
        return rawNode.disabled === true;
      }
      function isExpilicitlyNotLoaded(rawNode, getChildren) {
        return rawNode.isLeaf === false && !Array.isArray(getChildren(rawNode));
      }
      function unwrapCheckedKeys(result) {
        var _a;
        if (result === void 0 || result === null)
          return [];
        if (Array.isArray(result))
          return result;
        return (_a = result.checkedKeys) !== null && _a !== void 0 ? _a : [];
      }
      function unwrapIndeterminateKeys(result) {
        var _a;
        if (result === void 0 || result === null || Array.isArray(result)) {
          return [];
        }
        return (_a = result.indeterminateKeys) !== null && _a !== void 0 ? _a : [];
      }
      function merge(originalKeys, keysToAdd) {
        const set = new Set(originalKeys);
        keysToAdd.forEach((key) => {
          if (!set.has(key)) {
            set.add(key);
          }
        });
        return Array.from(set);
      }
      function minus(originalKeys, keysToRemove) {
        const set = new Set(originalKeys);
        keysToRemove.forEach((key) => {
          if (set.has(key)) {
            set.delete(key);
          }
        });
        return Array.from(set);
      }
      function isGroup(rawNode) {
        return (rawNode === null || rawNode === void 0 ? void 0 : rawNode.type) === "group";
      }
      function createIndexGetter(treeNodes) {
        const map2 = new Map();
        treeNodes.forEach((treeNode, i) => {
          map2.set(treeNode.key, i);
        });
        return (key) => {
          var _a;
          return (_a = map2.get(key)) !== null && _a !== void 0 ? _a : null;
        };
      }
      class SubtreeNotLoadedError extends Error {
        constructor() {
          super();
          this.message = "SubtreeNotLoadedError: checking a subtree whose required nodes are not fully loaded.";
        }
      }
      function getExtendedCheckedKeySetAfterCheck(checkKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
        return getExtendedCheckedKeySet(currentCheckedKeys.concat(checkKeys), treeMate, allowNotLoaded, false);
      }
      function getAvailableAscendantNodeSet(uncheckedKeys, treeMate) {
        const visitedKeys = new Set();
        uncheckedKeys.forEach((uncheckedKey) => {
          const uncheckedTreeNode = treeMate.treeNodeMap.get(uncheckedKey);
          if (uncheckedTreeNode !== void 0) {
            let nodeCursor = uncheckedTreeNode.parent;
            while (nodeCursor !== null) {
              if (nodeCursor.disabled)
                break;
              if (visitedKeys.has(nodeCursor.key))
                break;
              else {
                visitedKeys.add(nodeCursor.key);
              }
              nodeCursor = nodeCursor.parent;
            }
          }
        });
        return visitedKeys;
      }
      function getExtendedCheckedKeySetAfterUncheck(uncheckedKeys, currentCheckedKeys, treeMate, allowNotLoaded) {
        const extendedCheckedKeySet = getExtendedCheckedKeySet(currentCheckedKeys, treeMate, allowNotLoaded, false);
        const extendedKeySetToUncheck = getExtendedCheckedKeySet(uncheckedKeys, treeMate, allowNotLoaded, true);
        const ascendantKeySet = getAvailableAscendantNodeSet(uncheckedKeys, treeMate);
        const keysToRemove = [];
        extendedCheckedKeySet.forEach((key) => {
          if (extendedKeySetToUncheck.has(key) || ascendantKeySet.has(key)) {
            keysToRemove.push(key);
          }
        });
        keysToRemove.forEach((key) => extendedCheckedKeySet.delete(key));
        return extendedCheckedKeySet;
      }
      function getCheckedKeys(options, treeMate) {
        const { checkedKeys, keysToCheck, keysToUncheck, indeterminateKeys, cascade, leafOnly, checkStrategy, allowNotLoaded } = options;
        if (!cascade) {
          if (keysToCheck !== void 0) {
            return {
              checkedKeys: merge(checkedKeys, keysToCheck),
              indeterminateKeys: Array.from(indeterminateKeys)
            };
          } else if (keysToUncheck !== void 0) {
            return {
              checkedKeys: minus(checkedKeys, keysToUncheck),
              indeterminateKeys: Array.from(indeterminateKeys)
            };
          } else {
            return {
              checkedKeys: Array.from(checkedKeys),
              indeterminateKeys: Array.from(indeterminateKeys)
            };
          }
        }
        const { levelTreeNodeMap } = treeMate;
        let extendedCheckedKeySet;
        if (keysToUncheck !== void 0) {
          extendedCheckedKeySet = getExtendedCheckedKeySetAfterUncheck(keysToUncheck, checkedKeys, treeMate, allowNotLoaded);
        } else if (keysToCheck !== void 0) {
          extendedCheckedKeySet = getExtendedCheckedKeySetAfterCheck(keysToCheck, checkedKeys, treeMate, allowNotLoaded);
        } else {
          extendedCheckedKeySet = getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, false);
        }
        const checkStrategyIsParent = checkStrategy === "parent";
        const checkStrategyIsChild = checkStrategy === "child" || leafOnly;
        const syntheticCheckedKeySet = extendedCheckedKeySet;
        const syntheticIndeterminateKeySet = new Set();
        const maxLevel = Math.max.apply(null, Array.from(levelTreeNodeMap.keys()));
        for (let level = maxLevel; level >= 0; level -= 1) {
          const levelIsZero = level === 0;
          const levelTreeNodes = levelTreeNodeMap.get(level);
          for (const levelTreeNode of levelTreeNodes) {
            if (levelTreeNode.isLeaf)
              continue;
            const { key: levelTreeNodeKey, shallowLoaded } = levelTreeNode;
            if (checkStrategyIsChild && shallowLoaded) {
              levelTreeNode.children.forEach((v) => {
                if (!v.disabled && !v.isLeaf && v.shallowLoaded && syntheticCheckedKeySet.has(v.key)) {
                  syntheticCheckedKeySet.delete(v.key);
                }
              });
            }
            if (levelTreeNode.disabled || !shallowLoaded) {
              continue;
            }
            let fullyChecked = true;
            let partialChecked = false;
            let allDisabled = true;
            for (const childNode of levelTreeNode.children) {
              const childKey = childNode.key;
              if (childNode.disabled)
                continue;
              if (allDisabled)
                allDisabled = false;
              if (syntheticCheckedKeySet.has(childKey)) {
                partialChecked = true;
              } else if (syntheticIndeterminateKeySet.has(childKey)) {
                partialChecked = true;
                fullyChecked = false;
                break;
              } else {
                fullyChecked = false;
                if (partialChecked) {
                  break;
                }
              }
            }
            if (fullyChecked && !allDisabled) {
              if (checkStrategyIsParent) {
                levelTreeNode.children.forEach((v) => {
                  if (!v.disabled && syntheticCheckedKeySet.has(v.key)) {
                    syntheticCheckedKeySet.delete(v.key);
                  }
                });
              }
              syntheticCheckedKeySet.add(levelTreeNodeKey);
            } else if (partialChecked) {
              syntheticIndeterminateKeySet.add(levelTreeNodeKey);
            }
            if (levelIsZero && checkStrategyIsChild && syntheticCheckedKeySet.has(levelTreeNodeKey)) {
              syntheticCheckedKeySet.delete(levelTreeNodeKey);
            }
          }
        }
        return {
          checkedKeys: Array.from(syntheticCheckedKeySet),
          indeterminateKeys: Array.from(syntheticIndeterminateKeySet)
        };
      }
      function getExtendedCheckedKeySet(checkedKeys, treeMate, allowNotLoaded, isUnchecking) {
        const { treeNodeMap, getChildren } = treeMate;
        const visitedKeySet = new Set();
        const extendedKeySet = new Set(checkedKeys);
        checkedKeys.forEach((checkedKey) => {
          const checkedTreeNode = treeNodeMap.get(checkedKey);
          if (checkedTreeNode !== void 0) {
            traverseWithCb(checkedTreeNode, (treeNode) => {
              if (treeNode.disabled) {
                return TRAVERSE_COMMAND.STOP;
              }
              const { key } = treeNode;
              if (visitedKeySet.has(key))
                return;
              visitedKeySet.add(key);
              extendedKeySet.add(key);
              if (isExpilicitlyNotLoaded(treeNode.rawNode, getChildren)) {
                if (isUnchecking) {
                  return TRAVERSE_COMMAND.STOP;
                } else if (!allowNotLoaded) {
                  throw new SubtreeNotLoadedError();
                }
              }
            });
          }
        });
        return extendedKeySet;
      }
      function getPath(key, { includeGroup = false, includeSelf = true }, treeMate) {
        var _a;
        const treeNodeMap = treeMate.treeNodeMap;
        let treeNode = key === null || key === void 0 ? null : (_a = treeNodeMap.get(key)) !== null && _a !== void 0 ? _a : null;
        const mergedPath = {
          keyPath: [],
          treeNodePath: [],
          treeNode
        };
        if (treeNode === null || treeNode === void 0 ? void 0 : treeNode.ignored) {
          mergedPath.treeNode = null;
          return mergedPath;
        }
        while (treeNode) {
          if (!treeNode.ignored && (includeGroup || !treeNode.isGroup)) {
            mergedPath.treeNodePath.push(treeNode);
          }
          treeNode = treeNode.parent;
        }
        mergedPath.treeNodePath.reverse();
        if (!includeSelf)
          mergedPath.treeNodePath.pop();
        mergedPath.keyPath = mergedPath.treeNodePath.map((treeNode2) => treeNode2.key);
        return mergedPath;
      }
      function getFirstAvailableNode(nodes) {
        if (nodes.length === 0)
          return null;
        const node = nodes[0];
        if (node.isGroup || node.ignored || node.disabled) {
          return node.getNext();
        }
        return node;
      }
      function rawGetNext(node, loop) {
        const sibs = node.siblings;
        const l = sibs.length;
        const { index } = node;
        if (loop) {
          return sibs[(index + 1) % l];
        } else {
          if (index === sibs.length - 1)
            return null;
          return sibs[index + 1];
        }
      }
      function move(fromNode, dir, { loop = false, includeDisabled = false } = {}) {
        const iterate = dir === "prev" ? rawGetPrev : rawGetNext;
        const getChildOptions = {
          reverse: dir === "prev"
        };
        let meet = false;
        let endNode = null;
        function traverse(node) {
          if (node === null)
            return;
          if (node === fromNode) {
            if (!meet) {
              meet = true;
            } else if (!fromNode.disabled && !fromNode.isGroup) {
              endNode = fromNode;
              return;
            }
          } else {
            if ((!node.disabled || includeDisabled) && !node.ignored && !node.isGroup) {
              endNode = node;
              return;
            }
          }
          if (node.isGroup) {
            const child = getChild(node, getChildOptions);
            if (child !== null) {
              endNode = child;
            } else {
              traverse(iterate(node, loop));
            }
          } else {
            const nextNode = iterate(node, false);
            if (nextNode !== null) {
              traverse(nextNode);
            } else {
              const parent = rawGetParent(node);
              if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
                traverse(iterate(parent, loop));
              } else if (loop) {
                traverse(iterate(node, true));
              }
            }
          }
        }
        traverse(fromNode);
        return endNode;
      }
      function rawGetPrev(node, loop) {
        const sibs = node.siblings;
        const l = sibs.length;
        const { index } = node;
        if (loop) {
          return sibs[(index - 1 + l) % l];
        } else {
          if (index === 0)
            return null;
          return sibs[index - 1];
        }
      }
      function rawGetParent(node) {
        return node.parent;
      }
      function getChild(node, options = {}) {
        const { reverse = false } = options;
        const { children } = node;
        if (children) {
          const { length } = children;
          const start = reverse ? length - 1 : 0;
          const end = reverse ? -1 : length;
          const delta = reverse ? -1 : 1;
          for (let i = start; i !== end; i += delta) {
            const child = children[i];
            if (!child.disabled && !child.ignored) {
              if (child.isGroup) {
                const childInGroup = getChild(child, options);
                if (childInGroup !== null)
                  return childInGroup;
              } else {
                return child;
              }
            }
          }
        }
        return null;
      }
      const moveMethods = {
        getChild() {
          if (this.ignored)
            return null;
          return getChild(this);
        },
        getParent() {
          const { parent } = this;
          if (parent === null || parent === void 0 ? void 0 : parent.isGroup) {
            return parent.getParent();
          }
          return parent;
        },
        getNext(options = {}) {
          return move(this, "next", options);
        },
        getPrev(options = {}) {
          return move(this, "prev", options);
        }
      };
      function flatten$1(treeNodes, expandedKeys) {
        const expandedKeySet = expandedKeys ? new Set(expandedKeys) : void 0;
        const flattenedNodes = [];
        function traverse(treeNodes2) {
          treeNodes2.forEach((treeNode) => {
            flattenedNodes.push(treeNode);
            if (treeNode.isLeaf || !treeNode.children || treeNode.ignored)
              return;
            if (treeNode.isGroup) {
              traverse(treeNode.children);
            } else if (
expandedKeySet === void 0 || expandedKeySet.has(treeNode.key)
            ) {
              traverse(treeNode.children);
            }
          });
        }
        traverse(treeNodes);
        return flattenedNodes;
      }
      function contains(parent, child) {
        const parentKey = parent.key;
        while (child) {
          if (child.key === parentKey)
            return true;
          child = child.parent;
        }
        return false;
      }
      function createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, parent = null, level = 0) {
        const treeNodes = [];
        rawNodes.forEach((rawNode, index) => {
          var _a;
          const treeNode = Object.create(nodeProto);
          treeNode.rawNode = rawNode;
          treeNode.siblings = treeNodes;
          treeNode.level = level;
          treeNode.index = index;
          treeNode.isFirstChild = index === 0;
          treeNode.isLastChild = index + 1 === rawNodes.length;
          treeNode.parent = parent;
          if (!treeNode.ignored) {
            const rawChildren = getChildren(rawNode);
            if (Array.isArray(rawChildren)) {
              treeNode.children = createTreeNodes(rawChildren, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren, treeNode, level + 1);
            }
          }
          treeNodes.push(treeNode);
          treeNodeMap.set(treeNode.key, treeNode);
          if (!levelTreeNodeMap.has(level))
            levelTreeNodeMap.set(level, []);
          (_a = levelTreeNodeMap.get(level)) === null || _a === void 0 ? void 0 : _a.push(treeNode);
        });
        return treeNodes;
      }
      function createTreeMate(rawNodes, options = {}) {
        var _a;
        const treeNodeMap = new Map();
        const levelTreeNodeMap = new Map();
        const { getDisabled = isDisabled, getIgnored: getIgnored2 = isIgnored, getIsGroup: getIsGroup2 = isGroup, getKey = defaultGetKey } = options;
        const _getChildren = (_a = options.getChildren) !== null && _a !== void 0 ? _a : defaultGetChildren;
        const getChildren = options.ignoreEmptyChildren ? (node) => {
          const children = _getChildren(node);
          if (Array.isArray(children)) {
            if (!children.length)
              return null;
            return children;
          }
          return children;
        } : _getChildren;
        const nodeProto = Object.assign({
          get key() {
            return getKey(this.rawNode);
          },
          get disabled() {
            return getDisabled(this.rawNode);
          },
          get isGroup() {
            return getIsGroup2(this.rawNode);
          },
          get isLeaf() {
            return isLeaf(this.rawNode, getChildren);
          },
          get shallowLoaded() {
            return isShallowLoaded(this.rawNode, getChildren);
          },
          get ignored() {
            return getIgnored2(this.rawNode);
          },
          contains(node) {
            return contains(this, node);
          }
        }, moveMethods);
        const treeNodes = createTreeNodes(rawNodes, treeNodeMap, levelTreeNodeMap, nodeProto, getChildren);
        function getNode(key) {
          if (key === null || key === void 0)
            return null;
          const tmNode = treeNodeMap.get(key);
          if (tmNode && !tmNode.isGroup && !tmNode.ignored) {
            return tmNode;
          }
          return null;
        }
        function _getNode(key) {
          if (key === null || key === void 0)
            return null;
          const tmNode = treeNodeMap.get(key);
          if (tmNode && !tmNode.ignored) {
            return tmNode;
          }
          return null;
        }
        function getPrev(key, options2) {
          const node = _getNode(key);
          if (!node)
            return null;
          return node.getPrev(options2);
        }
        function getNext(key, options2) {
          const node = _getNode(key);
          if (!node)
            return null;
          return node.getNext(options2);
        }
        function getParent(key) {
          const node = _getNode(key);
          if (!node)
            return null;
          return node.getParent();
        }
        function getChild2(key) {
          const node = _getNode(key);
          if (!node)
            return null;
          return node.getChild();
        }
        const treemate = {
          treeNodes,
          treeNodeMap,
          levelTreeNodeMap,
          maxLevel: Math.max(...levelTreeNodeMap.keys()),
          getChildren,
          getFlattenedNodes(expandedKeys) {
            return flatten$1(treeNodes, expandedKeys);
          },
          getNode,
          getPrev,
          getNext,
          getParent,
          getChild: getChild2,
          getFirstAvailableNode() {
            return getFirstAvailableNode(treeNodes);
          },
          getPath(key, options2 = {}) {
            return getPath(key, options2, treemate);
          },
          getCheckedKeys(checkedKeys, options2 = {}) {
            const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
            return getCheckedKeys({
              checkedKeys: unwrapCheckedKeys(checkedKeys),
              indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
              cascade,
              leafOnly,
              checkStrategy,
              allowNotLoaded
            }, treemate);
          },
          check(keysToCheck, checkedKeys, options2 = {}) {
            const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
            return getCheckedKeys({
              checkedKeys: unwrapCheckedKeys(checkedKeys),
              indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
              keysToCheck: keysToCheck === void 0 || keysToCheck === null ? [] : toArray(keysToCheck),
              cascade,
              leafOnly,
              checkStrategy,
              allowNotLoaded
            }, treemate);
          },
          uncheck(keysToUncheck, checkedKeys, options2 = {}) {
            const { cascade = true, leafOnly = false, checkStrategy = "all", allowNotLoaded = false } = options2;
            return getCheckedKeys({
              checkedKeys: unwrapCheckedKeys(checkedKeys),
              indeterminateKeys: unwrapIndeterminateKeys(checkedKeys),
              keysToUncheck: keysToUncheck === null || keysToUncheck === void 0 ? [] : toArray(keysToUncheck),
              cascade,
              leafOnly,
              checkStrategy,
              allowNotLoaded
            }, treemate);
          },
          getNonLeafKeys(options2 = {}) {
            return getNonLeafKeys(treeNodes, options2);
          }
        };
        return treemate;
      }
      const commonVars$7 = {
        iconSizeTiny: "28px",
        iconSizeSmall: "34px",
        iconSizeMedium: "40px",
        iconSizeLarge: "46px",
        iconSizeHuge: "52px"
      };
      function self$s(vars) {
        const {
          textColorDisabled,
          iconColor,
          textColor2,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          fontSizeHuge
        } = vars;
        return Object.assign(Object.assign({}, commonVars$7), {
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          fontSizeHuge,
          textColor: textColorDisabled,
          iconColor,
          extraTextColor: textColor2
        });
      }
      const emptyLight = {
        name: "Empty",
        common: derived,
        self: self$s
      };
      const style$s = cB("empty", `
 display: flex;
 flex-direction: column;
 align-items: center;
 font-size: var(--n-font-size);
`, [cE("icon", `
 width: var(--n-icon-size);
 height: var(--n-icon-size);
 font-size: var(--n-icon-size);
 line-height: var(--n-icon-size);
 color: var(--n-icon-color);
 transition:
 color .3s var(--n-bezier);
 `, [c$1("+", [cE("description", `
 margin-top: 8px;
 `)])]), cE("description", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("extra", `
 text-align: center;
 transition: color .3s var(--n-bezier);
 margin-top: 12px;
 color: var(--n-extra-text-color);
 `)]);
      const emptyProps = Object.assign(Object.assign({}, useTheme.props), {
        description: String,
        showDescription: {
          type: Boolean,
          default: true
        },
        showIcon: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          default: "medium"
        },
        renderIcon: Function
      });
      const NEmpty = vue.defineComponent({
        name: "Empty",
        props: emptyProps,
        slots: Object,
        setup(props) {
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled,
            mergedComponentPropsRef
          } = useConfig(props);
          const themeRef = useTheme("Empty", "-empty", style$s, emptyLight, props, mergedClsPrefixRef);
          const {
            localeRef
          } = useLocale("Empty");
          const mergedDescriptionRef = vue.computed(() => {
            var _a, _b, _c;
            return (_a = props.description) !== null && _a !== void 0 ? _a : (_c = (_b = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _b === void 0 ? void 0 : _b.Empty) === null || _c === void 0 ? void 0 : _c.description;
          });
          const mergedRenderIconRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Empty) === null || _b === void 0 ? void 0 : _b.renderIcon) || (() => vue.h(EmptyIcon, null));
          });
          const cssVarsRef = vue.computed(() => {
            const {
              size: size2
            } = props;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                [createKey("iconSize", size2)]: iconSize,
                [createKey("fontSize", size2)]: fontSize2,
                textColor,
                iconColor,
                extraTextColor
              }
            } = themeRef.value;
            return {
              "--n-icon-size": iconSize,
              "--n-font-size": fontSize2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-text-color": textColor,
              "--n-icon-color": iconColor,
              "--n-extra-text-color": extraTextColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("empty", vue.computed(() => {
            let hash = "";
            const {
              size: size2
            } = props;
            hash += size2[0];
            return hash;
          }), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedRenderIcon: mergedRenderIconRef,
            localizedDescription: vue.computed(() => {
              return mergedDescriptionRef.value || localeRef.value.description;
            }),
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const {
            $slots,
            mergedClsPrefix,
            onRender
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("div", {
            class: [`${mergedClsPrefix}-empty`, this.themeClass],
            style: this.cssVars
          }, this.showIcon ? vue.h("div", {
            class: `${mergedClsPrefix}-empty__icon`
          }, $slots.icon ? $slots.icon() : vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: this.mergedRenderIcon
          })) : null, this.showDescription ? vue.h("div", {
            class: `${mergedClsPrefix}-empty__description`
          }, $slots.default ? $slots.default() : this.localizedDescription) : null, $slots.extra ? vue.h("div", {
            class: `${mergedClsPrefix}-empty__extra`
          }, $slots.extra()) : null);
        }
      });
      const commonVariables$d = {
        height: "calc(var(--n-option-height) * 7.6)",
        paddingTiny: "4px 0",
        paddingSmall: "4px 0",
        paddingMedium: "4px 0",
        paddingLarge: "4px 0",
        paddingHuge: "4px 0",
        optionPaddingTiny: "0 12px",
        optionPaddingSmall: "0 12px",
        optionPaddingMedium: "0 12px",
        optionPaddingLarge: "0 12px",
        optionPaddingHuge: "0 12px",
        loadingSize: "18px"
      };
      function self$r(vars) {
        const {
          borderRadius,
          popoverColor,
          textColor3,
          dividerColor,
          textColor2,
          primaryColorPressed,
          textColorDisabled,
          primaryColor,
          opacityDisabled,
          hoverColor,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          fontSizeHuge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          heightHuge
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$d), {
          optionFontSizeTiny: fontSizeTiny,
          optionFontSizeSmall: fontSizeSmall,
          optionFontSizeMedium: fontSizeMedium,
          optionFontSizeLarge: fontSizeLarge,
          optionFontSizeHuge: fontSizeHuge,
          optionHeightTiny: heightTiny,
          optionHeightSmall: heightSmall,
          optionHeightMedium: heightMedium,
          optionHeightLarge: heightLarge,
          optionHeightHuge: heightHuge,
          borderRadius,
          color: popoverColor,
          groupHeaderTextColor: textColor3,
          actionDividerColor: dividerColor,
          optionTextColor: textColor2,
          optionTextColorPressed: primaryColorPressed,
          optionTextColorDisabled: textColorDisabled,
          optionTextColorActive: primaryColor,
          optionOpacityDisabled: opacityDisabled,
          optionCheckColor: primaryColor,
          optionColorPending: hoverColor,
          optionColorActive: "rgba(0, 0, 0, 0)",
          optionColorActivePending: hoverColor,
          actionTextColor: textColor2,
          loadingColor: primaryColor
        });
      }
      const internalSelectMenuLight = createTheme({
        name: "InternalSelectMenu",
        common: derived,
        peers: {
          Scrollbar: scrollbarLight,
          Empty: emptyLight
        },
        self: self$r
      });
      const NSelectGroupHeader = vue.defineComponent({
        name: "NBaseSelectGroupHeader",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          }
        },
        setup() {
          const {
            renderLabelRef,
            renderOptionRef,
            labelFieldRef,
            nodePropsRef
          } = vue.inject(internalSelectionMenuInjectionKey);
          return {
            labelField: labelFieldRef,
            nodeProps: nodePropsRef,
            renderLabel: renderLabelRef,
            renderOption: renderOptionRef
          };
        },
        render() {
          const {
            clsPrefix,
            renderLabel,
            renderOption,
            nodeProps,
            tmNode: {
              rawNode
            }
          } = this;
          const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
          const children = renderLabel ? renderLabel(rawNode, false) : render(rawNode[this.labelField], rawNode, false);
          const node = vue.h("div", Object.assign({}, attrs, {
            class: [`${clsPrefix}-base-select-group-header`, attrs === null || attrs === void 0 ? void 0 : attrs.class]
          }), children);
          return rawNode.render ? rawNode.render({
            node,
            option: rawNode
          }) : renderOption ? renderOption({
            node,
            option: rawNode,
            selected: false
          }) : node;
        }
      });
      function renderCheckMark$1(show, clsPrefix) {
        return vue.h(vue.Transition, {
          name: "fade-in-scale-up-transition"
        }, {
          default: () => show ? vue.h(NBaseIcon, {
            clsPrefix,
            class: `${clsPrefix}-base-select-option__check`
          }, {
            default: () => vue.h(FinishedIcon)
          }) : null
        });
      }
      const NSelectOption = vue.defineComponent({
        name: "NBaseSelectOption",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          }
        },
        setup(props) {
          const {
            valueRef,
            pendingTmNodeRef,
            multipleRef,
            valueSetRef,
            renderLabelRef,
            renderOptionRef,
            labelFieldRef,
            valueFieldRef,
            showCheckmarkRef,
            nodePropsRef,
            handleOptionClick,
            handleOptionMouseEnter
          } = vue.inject(internalSelectionMenuInjectionKey);
          const isPendingRef = useMemo(() => {
            const {
              value: pendingTmNode
            } = pendingTmNodeRef;
            if (!pendingTmNode) return false;
            return props.tmNode.key === pendingTmNode.key;
          });
          function handleClick2(e) {
            const {
              tmNode
            } = props;
            if (tmNode.disabled) return;
            handleOptionClick(e, tmNode);
          }
          function handleMouseEnter(e) {
            const {
              tmNode
            } = props;
            if (tmNode.disabled) return;
            handleOptionMouseEnter(e, tmNode);
          }
          function handleMouseMove(e) {
            const {
              tmNode
            } = props;
            const {
              value: isPending
            } = isPendingRef;
            if (tmNode.disabled || isPending) return;
            handleOptionMouseEnter(e, tmNode);
          }
          return {
            multiple: multipleRef,
            isGrouped: useMemo(() => {
              const {
                tmNode
              } = props;
              const {
                parent
              } = tmNode;
              return parent && parent.rawNode.type === "group";
            }),
            showCheckmark: showCheckmarkRef,
            nodeProps: nodePropsRef,
            isPending: isPendingRef,
            isSelected: useMemo(() => {
              const {
                value
              } = valueRef;
              const {
                value: multiple
              } = multipleRef;
              if (value === null) return false;
              const optionValue = props.tmNode.rawNode[valueFieldRef.value];
              if (multiple) {
                const {
                  value: valueSet
                } = valueSetRef;
                return valueSet.has(optionValue);
              } else {
                return value === optionValue;
              }
            }),
            labelField: labelFieldRef,
            renderLabel: renderLabelRef,
            renderOption: renderOptionRef,
            handleMouseMove,
            handleMouseEnter,
            handleClick: handleClick2
          };
        },
        render() {
          const {
            clsPrefix,
            tmNode: {
              rawNode
            },
            isSelected,
            isPending,
            isGrouped,
            showCheckmark,
            nodeProps,
            renderOption,
            renderLabel,
            handleClick: handleClick2,
            handleMouseEnter,
            handleMouseMove
          } = this;
          const checkmark = renderCheckMark$1(isSelected, clsPrefix);
          const children = renderLabel ? [renderLabel(rawNode, isSelected), showCheckmark && checkmark] : [render(rawNode[this.labelField], rawNode, isSelected), showCheckmark && checkmark];
          const attrs = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
          const node = vue.h("div", Object.assign({}, attrs, {
            class: [`${clsPrefix}-base-select-option`, rawNode.class, attrs === null || attrs === void 0 ? void 0 : attrs.class, {
              [`${clsPrefix}-base-select-option--disabled`]: rawNode.disabled,
              [`${clsPrefix}-base-select-option--selected`]: isSelected,
              [`${clsPrefix}-base-select-option--grouped`]: isGrouped,
              [`${clsPrefix}-base-select-option--pending`]: isPending,
              [`${clsPrefix}-base-select-option--show-checkmark`]: showCheckmark
            }],
            style: [(attrs === null || attrs === void 0 ? void 0 : attrs.style) || "", rawNode.style || ""],
            onClick: mergeEventHandlers([handleClick2, attrs === null || attrs === void 0 ? void 0 : attrs.onClick]),
            onMouseenter: mergeEventHandlers([handleMouseEnter, attrs === null || attrs === void 0 ? void 0 : attrs.onMouseenter]),
            onMousemove: mergeEventHandlers([handleMouseMove, attrs === null || attrs === void 0 ? void 0 : attrs.onMousemove])
          }), vue.h("div", {
            class: `${clsPrefix}-base-select-option__content`
          }, children));
          return rawNode.render ? rawNode.render({
            node,
            option: rawNode,
            selected: isSelected
          }) : renderOption ? renderOption({
            node,
            option: rawNode,
            selected: isSelected
          }) : node;
        }
      });
      const {
        cubicBezierEaseIn: cubicBezierEaseIn$1,
        cubicBezierEaseOut: cubicBezierEaseOut$1
      } = commonVariables$e;
      function fadeInScaleUpTransition({
        transformOrigin = "inherit",
        duration: duration2 = ".2s",
        enterScale = ".9",
        originalTransform = "",
        originalTransition = ""
      } = {}) {
        return [c$1("&.fade-in-scale-up-transition-leave-active", {
          transformOrigin,
          transition: `opacity ${duration2} ${cubicBezierEaseIn$1}, transform ${duration2} ${cubicBezierEaseIn$1} ${originalTransition && `,${originalTransition}`}`
        }), c$1("&.fade-in-scale-up-transition-enter-active", {
          transformOrigin,
          transition: `opacity ${duration2} ${cubicBezierEaseOut$1}, transform ${duration2} ${cubicBezierEaseOut$1} ${originalTransition && `,${originalTransition}`}`
        }), c$1("&.fade-in-scale-up-transition-enter-from, &.fade-in-scale-up-transition-leave-to", {
          opacity: 0,
          transform: `${originalTransform} scale(${enterScale})`
        }), c$1("&.fade-in-scale-up-transition-leave-from, &.fade-in-scale-up-transition-enter-to", {
          opacity: 1,
          transform: `${originalTransform} scale(1)`
        })];
      }
      const style$r = cB("base-select-menu", `
 line-height: 1.5;
 outline: none;
 z-index: 0;
 position: relative;
 border-radius: var(--n-border-radius);
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-color);
`, [cB("scrollbar", `
 max-height: var(--n-height);
 `), cB("virtual-list", `
 max-height: var(--n-height);
 `), cB("base-select-option", `
 min-height: var(--n-option-height);
 font-size: var(--n-option-font-size);
 display: flex;
 align-items: center;
 `, [cE("content", `
 z-index: 1;
 white-space: nowrap;
 text-overflow: ellipsis;
 overflow: hidden;
 `)]), cB("base-select-group-header", `
 min-height: var(--n-option-height);
 font-size: .93em;
 display: flex;
 align-items: center;
 `), cB("base-select-menu-option-wrapper", `
 position: relative;
 width: 100%;
 `), cE("loading, empty", `
 display: flex;
 padding: 12px 32px;
 flex: 1;
 justify-content: center;
 `), cE("loading", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 `), cE("header", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-bottom: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), cE("action", `
 padding: 8px var(--n-option-padding-left);
 font-size: var(--n-option-font-size);
 transition: 
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 border-top: 1px solid var(--n-action-divider-color);
 color: var(--n-action-text-color);
 `), cB("base-select-group-header", `
 position: relative;
 cursor: default;
 padding: var(--n-option-padding);
 color: var(--n-group-header-text-color);
 `), cB("base-select-option", `
 cursor: pointer;
 position: relative;
 padding: var(--n-option-padding);
 transition:
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 box-sizing: border-box;
 color: var(--n-option-text-color);
 opacity: 1;
 `, [cM("show-checkmark", `
 padding-right: calc(var(--n-option-padding-right) + 20px);
 `), c$1("&::before", `
 content: "";
 position: absolute;
 left: 4px;
 right: 4px;
 top: 0;
 bottom: 0;
 border-radius: var(--n-border-radius);
 transition: background-color .3s var(--n-bezier);
 `), c$1("&:active", `
 color: var(--n-option-text-color-pressed);
 `), cM("grouped", `
 padding-left: calc(var(--n-option-padding-left) * 1.5);
 `), cM("pending", [c$1("&::before", `
 background-color: var(--n-option-color-pending);
 `)]), cM("selected", `
 color: var(--n-option-text-color-active);
 `, [c$1("&::before", `
 background-color: var(--n-option-color-active);
 `), cM("pending", [c$1("&::before", `
 background-color: var(--n-option-color-active-pending);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `, [cNotM("selected", `
 color: var(--n-option-text-color-disabled);
 `), cM("selected", `
 opacity: var(--n-option-opacity-disabled);
 `)]), cE("check", `
 font-size: 16px;
 position: absolute;
 right: calc(var(--n-option-padding-right) - 4px);
 top: calc(50% - 7px);
 color: var(--n-option-check-color);
 transition: color .3s var(--n-bezier);
 `, [fadeInScaleUpTransition({
        enterScale: "0.5"
      })])])]);
      const NInternalSelectMenu = vue.defineComponent({
        name: "InternalSelectMenu",
        props: Object.assign(Object.assign({}, useTheme.props), {
          clsPrefix: {
            type: String,
            required: true
          },
          scrollable: {
            type: Boolean,
            default: true
          },
          treeMate: {
            type: Object,
            required: true
          },
          multiple: Boolean,
          size: {
            type: String,
            default: "medium"
          },
          value: {
            type: [String, Number, Array],
            default: null
          },
          autoPending: Boolean,
          virtualScroll: {
            type: Boolean,
            default: true
          },
show: {
            type: Boolean,
            default: true
          },
          labelField: {
            type: String,
            default: "label"
          },
          valueField: {
            type: String,
            default: "value"
          },
          loading: Boolean,
          focusable: Boolean,
          renderLabel: Function,
          renderOption: Function,
          nodeProps: Function,
          showCheckmark: {
            type: Boolean,
            default: true
          },
          onMousedown: Function,
          onScroll: Function,
          onFocus: Function,
          onBlur: Function,
          onKeyup: Function,
          onKeydown: Function,
          onTabOut: Function,
          onMouseenter: Function,
          onMouseleave: Function,
          onResize: Function,
          resetMenuOnOptionsChange: {
            type: Boolean,
            default: true
          },
          inlineThemeDisabled: Boolean,
onToggle: Function
        }),
        setup(props) {
          const {
            mergedClsPrefixRef,
            mergedRtlRef
          } = useConfig(props);
          const rtlEnabledRef = useRtl("InternalSelectMenu", mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme("InternalSelectMenu", "-internal-select-menu", style$r, internalSelectMenuLight, props, vue.toRef(props, "clsPrefix"));
          const selfRef = vue.ref(null);
          const virtualListRef = vue.ref(null);
          const scrollbarRef = vue.ref(null);
          const flattenedNodesRef = vue.computed(() => props.treeMate.getFlattenedNodes());
          const fIndexGetterRef = vue.computed(() => createIndexGetter(flattenedNodesRef.value));
          const pendingNodeRef = vue.ref(null);
          function initPendingNode() {
            const {
              treeMate
            } = props;
            let defaultPendingNode = null;
            const {
              value
            } = props;
            if (value === null) {
              defaultPendingNode = treeMate.getFirstAvailableNode();
            } else {
              if (props.multiple) {
                defaultPendingNode = treeMate.getNode((value || [])[(value || []).length - 1]);
              } else {
                defaultPendingNode = treeMate.getNode(value);
              }
              if (!defaultPendingNode || defaultPendingNode.disabled) {
                defaultPendingNode = treeMate.getFirstAvailableNode();
              }
            }
            if (defaultPendingNode) {
              setPendingTmNode(defaultPendingNode);
            } else {
              setPendingTmNode(null);
            }
          }
          function clearPendingNodeIfInvalid() {
            const {
              value: pendingNode
            } = pendingNodeRef;
            if (pendingNode && !props.treeMate.getNode(pendingNode.key)) {
              pendingNodeRef.value = null;
            }
          }
          let initPendingNodeWatchStopHandle;
          vue.watch(() => props.show, (show) => {
            if (show) {
              initPendingNodeWatchStopHandle = vue.watch(() => props.treeMate, () => {
                if (props.resetMenuOnOptionsChange) {
                  if (props.autoPending) {
                    initPendingNode();
                  } else {
                    clearPendingNodeIfInvalid();
                  }
                  void vue.nextTick(scrollToPendingNode);
                } else {
                  clearPendingNodeIfInvalid();
                }
              }, {
                immediate: true
              });
            } else {
              initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
            }
          }, {
            immediate: true
          });
          vue.onBeforeUnmount(() => {
            initPendingNodeWatchStopHandle === null || initPendingNodeWatchStopHandle === void 0 ? void 0 : initPendingNodeWatchStopHandle();
          });
          const itemSizeRef = vue.computed(() => {
            return depx(themeRef.value.self[createKey("optionHeight", props.size)]);
          });
          const paddingRef = vue.computed(() => {
            return getMargin(themeRef.value.self[createKey("padding", props.size)]);
          });
          const valueSetRef = vue.computed(() => {
            if (props.multiple && Array.isArray(props.value)) {
              return new Set(props.value);
            }
            return new Set();
          });
          const emptyRef = vue.computed(() => {
            const tmNodes = flattenedNodesRef.value;
            return tmNodes && tmNodes.length === 0;
          });
          function doToggle(tmNode) {
            const {
              onToggle
            } = props;
            if (onToggle) onToggle(tmNode);
          }
          function doScroll(e) {
            const {
              onScroll
            } = props;
            if (onScroll) onScroll(e);
          }
          function handleVirtualListScroll(e) {
            var _a;
            (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
            doScroll(e);
          }
          function handleVirtualListResize() {
            var _a;
            (_a = scrollbarRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function getPendingTmNode() {
            const {
              value: pendingTmNode
            } = pendingNodeRef;
            if (pendingTmNode) return pendingTmNode;
            return null;
          }
          function handleOptionMouseEnter(e, tmNode) {
            if (tmNode.disabled) return;
            setPendingTmNode(tmNode, false);
          }
          function handleOptionClick(e, tmNode) {
            if (tmNode.disabled) return;
            doToggle(tmNode);
          }
          function handleKeyUp(e) {
            var _a;
            if (happensIn(e, "action")) return;
            (_a = props.onKeyup) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleKeyDown(e) {
            var _a;
            if (happensIn(e, "action")) return;
            (_a = props.onKeydown) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleMouseDown(e) {
            var _a;
            (_a = props.onMousedown) === null || _a === void 0 ? void 0 : _a.call(props, e);
            if (props.focusable) return;
            e.preventDefault();
          }
          function next() {
            const {
              value: pendingTmNode
            } = pendingNodeRef;
            if (pendingTmNode) {
              setPendingTmNode(pendingTmNode.getNext({
                loop: true
              }), true);
            }
          }
          function prev() {
            const {
              value: pendingTmNode
            } = pendingNodeRef;
            if (pendingTmNode) {
              setPendingTmNode(pendingTmNode.getPrev({
                loop: true
              }), true);
            }
          }
          function setPendingTmNode(tmNode, doScroll2 = false) {
            pendingNodeRef.value = tmNode;
            if (doScroll2) scrollToPendingNode();
          }
          function scrollToPendingNode() {
            var _a, _b;
            const tmNode = pendingNodeRef.value;
            if (!tmNode) return;
            const fIndex = fIndexGetterRef.value(tmNode.key);
            if (fIndex === null) return;
            if (props.virtualScroll) {
              (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo({
                index: fIndex
              });
            } else {
              (_b = scrollbarRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo({
                index: fIndex,
                elSize: itemSizeRef.value
              });
            }
          }
          function handleFocusin(e) {
            var _a, _b;
            if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.target)) {
              (_b = props.onFocus) === null || _b === void 0 ? void 0 : _b.call(props, e);
            }
          }
          function handleFocusout(e) {
            var _a, _b;
            if (!((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
              (_b = props.onBlur) === null || _b === void 0 ? void 0 : _b.call(props, e);
            }
          }
          vue.provide(internalSelectionMenuInjectionKey, {
            handleOptionMouseEnter,
            handleOptionClick,
            valueSetRef,
            pendingTmNodeRef: pendingNodeRef,
            nodePropsRef: vue.toRef(props, "nodeProps"),
            showCheckmarkRef: vue.toRef(props, "showCheckmark"),
            multipleRef: vue.toRef(props, "multiple"),
            valueRef: vue.toRef(props, "value"),
            renderLabelRef: vue.toRef(props, "renderLabel"),
            renderOptionRef: vue.toRef(props, "renderOption"),
            labelFieldRef: vue.toRef(props, "labelField"),
            valueFieldRef: vue.toRef(props, "valueField")
          });
          vue.provide(internalSelectionMenuBodyInjectionKey, selfRef);
          vue.onMounted(() => {
            const {
              value
            } = scrollbarRef;
            if (value) value.sync();
          });
          const cssVarsRef = vue.computed(() => {
            const {
              size: size2
            } = props;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                height,
                borderRadius,
                color,
                groupHeaderTextColor,
                actionDividerColor,
                optionTextColorPressed,
                optionTextColor,
                optionTextColorDisabled,
                optionTextColorActive,
                optionOpacityDisabled,
                optionCheckColor,
                actionTextColor,
                optionColorPending,
                optionColorActive,
                loadingColor,
                loadingSize,
                optionColorActivePending,
                [createKey("optionFontSize", size2)]: fontSize2,
                [createKey("optionHeight", size2)]: optionHeight,
                [createKey("optionPadding", size2)]: optionPadding
              }
            } = themeRef.value;
            return {
              "--n-height": height,
              "--n-action-divider-color": actionDividerColor,
              "--n-action-text-color": actionTextColor,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-color": color,
              "--n-option-font-size": fontSize2,
              "--n-group-header-text-color": groupHeaderTextColor,
              "--n-option-check-color": optionCheckColor,
              "--n-option-color-pending": optionColorPending,
              "--n-option-color-active": optionColorActive,
              "--n-option-color-active-pending": optionColorActivePending,
              "--n-option-height": optionHeight,
              "--n-option-opacity-disabled": optionOpacityDisabled,
              "--n-option-text-color": optionTextColor,
              "--n-option-text-color-active": optionTextColorActive,
              "--n-option-text-color-disabled": optionTextColorDisabled,
              "--n-option-text-color-pressed": optionTextColorPressed,
              "--n-option-padding": optionPadding,
              "--n-option-padding-left": getMargin(optionPadding, "left"),
              "--n-option-padding-right": getMargin(optionPadding, "right"),
              "--n-loading-color": loadingColor,
              "--n-loading-size": loadingSize
            };
          });
          const {
            inlineThemeDisabled
          } = props;
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("internal-select-menu", vue.computed(() => props.size[0]), cssVarsRef, props) : void 0;
          const exposedProps = {
            selfRef,
            next,
            prev,
            getPendingTmNode
          };
          useOnResize(selfRef, props.onResize);
          return Object.assign({
            mergedTheme: themeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            virtualListRef,
            scrollbarRef,
            itemSize: itemSizeRef,
            padding: paddingRef,
            flattenedNodes: flattenedNodesRef,
            empty: emptyRef,
            virtualListContainer() {
              const {
                value
              } = virtualListRef;
              return value === null || value === void 0 ? void 0 : value.listElRef;
            },
            virtualListContent() {
              const {
                value
              } = virtualListRef;
              return value === null || value === void 0 ? void 0 : value.itemsElRef;
            },
            doScroll,
            handleFocusin,
            handleFocusout,
            handleKeyUp,
            handleKeyDown,
            handleMouseDown,
            handleVirtualListResize,
            handleVirtualListScroll,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          }, exposedProps);
        },
        render() {
          const {
            $slots,
            virtualScroll,
            clsPrefix,
            mergedTheme,
            themeClass,
            onRender
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("div", {
            ref: "selfRef",
            tabindex: this.focusable ? 0 : -1,
            class: [`${clsPrefix}-base-select-menu`, this.rtlEnabled && `${clsPrefix}-base-select-menu--rtl`, themeClass, this.multiple && `${clsPrefix}-base-select-menu--multiple`],
            style: this.cssVars,
            onFocusin: this.handleFocusin,
            onFocusout: this.handleFocusout,
            onKeyup: this.handleKeyUp,
            onKeydown: this.handleKeyDown,
            onMousedown: this.handleMouseDown,
            onMouseenter: this.onMouseenter,
            onMouseleave: this.onMouseleave
          }, resolveWrappedSlot($slots.header, (children) => children && vue.h("div", {
            class: `${clsPrefix}-base-select-menu__header`,
            "data-header": true,
            key: "header"
          }, children)), this.loading ? vue.h("div", {
            class: `${clsPrefix}-base-select-menu__loading`
          }, vue.h(NBaseLoading, {
            clsPrefix,
            strokeWidth: 20
          })) : !this.empty ? vue.h(Scrollbar, {
            ref: "scrollbarRef",
            theme: mergedTheme.peers.Scrollbar,
            themeOverrides: mergedTheme.peerOverrides.Scrollbar,
            scrollable: this.scrollable,
            container: virtualScroll ? this.virtualListContainer : void 0,
            content: virtualScroll ? this.virtualListContent : void 0,
            onScroll: virtualScroll ? void 0 : this.doScroll
          }, {
            default: () => {
              return virtualScroll ? vue.h(VVirtualList, {
                ref: "virtualListRef",
                class: `${clsPrefix}-virtual-list`,
                items: this.flattenedNodes,
                itemSize: this.itemSize,
                showScrollbar: false,
                paddingTop: this.padding.top,
                paddingBottom: this.padding.bottom,
                onResize: this.handleVirtualListResize,
                onScroll: this.handleVirtualListScroll,
                itemResizable: true
              }, {
                default: ({
                  item: tmNode
                }) => {
                  return tmNode.isGroup ? vue.h(NSelectGroupHeader, {
                    key: tmNode.key,
                    clsPrefix,
                    tmNode
                  }) : tmNode.ignored ? null : vue.h(NSelectOption, {
                    clsPrefix,
                    key: tmNode.key,
                    tmNode
                  });
                }
              }) : vue.h("div", {
                class: `${clsPrefix}-base-select-menu-option-wrapper`,
                style: {
                  paddingTop: this.padding.top,
                  paddingBottom: this.padding.bottom
                }
              }, this.flattenedNodes.map((tmNode) => tmNode.isGroup ? vue.h(NSelectGroupHeader, {
                key: tmNode.key,
                clsPrefix,
                tmNode
              }) : vue.h(NSelectOption, {
                clsPrefix,
                key: tmNode.key,
                tmNode
              })));
            }
          }) : vue.h("div", {
            class: `${clsPrefix}-base-select-menu__empty`,
            "data-empty": true
          }, resolveSlot($slots.empty, () => [vue.h(NEmpty, {
            theme: mergedTheme.peers.Empty,
            themeOverrides: mergedTheme.peerOverrides.Empty,
            size: this.size
          })])), resolveWrappedSlot($slots.action, (children) => children && [vue.h("div", {
            class: `${clsPrefix}-base-select-menu__action`,
            "data-action": true,
            key: "action"
          }, children), vue.h(FocusDetector, {
            onFocus: this.onTabOut,
            key: "focus-detector"
          })]));
        }
      });
      const commonVariables$c = {
        space: "6px",
        spaceArrow: "10px",
        arrowOffset: "10px",
        arrowOffsetVertical: "10px",
        arrowHeight: "6px",
        padding: "8px 14px"
      };
      function self$q(vars) {
        const {
          boxShadow2,
          popoverColor,
          textColor2,
          borderRadius,
          fontSize: fontSize2,
          dividerColor
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$c), {
          fontSize: fontSize2,
          borderRadius,
          color: popoverColor,
          dividerColor,
          textColor: textColor2,
          boxShadow: boxShadow2
        });
      }
      const popoverLight = createTheme({
        name: "Popover",
        common: derived,
        peers: {
          Scrollbar: scrollbarLight
        },
        self: self$q
      });
      const oppositePlacement = {
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
      };
      const arrowSize = "var(--n-arrow-height) * 1.414";
      const style$q = c$1([cB("popover", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 position: relative;
 font-size: var(--n-font-size);
 color: var(--n-text-color);
 box-shadow: var(--n-box-shadow);
 word-break: break-word;
 `, [c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("raw", `
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 `, [cNotM("scrollable", [cNotM("show-header-or-footer", "padding: var(--n-padding);")])]), cE("header", `
 padding: var(--n-padding);
 border-bottom: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cE("footer", `
 padding: var(--n-padding);
 border-top: 1px solid var(--n-divider-color);
 transition: border-color .3s var(--n-bezier);
 `), cM("scrollable, show-header-or-footer", [cE("content", `
 padding: var(--n-padding);
 `)])]), cB("popover-shared", `
 transform-origin: inherit;
 `, [
        cB("popover-arrow-wrapper", `
 position: absolute;
 overflow: hidden;
 pointer-events: none;
 `, [cB("popover-arrow", `
 transition: background-color .3s var(--n-bezier);
 position: absolute;
 display: block;
 width: calc(${arrowSize});
 height: calc(${arrowSize});
 box-shadow: 0 0 8px 0 rgba(0, 0, 0, .12);
 transform: rotate(45deg);
 background-color: var(--n-color);
 pointer-events: all;
 `)]),
c$1("&.popover-transition-enter-from, &.popover-transition-leave-to", `
 opacity: 0;
 transform: scale(.85);
 `),
        c$1("&.popover-transition-enter-to, &.popover-transition-leave-from", `
 transform: scale(1);
 opacity: 1;
 `),
        c$1("&.popover-transition-enter-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-out),
 transform .15s var(--n-bezier-ease-out);
 `),
        c$1("&.popover-transition-leave-active", `
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .15s var(--n-bezier-ease-in),
 transform .15s var(--n-bezier-ease-in);
 `)
      ]), placementStyle("top-start", `
 top: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("top-start")} - var(--v-offset-left));
 `), placementStyle("top", `
 top: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("top-end", `
 top: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("top-end")} + var(--v-offset-left));
 `), placementStyle("bottom-start", `
 bottom: calc(${arrowSize} / -2);
 left: calc(${getArrowOffset("bottom-start")} - var(--v-offset-left));
 `), placementStyle("bottom", `
 bottom: calc(${arrowSize} / -2);
 transform: translateX(calc(${arrowSize} / -2)) rotate(45deg);
 left: 50%;
 `), placementStyle("bottom-end", `
 bottom: calc(${arrowSize} / -2);
 right: calc(${getArrowOffset("bottom-end")} + var(--v-offset-left));
 `), placementStyle("left-start", `
 left: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("left-start")} - var(--v-offset-top));
 `), placementStyle("left", `
 left: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("left-end", `
 left: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("left-end")} + var(--v-offset-top));
 `), placementStyle("right-start", `
 right: calc(${arrowSize} / -2);
 top: calc(${getArrowOffset("right-start")} - var(--v-offset-top));
 `), placementStyle("right", `
 right: calc(${arrowSize} / -2);
 transform: translateY(calc(${arrowSize} / -2)) rotate(45deg);
 top: 50%;
 `), placementStyle("right-end", `
 right: calc(${arrowSize} / -2);
 bottom: calc(${getArrowOffset("right-end")} + var(--v-offset-top));
 `), ...map({
        top: ["right-start", "left-start"],
        right: ["top-end", "bottom-end"],
        bottom: ["right-end", "left-end"],
        left: ["top-start", "bottom-start"]
      }, (placements, direction) => {
        const isVertical = ["right", "left"].includes(direction);
        const sizeType = isVertical ? "width" : "height";
        return placements.map((placement) => {
          const isReverse = placement.split("-")[1] === "end";
          const targetSize = `var(--v-target-${sizeType}, 0px)`;
          const centerOffset = `calc((${targetSize} - ${arrowSize}) / 2)`;
          const offset = getArrowOffset(placement);
          return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", [cM("center-arrow", [cB("popover-arrow", `${direction}: calc(max(${centerOffset}, ${offset}) ${isReverse ? "+" : "-"} var(--v-offset-${isVertical ? "left" : "top"}));`)])])]);
        });
      })]);
      function getArrowOffset(placement) {
        return ["top", "bottom"].includes(placement.split("-")[0]) ? "var(--n-arrow-offset)" : "var(--n-arrow-offset-vertical)";
      }
      function placementStyle(placement, arrowStyleLiteral) {
        const position = placement.split("-")[0];
        const sizeStyle = ["top", "bottom"].includes(position) ? "height: var(--n-space-arrow);" : "width: var(--n-space-arrow);";
        return c$1(`[v-placement="${placement}"] >`, [cB("popover-shared", `
 margin-${oppositePlacement[position]}: var(--n-space);
 `, [cM("show-arrow", `
 margin-${oppositePlacement[position]}: var(--n-space-arrow);
 `), cM("overlap", `
 margin: 0;
 `), cCB("popover-arrow-wrapper", `
 right: 0;
 left: 0;
 top: 0;
 bottom: 0;
 ${position}: 100%;
 ${oppositePlacement[position]}: auto;
 ${sizeStyle}
 `, [cB("popover-arrow", arrowStyleLiteral)])])]);
      }
      const popoverBodyProps = Object.assign(Object.assign({}, useTheme.props), {
        to: useAdjustedTo.propTo,
        show: Boolean,
        trigger: String,
        showArrow: Boolean,
        delay: Number,
        duration: Number,
        raw: Boolean,
        arrowPointToCenter: Boolean,
        arrowClass: String,
        arrowStyle: [String, Object],
        arrowWrapperClass: String,
        arrowWrapperStyle: [String, Object],
        displayDirective: String,
        x: Number,
        y: Number,
        flip: Boolean,
        overlap: Boolean,
        placement: String,
        width: [Number, String],
        keepAliveOnHover: Boolean,
        scrollable: Boolean,
        contentClass: String,
        contentStyle: [Object, String],
        headerClass: String,
        headerStyle: [Object, String],
        footerClass: String,
        footerStyle: [Object, String],
internalDeactivateImmediately: Boolean,
        animated: Boolean,
        onClickoutside: Function,
        internalTrapFocus: Boolean,
        internalOnAfterLeave: Function,
minWidth: Number,
        maxWidth: Number
      });
      function renderArrow({
        arrowClass,
        arrowStyle,
        arrowWrapperClass,
        arrowWrapperStyle,
        clsPrefix
      }) {
        return vue.h("div", {
          key: "__popover-arrow__",
          style: arrowWrapperStyle,
          class: [`${clsPrefix}-popover-arrow-wrapper`, arrowWrapperClass]
        }, vue.h("div", {
          class: [`${clsPrefix}-popover-arrow`, arrowClass],
          style: arrowStyle
        }));
      }
      const NPopoverBody = vue.defineComponent({
        name: "PopoverBody",
        inheritAttrs: false,
        props: popoverBodyProps,
        setup(props, {
          slots,
          attrs
        }) {
          const {
            namespaceRef,
            mergedClsPrefixRef,
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const themeRef = useTheme("Popover", "-popover", style$q, popoverLight, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Popover", mergedRtlRef, mergedClsPrefixRef);
          const followerRef = vue.ref(null);
          const NPopover2 = vue.inject("NPopover");
          const bodyRef = vue.ref(null);
          const followerEnabledRef = vue.ref(props.show);
          const displayedRef = vue.ref(false);
          vue.watchEffect(() => {
            const {
              show
            } = props;
            if (show && !isJsdom() && !props.internalDeactivateImmediately) {
              displayedRef.value = true;
            }
          });
          const directivesRef = vue.computed(() => {
            const {
              trigger: trigger2,
              onClickoutside
            } = props;
            const directives = [];
            const {
              positionManuallyRef: {
                value: positionManually
              }
            } = NPopover2;
            if (!positionManually) {
              if (trigger2 === "click" && !onClickoutside) {
                directives.push([clickoutside, handleClickOutside, void 0, {
                  capture: true
                }]);
              }
              if (trigger2 === "hover") {
                directives.push([mousemoveoutside, handleMouseMoveOutside]);
              }
            }
            if (onClickoutside) {
              directives.push([clickoutside, handleClickOutside, void 0, {
                capture: true
              }]);
            }
            if (props.displayDirective === "show" || props.animated && displayedRef.value) {
              directives.push([vue.vShow, props.show]);
            }
            return directives;
          });
          const cssVarsRef = vue.computed(() => {
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2,
                cubicBezierEaseIn: cubicBezierEaseIn2,
                cubicBezierEaseOut: cubicBezierEaseOut2
              },
              self: {
                space,
                spaceArrow,
                padding,
                fontSize: fontSize2,
                textColor,
                dividerColor,
                color,
                boxShadow,
                borderRadius,
                arrowHeight,
                arrowOffset,
                arrowOffsetVertical
              }
            } = themeRef.value;
            return {
              "--n-box-shadow": boxShadow,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-bezier-ease-in": cubicBezierEaseIn2,
              "--n-bezier-ease-out": cubicBezierEaseOut2,
              "--n-font-size": fontSize2,
              "--n-text-color": textColor,
              "--n-color": color,
              "--n-divider-color": dividerColor,
              "--n-border-radius": borderRadius,
              "--n-arrow-height": arrowHeight,
              "--n-arrow-offset": arrowOffset,
              "--n-arrow-offset-vertical": arrowOffsetVertical,
              "--n-padding": padding,
              "--n-space": space,
              "--n-space-arrow": spaceArrow
            };
          });
          const styleRef = vue.computed(() => {
            const width = props.width === "trigger" ? void 0 : formatLength(props.width);
            const style2 = [];
            if (width) {
              style2.push({
                width
              });
            }
            const {
              maxWidth,
              minWidth
            } = props;
            if (maxWidth) {
              style2.push({
                maxWidth: formatLength(maxWidth)
              });
            }
            if (minWidth) {
              style2.push({
                maxWidth: formatLength(minWidth)
              });
            }
            if (!inlineThemeDisabled) {
              style2.push(cssVarsRef.value);
            }
            return style2;
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("popover", void 0, cssVarsRef, props) : void 0;
          NPopover2.setBodyInstance({
            syncPosition
          });
          vue.onBeforeUnmount(() => {
            NPopover2.setBodyInstance(null);
          });
          vue.watch(vue.toRef(props, "show"), (value) => {
            if (props.animated) return;
            if (value) {
              followerEnabledRef.value = true;
            } else {
              followerEnabledRef.value = false;
            }
          });
          function syncPosition() {
            var _a;
            (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function handleMouseEnter(e) {
            if (props.trigger === "hover" && props.keepAliveOnHover && props.show) {
              NPopover2.handleMouseEnter(e);
            }
          }
          function handleMouseLeave(e) {
            if (props.trigger === "hover" && props.keepAliveOnHover) {
              NPopover2.handleMouseLeave(e);
            }
          }
          function handleMouseMoveOutside(e) {
            if (props.trigger === "hover" && !getTriggerElement().contains(getPreciseEventTarget(e))) {
              NPopover2.handleMouseMoveOutside(e);
            }
          }
          function handleClickOutside(e) {
            if (props.trigger === "click" && !getTriggerElement().contains(getPreciseEventTarget(e)) || props.onClickoutside) {
              NPopover2.handleClickOutside(e);
            }
          }
          function getTriggerElement() {
            return NPopover2.getTriggerElement();
          }
          vue.provide(popoverBodyInjectionKey, bodyRef);
          vue.provide(drawerBodyInjectionKey, null);
          vue.provide(modalBodyInjectionKey, null);
          function renderContentNode() {
            themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender();
            const shouldRenderDom = props.displayDirective === "show" || props.show || props.animated && displayedRef.value;
            if (!shouldRenderDom) {
              return null;
            }
            let contentNode;
            const renderBody = NPopover2.internalRenderBodyRef.value;
            const {
              value: mergedClsPrefix
            } = mergedClsPrefixRef;
            if (!renderBody) {
              const {
                value: extraClass
              } = NPopover2.extraClassRef;
              const {
                internalTrapFocus
              } = props;
              const hasHeaderOrFooter = !isSlotEmpty(slots.header) || !isSlotEmpty(slots.footer);
              const renderContentInnerNode = () => {
                var _a, _b;
                const body = hasHeaderOrFooter ? vue.h(vue.Fragment, null, resolveWrappedSlot(slots.header, (children) => {
                  return children ? vue.h("div", {
                    class: [`${mergedClsPrefix}-popover__header`, props.headerClass],
                    style: props.headerStyle
                  }, children) : null;
                }), resolveWrappedSlot(slots.default, (children) => {
                  return children ? vue.h("div", {
                    class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
                    style: props.contentStyle
                  }, slots) : null;
                }), resolveWrappedSlot(slots.footer, (children) => {
                  return children ? vue.h("div", {
                    class: [`${mergedClsPrefix}-popover__footer`, props.footerClass],
                    style: props.footerStyle
                  }, children) : null;
                })) : props.scrollable ? (_a = slots.default) === null || _a === void 0 ? void 0 : _a.call(slots) : vue.h("div", {
                  class: [`${mergedClsPrefix}-popover__content`, props.contentClass],
                  style: props.contentStyle
                }, slots);
                const maybeScrollableBody = props.scrollable ? vue.h(XScrollbar, {
                  themeOverrides: themeRef.value.peerOverrides.Scrollbar,
                  theme: themeRef.value.peers.Scrollbar,
                  contentClass: hasHeaderOrFooter ? void 0 : `${mergedClsPrefix}-popover__content ${(_b = props.contentClass) !== null && _b !== void 0 ? _b : ""}`,
                  contentStyle: hasHeaderOrFooter ? void 0 : props.contentStyle
                }, {
                  default: () => body
                }) : body;
                const arrow = props.showArrow ? renderArrow({
                  arrowClass: props.arrowClass,
                  arrowStyle: props.arrowStyle,
                  arrowWrapperClass: props.arrowWrapperClass,
                  arrowWrapperStyle: props.arrowWrapperStyle,
                  clsPrefix: mergedClsPrefix
                }) : null;
                return [maybeScrollableBody, arrow];
              };
              contentNode = vue.h("div", vue.mergeProps({
                class: [`${mergedClsPrefix}-popover`, `${mergedClsPrefix}-popover-shared`, (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) && `${mergedClsPrefix}-popover--rtl`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, extraClass.map((v) => `${mergedClsPrefix}-${v}`), {
                  [`${mergedClsPrefix}-popover--scrollable`]: props.scrollable,
                  [`${mergedClsPrefix}-popover--show-header-or-footer`]: hasHeaderOrFooter,
                  [`${mergedClsPrefix}-popover--raw`]: props.raw,
                  [`${mergedClsPrefix}-popover-shared--overlap`]: props.overlap,
                  [`${mergedClsPrefix}-popover-shared--show-arrow`]: props.showArrow,
                  [`${mergedClsPrefix}-popover-shared--center-arrow`]: props.arrowPointToCenter
                }],
                ref: bodyRef,
                style: styleRef.value,
                onKeydown: NPopover2.handleKeydown,
                onMouseenter: handleMouseEnter,
                onMouseleave: handleMouseLeave
              }, attrs), internalTrapFocus ? vue.h(FocusTrap, {
                active: props.show,
                autoFocus: true
              }, {
                default: renderContentInnerNode
              }) : renderContentInnerNode());
            } else {
              contentNode = renderBody(


[`${mergedClsPrefix}-popover-shared`, (rtlEnabledRef === null || rtlEnabledRef === void 0 ? void 0 : rtlEnabledRef.value) && `${mergedClsPrefix}-popover--rtl`, themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass.value, props.overlap && `${mergedClsPrefix}-popover-shared--overlap`, props.showArrow && `${mergedClsPrefix}-popover-shared--show-arrow`, props.arrowPointToCenter && `${mergedClsPrefix}-popover-shared--center-arrow`],
                bodyRef,
                styleRef.value,
                handleMouseEnter,
                handleMouseLeave
              );
            }
            return vue.withDirectives(contentNode, directivesRef.value);
          }
          return {
            displayed: displayedRef,
            namespace: namespaceRef,
            isMounted: NPopover2.isMountedRef,
            zIndex: NPopover2.zIndexRef,
            followerRef,
            adjustedTo: useAdjustedTo(props),
            followerEnabled: followerEnabledRef,
            renderContentNode
          };
        },
        render() {
          return vue.h(VFollower, {
            ref: "followerRef",
            zIndex: this.zIndex,
            show: this.show,
            enabled: this.followerEnabled,
            to: this.adjustedTo,
            x: this.x,
            y: this.y,
            flip: this.flip,
            placement: this.placement,
            containerClass: this.namespace,
            overlap: this.overlap,
            width: this.width === "trigger" ? "target" : void 0,
            teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey
          }, {
            default: () => {
              return this.animated ? vue.h(vue.Transition, {
                name: "popover-transition",
                appear: this.isMounted,

onEnter: () => {
                  this.followerEnabled = true;
                },
                onAfterLeave: () => {
                  var _a;
                  (_a = this.internalOnAfterLeave) === null || _a === void 0 ? void 0 : _a.call(this);
                  this.followerEnabled = false;
                  this.displayed = false;
                }
              }, {
                default: this.renderContentNode
              }) : this.renderContentNode();
            }
          });
        }
      });
      const bodyPropKeys = Object.keys(popoverBodyProps);
      const triggerEventMap = {
        focus: ["onFocus", "onBlur"],
        click: ["onClick"],
        hover: ["onMouseenter", "onMouseleave"],
        manual: [],
        nested: ["onFocus", "onBlur", "onMouseenter", "onMouseleave", "onClick"]
      };
      function appendEvents(vNode, trigger2, events2) {
        triggerEventMap[trigger2].forEach((eventName) => {
          if (!vNode.props) {
            vNode.props = {};
          } else {
            vNode.props = Object.assign({}, vNode.props);
          }
          const originalHandler = vNode.props[eventName];
          const handler = events2[eventName];
          if (!originalHandler) {
            vNode.props[eventName] = handler;
          } else {
            vNode.props[eventName] = (...args) => {
              originalHandler(...args);
              handler(...args);
            };
          }
        });
      }
      const popoverBaseProps = {
        show: {
          type: Boolean,
          default: void 0
        },
        defaultShow: Boolean,
        showArrow: {
          type: Boolean,
          default: true
        },
        trigger: {
          type: String,
          default: "hover"
        },
        delay: {
          type: Number,
          default: 100
        },
        duration: {
          type: Number,
          default: 100
        },
        raw: Boolean,
        placement: {
          type: String,
          default: "top"
        },
        x: Number,
        y: Number,
        arrowPointToCenter: Boolean,
        disabled: Boolean,
        getDisabled: Function,
        displayDirective: {
          type: String,
          default: "if"
        },
        arrowClass: String,
        arrowStyle: [String, Object],
        arrowWrapperClass: String,
        arrowWrapperStyle: [String, Object],
        flip: {
          type: Boolean,
          default: true
        },
        animated: {
          type: Boolean,
          default: true
        },
        width: {
          type: [Number, String],
          default: void 0
        },
        overlap: Boolean,
        keepAliveOnHover: {
          type: Boolean,
          default: true
        },
        zIndex: Number,
        to: useAdjustedTo.propTo,
        scrollable: Boolean,
        contentClass: String,
        contentStyle: [Object, String],
        headerClass: String,
        headerStyle: [Object, String],
        footerClass: String,
        footerStyle: [Object, String],
onClickoutside: Function,
        "onUpdate:show": [Function, Array],
        onUpdateShow: [Function, Array],
internalDeactivateImmediately: Boolean,
        internalSyncTargetWithParent: Boolean,
        internalInheritedEventHandlers: {
          type: Array,
          default: () => []
        },
        internalTrapFocus: Boolean,
        internalExtraClass: {
          type: Array,
          default: () => []
        },
onShow: [Function, Array],
        onHide: [Function, Array],
        arrow: {
          type: Boolean,
          default: void 0
        },
        minWidth: Number,
        maxWidth: Number
      };
      const popoverProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), {
        internalOnAfterLeave: Function,
        internalRenderBody: Function
      });
      const NPopover = vue.defineComponent({
        name: "Popover",
        inheritAttrs: false,
        props: popoverProps,
        slots: Object,
        __popover__: true,
        setup(props) {
          const isMountedRef = isMounted();
          const binderInstRef = vue.ref(null);
          const controlledShowRef = vue.computed(() => props.show);
          const uncontrolledShowRef = vue.ref(props.defaultShow);
          const mergedShowWithoutDisabledRef = useMergedState(controlledShowRef, uncontrolledShowRef);
          const mergedShowConsideringDisabledPropRef = useMemo(() => {
            if (props.disabled) return false;
            return mergedShowWithoutDisabledRef.value;
          });
          const getMergedDisabled = () => {
            if (props.disabled) return true;
            const {
              getDisabled
            } = props;
            if (getDisabled === null || getDisabled === void 0 ? void 0 : getDisabled()) return true;
            return false;
          };
          const getMergedShow = () => {
            if (getMergedDisabled()) return false;
            return mergedShowWithoutDisabledRef.value;
          };
          const compatibleShowArrowRef = useCompitable(props, ["arrow", "showArrow"]);
          const mergedShowArrowRef = vue.computed(() => {
            if (props.overlap) return false;
            return compatibleShowArrowRef.value;
          });
          let bodyInstance = null;
          const showTimerIdRef = vue.ref(null);
          const hideTimerIdRef = vue.ref(null);
          const positionManuallyRef = useMemo(() => {
            return props.x !== void 0 && props.y !== void 0;
          });
          function doUpdateShow(value) {
            const {
              "onUpdate:show": _onUpdateShow,
              onUpdateShow,
              onShow,
              onHide
            } = props;
            uncontrolledShowRef.value = value;
            if (_onUpdateShow) {
              call(_onUpdateShow, value);
            }
            if (onUpdateShow) {
              call(onUpdateShow, value);
            }
            if (value && onShow) {
              call(onShow, true);
            }
            if (value && onHide) {
              call(onHide, false);
            }
          }
          function syncPosition() {
            if (bodyInstance) {
              bodyInstance.syncPosition();
            }
          }
          function clearShowTimer() {
            const {
              value: showTimerId
            } = showTimerIdRef;
            if (showTimerId) {
              window.clearTimeout(showTimerId);
              showTimerIdRef.value = null;
            }
          }
          function clearHideTimer() {
            const {
              value: hideTimerId
            } = hideTimerIdRef;
            if (hideTimerId) {
              window.clearTimeout(hideTimerId);
              hideTimerIdRef.value = null;
            }
          }
          function handleFocus() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === "focus" && !mergedDisabled) {
              if (getMergedShow()) return;
              doUpdateShow(true);
            }
          }
          function handleBlur() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === "focus" && !mergedDisabled) {
              if (!getMergedShow()) return;
              doUpdateShow(false);
            }
          }
          function handleMouseEnter() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === "hover" && !mergedDisabled) {
              clearHideTimer();
              if (showTimerIdRef.value !== null) return;
              if (getMergedShow()) return;
              const delayCallback = () => {
                doUpdateShow(true);
                showTimerIdRef.value = null;
              };
              const {
                delay
              } = props;
              if (delay === 0) {
                delayCallback();
              } else {
                showTimerIdRef.value = window.setTimeout(delayCallback, delay);
              }
            }
          }
          function handleMouseLeave() {
            const mergedDisabled = getMergedDisabled();
            if (props.trigger === "hover" && !mergedDisabled) {
              clearShowTimer();
              if (hideTimerIdRef.value !== null) return;
              if (!getMergedShow()) return;
              const delayedCallback = () => {
                doUpdateShow(false);
                hideTimerIdRef.value = null;
              };
              const {
                duration: duration2
              } = props;
              if (duration2 === 0) {
                delayedCallback();
              } else {
                hideTimerIdRef.value = window.setTimeout(delayedCallback, duration2);
              }
            }
          }
          function handleMouseMoveOutside() {
            handleMouseLeave();
          }
          function handleClickOutside(e) {
            var _a;
            if (!getMergedShow()) return;
            if (props.trigger === "click") {
              clearShowTimer();
              clearHideTimer();
              doUpdateShow(false);
            }
            (_a = props.onClickoutside) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handleClick2() {
            if (props.trigger === "click" && !getMergedDisabled()) {
              clearShowTimer();
              clearHideTimer();
              const nextShow = !getMergedShow();
              doUpdateShow(nextShow);
            }
          }
          function handleKeydown(e) {
            if (!props.internalTrapFocus) return;
            if (e.key === "Escape") {
              clearShowTimer();
              clearHideTimer();
              doUpdateShow(false);
            }
          }
          function setShow(value) {
            uncontrolledShowRef.value = value;
          }
          function getTriggerElement() {
            var _a;
            return (_a = binderInstRef.value) === null || _a === void 0 ? void 0 : _a.targetRef;
          }
          function setBodyInstance(value) {
            bodyInstance = value;
          }
          vue.provide("NPopover", {
            getTriggerElement,
            handleKeydown,
            handleMouseEnter,
            handleMouseLeave,
            handleClickOutside,
            handleMouseMoveOutside,
            setBodyInstance,
            positionManuallyRef,
            isMountedRef,
            zIndexRef: vue.toRef(props, "zIndex"),
            extraClassRef: vue.toRef(props, "internalExtraClass"),
            internalRenderBodyRef: vue.toRef(props, "internalRenderBody")
          });
          vue.watchEffect(() => {
            if (mergedShowWithoutDisabledRef.value && getMergedDisabled()) {
              doUpdateShow(false);
            }
          });
          const returned = {
            binderInstRef,
            positionManually: positionManuallyRef,
            mergedShowConsideringDisabledProp: mergedShowConsideringDisabledPropRef,
uncontrolledShow: uncontrolledShowRef,
            mergedShowArrow: mergedShowArrowRef,
            getMergedShow,
            setShow,
            handleClick: handleClick2,
            handleMouseEnter,
            handleMouseLeave,
            handleFocus,
            handleBlur,
            syncPosition
          };
          return returned;
        },
        render() {
          var _a;
          const {
            positionManually,
            $slots: slots
          } = this;
          let triggerVNode;
          let popoverInside = false;
          if (!positionManually) {
            triggerVNode = getFirstSlotVNode(slots, "trigger");
            if (triggerVNode) {
              triggerVNode = vue.cloneVNode(triggerVNode);
              triggerVNode = triggerVNode.type === vue.Text ? vue.h("span", [triggerVNode]) : triggerVNode;
              const handlers = {
                onClick: this.handleClick,
                onMouseenter: this.handleMouseEnter,
                onMouseleave: this.handleMouseLeave,
                onFocus: this.handleFocus,
                onBlur: this.handleBlur
              };
              if ((_a = triggerVNode.type) === null || _a === void 0 ? void 0 : _a.__popover__) {
                popoverInside = true;
                if (!triggerVNode.props) {
                  triggerVNode.props = {
                    internalSyncTargetWithParent: true,
                    internalInheritedEventHandlers: []
                  };
                }
                triggerVNode.props.internalSyncTargetWithParent = true;
                if (!triggerVNode.props.internalInheritedEventHandlers) {
                  triggerVNode.props.internalInheritedEventHandlers = [handlers];
                } else {
                  triggerVNode.props.internalInheritedEventHandlers = [handlers, ...triggerVNode.props.internalInheritedEventHandlers];
                }
              } else {
                const {
                  internalInheritedEventHandlers
                } = this;
                const ascendantAndCurrentHandlers = [handlers, ...internalInheritedEventHandlers];
                const mergedHandlers = {
                  onBlur: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onBlur(e);
                    });
                  },
                  onFocus: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onFocus(e);
                    });
                  },
                  onClick: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onClick(e);
                    });
                  },
                  onMouseenter: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onMouseenter(e);
                    });
                  },
                  onMouseleave: (e) => {
                    ascendantAndCurrentHandlers.forEach((_handlers) => {
                      _handlers.onMouseleave(e);
                    });
                  }
                };
                appendEvents(triggerVNode, internalInheritedEventHandlers ? "nested" : positionManually ? "manual" : this.trigger, mergedHandlers);
              }
            }
          }
          return vue.h(Binder, {
            ref: "binderInstRef",
            syncTarget: !popoverInside,
            syncTargetWithParent: this.internalSyncTargetWithParent
          }, {
            default: () => {
              void this.mergedShowConsideringDisabledProp;
              const mergedShow = this.getMergedShow();
              return [this.internalTrapFocus && mergedShow ? vue.withDirectives(vue.h("div", {
                style: {
                  position: "fixed",
                  top: 0,
                  right: 0,
                  bottom: 0,
                  left: 0
                }
              }), [[zindexable, {
                enabled: mergedShow,
                zIndex: this.zIndex
              }]]) : null, positionManually ? null : vue.h(VTarget, null, {
                default: () => triggerVNode
              }), vue.h(NPopoverBody, keep(this.$props, bodyPropKeys, Object.assign(Object.assign({}, this.$attrs), {
                showArrow: this.mergedShowArrow,
                show: mergedShow
              })), {
                default: () => {
                  var _a2, _b;
                  return (_b = (_a2 = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a2);
                },
                header: () => {
                  var _a2, _b;
                  return (_b = (_a2 = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a2);
                },
                footer: () => {
                  var _a2, _b;
                  return (_b = (_a2 = this.$slots).footer) === null || _b === void 0 ? void 0 : _b.call(_a2);
                }
              })];
            }
          });
        }
      });
      const commonVariables$b = {
        closeIconSizeTiny: "12px",
        closeIconSizeSmall: "12px",
        closeIconSizeMedium: "14px",
        closeIconSizeLarge: "14px",
        closeSizeTiny: "16px",
        closeSizeSmall: "16px",
        closeSizeMedium: "18px",
        closeSizeLarge: "18px",
        padding: "0 7px",
        closeMargin: "0 0 0 4px"
      };
      function self$p(vars) {
        const {
          textColor2,
          primaryColorHover,
          primaryColorPressed,
          primaryColor,
          infoColor,
          successColor,
          warningColor,
          errorColor,
          baseColor,
          borderColor,
          opacityDisabled,
          tagColor,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          borderRadiusSmall: borderRadius,
          fontSizeMini,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          heightMini,
          heightTiny,
          heightSmall,
          heightMedium,
          closeColorHover,
          closeColorPressed,
          buttonColor2Hover,
          buttonColor2Pressed,
          fontWeightStrong
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$b), {
          closeBorderRadius: borderRadius,
          heightTiny: heightMini,
          heightSmall: heightTiny,
          heightMedium: heightSmall,
          heightLarge: heightMedium,
          borderRadius,
          opacityDisabled,
          fontSizeTiny: fontSizeMini,
          fontSizeSmall: fontSizeTiny,
          fontSizeMedium: fontSizeSmall,
          fontSizeLarge: fontSizeMedium,
          fontWeightStrong,
textColorCheckable: textColor2,
          textColorHoverCheckable: textColor2,
          textColorPressedCheckable: textColor2,
          textColorChecked: baseColor,
          colorCheckable: "#0000",
          colorHoverCheckable: buttonColor2Hover,
          colorPressedCheckable: buttonColor2Pressed,
          colorChecked: primaryColor,
          colorCheckedHover: primaryColorHover,
          colorCheckedPressed: primaryColorPressed,
border: `1px solid ${borderColor}`,
          textColor: textColor2,
          color: tagColor,
          colorBordered: "rgb(250, 250, 252)",
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          borderPrimary: `1px solid ${changeColor(primaryColor, {
          alpha: 0.3
        })}`,
          textColorPrimary: primaryColor,
          colorPrimary: changeColor(primaryColor, {
            alpha: 0.12
          }),
          colorBorderedPrimary: changeColor(primaryColor, {
            alpha: 0.1
          }),
          closeIconColorPrimary: primaryColor,
          closeIconColorHoverPrimary: primaryColor,
          closeIconColorPressedPrimary: primaryColor,
          closeColorHoverPrimary: changeColor(primaryColor, {
            alpha: 0.12
          }),
          closeColorPressedPrimary: changeColor(primaryColor, {
            alpha: 0.18
          }),
          borderInfo: `1px solid ${changeColor(infoColor, {
          alpha: 0.3
        })}`,
          textColorInfo: infoColor,
          colorInfo: changeColor(infoColor, {
            alpha: 0.12
          }),
          colorBorderedInfo: changeColor(infoColor, {
            alpha: 0.1
          }),
          closeIconColorInfo: infoColor,
          closeIconColorHoverInfo: infoColor,
          closeIconColorPressedInfo: infoColor,
          closeColorHoverInfo: changeColor(infoColor, {
            alpha: 0.12
          }),
          closeColorPressedInfo: changeColor(infoColor, {
            alpha: 0.18
          }),
          borderSuccess: `1px solid ${changeColor(successColor, {
          alpha: 0.3
        })}`,
          textColorSuccess: successColor,
          colorSuccess: changeColor(successColor, {
            alpha: 0.12
          }),
          colorBorderedSuccess: changeColor(successColor, {
            alpha: 0.1
          }),
          closeIconColorSuccess: successColor,
          closeIconColorHoverSuccess: successColor,
          closeIconColorPressedSuccess: successColor,
          closeColorHoverSuccess: changeColor(successColor, {
            alpha: 0.12
          }),
          closeColorPressedSuccess: changeColor(successColor, {
            alpha: 0.18
          }),
          borderWarning: `1px solid ${changeColor(warningColor, {
          alpha: 0.35
        })}`,
          textColorWarning: warningColor,
          colorWarning: changeColor(warningColor, {
            alpha: 0.15
          }),
          colorBorderedWarning: changeColor(warningColor, {
            alpha: 0.12
          }),
          closeIconColorWarning: warningColor,
          closeIconColorHoverWarning: warningColor,
          closeIconColorPressedWarning: warningColor,
          closeColorHoverWarning: changeColor(warningColor, {
            alpha: 0.12
          }),
          closeColorPressedWarning: changeColor(warningColor, {
            alpha: 0.18
          }),
          borderError: `1px solid ${changeColor(errorColor, {
          alpha: 0.23
        })}`,
          textColorError: errorColor,
          colorError: changeColor(errorColor, {
            alpha: 0.1
          }),
          colorBorderedError: changeColor(errorColor, {
            alpha: 0.08
          }),
          closeIconColorError: errorColor,
          closeIconColorHoverError: errorColor,
          closeIconColorPressedError: errorColor,
          closeColorHoverError: changeColor(errorColor, {
            alpha: 0.12
          }),
          closeColorPressedError: changeColor(errorColor, {
            alpha: 0.18
          })
        });
      }
      const tagLight = {
        common: derived,
        self: self$p
      };
      const commonProps = {
        color: Object,
        type: {
          type: String,
          default: "default"
        },
        round: Boolean,
        size: {
          type: String,
          default: "medium"
        },
        closable: Boolean,
        disabled: {
          type: Boolean,
          default: void 0
        }
      };
      const style$p = cB("tag", `
 --n-close-margin: var(--n-close-margin-top) var(--n-close-margin-right) var(--n-close-margin-bottom) var(--n-close-margin-left);
 white-space: nowrap;
 position: relative;
 box-sizing: border-box;
 cursor: default;
 display: inline-flex;
 align-items: center;
 flex-wrap: nowrap;
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 line-height: 1;
 height: var(--n-height);
 font-size: var(--n-font-size);
`, [cM("strong", `
 font-weight: var(--n-font-weight-strong);
 `), cE("border", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
 border: var(--n-border);
 transition: border-color .3s var(--n-bezier);
 `), cE("icon", `
 display: flex;
 margin: 0 4px 0 0;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 font-size: var(--n-avatar-size-override);
 `), cE("avatar", `
 display: flex;
 margin: 0 6px 0 0;
 `), cE("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cM("round", `
 padding: 0 calc(var(--n-height) / 3);
 border-radius: calc(var(--n-height) / 2);
 `, [cE("icon", `
 margin: 0 4px 0 calc((var(--n-height) - 8px) / -2);
 `), cE("avatar", `
 margin: 0 6px 0 calc((var(--n-height) - 8px) / -2);
 `), cM("closable", `
 padding: 0 calc(var(--n-height) / 4) 0 calc(var(--n-height) / 3);
 `)]), cM("icon, avatar", [cM("round", `
 padding: 0 calc(var(--n-height) / 3) 0 calc(var(--n-height) / 2);
 `)]), cM("disabled", `
 cursor: not-allowed !important;
 opacity: var(--n-opacity-disabled);
 `), cM("checkable", `
 cursor: pointer;
 box-shadow: none;
 color: var(--n-text-color-checkable);
 background-color: var(--n-color-checkable);
 `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-hover-checkable);", [cNotM("checked", "color: var(--n-text-color-hover-checkable);")]), c$1("&:active", "background-color: var(--n-color-pressed-checkable);", [cNotM("checked", "color: var(--n-text-color-pressed-checkable);")])]), cM("checked", `
 color: var(--n-text-color-checked);
 background-color: var(--n-color-checked);
 `, [cNotM("disabled", [c$1("&:hover", "background-color: var(--n-color-checked-hover);"), c$1("&:active", "background-color: var(--n-color-checked-pressed);")])])])]);
      const tagProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), commonProps), {
        bordered: {
          type: Boolean,
          default: void 0
        },
        checked: Boolean,
        checkable: Boolean,
        strong: Boolean,
        triggerClickOnClose: Boolean,
        onClose: [Array, Function],
        onMouseenter: Function,
        onMouseleave: Function,
        "onUpdate:checked": Function,
        onUpdateChecked: Function,
internalCloseFocusable: {
          type: Boolean,
          default: true
        },
        internalCloseIsButtonTag: {
          type: Boolean,
          default: true
        },
onCheckedChange: Function
      });
      const tagInjectionKey = createInjectionKey("n-tag");
      const NTag = vue.defineComponent({
        name: "Tag",
        props: tagProps,
        slots: Object,
        setup(props) {
          const contentRef = vue.ref(null);
          const {
            mergedBorderedRef,
            mergedClsPrefixRef,
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const themeRef = useTheme("Tag", "-tag", style$p, tagLight, props, mergedClsPrefixRef);
          vue.provide(tagInjectionKey, {
            roundRef: vue.toRef(props, "round")
          });
          function handleClick2() {
            if (!props.disabled) {
              if (props.checkable) {
                const {
                  checked,
                  onCheckedChange,
                  onUpdateChecked,
                  "onUpdate:checked": _onUpdateChecked
                } = props;
                if (onUpdateChecked) onUpdateChecked(!checked);
                if (_onUpdateChecked) _onUpdateChecked(!checked);
                if (onCheckedChange) onCheckedChange(!checked);
              }
            }
          }
          function handleCloseClick(e) {
            if (!props.triggerClickOnClose) {
              e.stopPropagation();
            }
            if (!props.disabled) {
              const {
                onClose
              } = props;
              if (onClose) call(onClose, e);
            }
          }
          const tagPublicMethods = {
            setTextContent(textContent) {
              const {
                value
              } = contentRef;
              if (value) value.textContent = textContent;
            }
          };
          const rtlEnabledRef = useRtl("Tag", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              type,
              size: size2,
              color: {
                color,
                textColor
              } = {}
            } = props;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                padding,
                closeMargin,
                borderRadius,
                opacityDisabled,
                textColorCheckable,
                textColorHoverCheckable,
                textColorPressedCheckable,
                textColorChecked,
                colorCheckable,
                colorHoverCheckable,
                colorPressedCheckable,
                colorChecked,
                colorCheckedHover,
                colorCheckedPressed,
                closeBorderRadius,
                fontWeightStrong,
                [createKey("colorBordered", type)]: colorBordered,
                [createKey("closeSize", size2)]: closeSize,
                [createKey("closeIconSize", size2)]: closeIconSize,
                [createKey("fontSize", size2)]: fontSize2,
                [createKey("height", size2)]: height,
                [createKey("color", type)]: typedColor,
                [createKey("textColor", type)]: typeTextColor,
                [createKey("border", type)]: border,
                [createKey("closeIconColor", type)]: closeIconColor,
                [createKey("closeIconColorHover", type)]: closeIconColorHover,
                [createKey("closeIconColorPressed", type)]: closeIconColorPressed,
                [createKey("closeColorHover", type)]: closeColorHover,
                [createKey("closeColorPressed", type)]: closeColorPressed
              }
            } = themeRef.value;
            const closeMarginDiscrete = getMargin(closeMargin);
            return {
              "--n-font-weight-strong": fontWeightStrong,
              "--n-avatar-size-override": `calc(${height} - 8px)`,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-border": border,
              "--n-close-icon-size": closeIconSize,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-color-hover": closeColorHover,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-close-icon-color-disabled": closeIconColor,
              "--n-close-margin-top": closeMarginDiscrete.top,
              "--n-close-margin-right": closeMarginDiscrete.right,
              "--n-close-margin-bottom": closeMarginDiscrete.bottom,
              "--n-close-margin-left": closeMarginDiscrete.left,
              "--n-close-size": closeSize,
              "--n-color": color || (mergedBorderedRef.value ? colorBordered : typedColor),
              "--n-color-checkable": colorCheckable,
              "--n-color-checked": colorChecked,
              "--n-color-checked-hover": colorCheckedHover,
              "--n-color-checked-pressed": colorCheckedPressed,
              "--n-color-hover-checkable": colorHoverCheckable,
              "--n-color-pressed-checkable": colorPressedCheckable,
              "--n-font-size": fontSize2,
              "--n-height": height,
              "--n-opacity-disabled": opacityDisabled,
              "--n-padding": padding,
              "--n-text-color": textColor || typeTextColor,
              "--n-text-color-checkable": textColorCheckable,
              "--n-text-color-checked": textColorChecked,
              "--n-text-color-hover-checkable": textColorHoverCheckable,
              "--n-text-color-pressed-checkable": textColorPressedCheckable
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("tag", vue.computed(() => {
            let hash = "";
            const {
              type,
              size: size2,
              color: {
                color,
                textColor
              } = {}
            } = props;
            hash += type[0];
            hash += size2[0];
            if (color) {
              hash += `a${color2Class(color)}`;
            }
            if (textColor) {
              hash += `b${color2Class(textColor)}`;
            }
            if (mergedBorderedRef.value) {
              hash += "c";
            }
            return hash;
          }), cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, tagPublicMethods), {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            contentRef,
            mergedBordered: mergedBorderedRef,
            handleClick: handleClick2,
            handleCloseClick,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a, _b;
          const {
            mergedClsPrefix,
            rtlEnabled,
            closable,
            color: {
              borderColor
            } = {},
            round,
            onRender,
            $slots
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const avatarNode = resolveWrappedSlot($slots.avatar, (children) => children && vue.h("div", {
            class: `${mergedClsPrefix}-tag__avatar`
          }, children));
          const iconNode = resolveWrappedSlot($slots.icon, (children) => children && vue.h("div", {
            class: `${mergedClsPrefix}-tag__icon`
          }, children));
          return vue.h("div", {
            class: [`${mergedClsPrefix}-tag`, this.themeClass, {
              [`${mergedClsPrefix}-tag--rtl`]: rtlEnabled,
              [`${mergedClsPrefix}-tag--strong`]: this.strong,
              [`${mergedClsPrefix}-tag--disabled`]: this.disabled,
              [`${mergedClsPrefix}-tag--checkable`]: this.checkable,
              [`${mergedClsPrefix}-tag--checked`]: this.checkable && this.checked,
              [`${mergedClsPrefix}-tag--round`]: round,
              [`${mergedClsPrefix}-tag--avatar`]: avatarNode,
              [`${mergedClsPrefix}-tag--icon`]: iconNode,
              [`${mergedClsPrefix}-tag--closable`]: closable
            }],
            style: this.cssVars,
            onClick: this.handleClick,
            onMouseenter: this.onMouseenter,
            onMouseleave: this.onMouseleave
          }, iconNode || avatarNode, vue.h("span", {
            class: `${mergedClsPrefix}-tag__content`,
            ref: "contentRef"
          }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)), !this.checkable && closable ? vue.h(NBaseClose, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-tag__close`,
            disabled: this.disabled,
            onClick: this.handleCloseClick,
            focusable: this.internalCloseFocusable,
            round,
            isButtonTag: this.internalCloseIsButtonTag,
            absolute: true
          }) : null, !this.checkable && this.mergedBordered ? vue.h("div", {
            class: `${mergedClsPrefix}-tag__border`,
            style: {
              borderColor
            }
          }) : null);
        }
      });
      const NBaseSuffix = vue.defineComponent({
        name: "InternalSelectionSuffix",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          showArrow: {
            type: Boolean,
            default: void 0
          },
          showClear: {
            type: Boolean,
            default: void 0
          },
          loading: {
            type: Boolean,
            default: false
          },
          onClear: Function
        },
        setup(props, {
          slots
        }) {
          return () => {
            const {
              clsPrefix
            } = props;
            return vue.h(NBaseLoading, {
              clsPrefix,
              class: `${clsPrefix}-base-suffix`,
              strokeWidth: 24,
              scale: 0.85,
              show: props.loading
            }, {
              default: () => props.showArrow ? vue.h(NBaseClear, {
                clsPrefix,
                show: props.showClear,
                onClear: props.onClear
              }, {
                placeholder: () => vue.h(NBaseIcon, {
                  clsPrefix,
                  class: `${clsPrefix}-base-suffix__arrow`
                }, {
                  default: () => resolveSlot(slots.default, () => [vue.h(ChevronDownIcon, null)])
                })
              }) : null
            });
          };
        }
      });
      const commonVariables$a = {
        paddingSingle: "0 26px 0 12px",
        paddingMultiple: "3px 26px 0 12px",
        clearSize: "16px",
        arrowSize: "16px"
      };
      function self$o(vars) {
        const {
          borderRadius,
          textColor2,
          textColorDisabled,
          inputColor,
          inputColorDisabled,
          primaryColor,
          primaryColorHover,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          borderColor,
          iconColor,
          iconColorDisabled,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontWeight
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$a), {
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius,
          fontWeight,
textColor: textColor2,
          textColorDisabled,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorActive: inputColor,
          border: `1px solid ${borderColor}`,
          borderHover: `1px solid ${primaryColorHover}`,
          borderActive: `1px solid ${primaryColor}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowHover: "none",
          boxShadowActive: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
          boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
          caretColor: primaryColor,
          arrowColor: iconColor,
          arrowColorDisabled: iconColorDisabled,
          loadingColor: primaryColor,
borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          borderActiveWarning: `1px solid ${warningColor}`,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowHoverWarning: "none",
          boxShadowActiveWarning: `0 0 0 2px ${changeColor(warningColor, {
          alpha: 0.2
        })}`,
          boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
          alpha: 0.2
        })}`,
          colorActiveWarning: inputColor,
          caretColorWarning: warningColor,
borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          borderActiveError: `1px solid ${errorColor}`,
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowHoverError: "none",
          boxShadowActiveError: `0 0 0 2px ${changeColor(errorColor, {
          alpha: 0.2
        })}`,
          boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
          alpha: 0.2
        })}`,
          colorActiveError: inputColor,
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed
        });
      }
      const internalSelectionLight = createTheme({
        name: "InternalSelection",
        common: derived,
        peers: {
          Popover: popoverLight
        },
        self: self$o
      });
      const style$o = c$1([cB("base-selection", `
 --n-padding-single: var(--n-padding-single-top) var(--n-padding-single-right) var(--n-padding-single-bottom) var(--n-padding-single-left);
 --n-padding-multiple: var(--n-padding-multiple-top) var(--n-padding-multiple-right) var(--n-padding-multiple-bottom) var(--n-padding-multiple-left);
 position: relative;
 z-index: auto;
 box-shadow: none;
 width: 100%;
 max-width: 100%;
 display: inline-block;
 vertical-align: bottom;
 border-radius: var(--n-border-radius);
 min-height: var(--n-height);
 line-height: 1.5;
 font-size: var(--n-font-size);
 `, [cB("base-loading", `
 color: var(--n-loading-color);
 `), cB("base-selection-tags", "min-height: var(--n-height);"), cE("border, state-border", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border: var(--n-border);
 border-radius: inherit;
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `), cE("state-border", `
 z-index: 1;
 border-color: #0000;
 `), cB("base-suffix", `
 cursor: pointer;
 position: absolute;
 top: 50%;
 transform: translateY(-50%);
 right: 10px;
 `, [cE("arrow", `
 font-size: var(--n-arrow-size);
 color: var(--n-arrow-color);
 transition: color .3s var(--n-bezier);
 `)]), cB("base-selection-overlay", `
 display: flex;
 align-items: center;
 white-space: nowrap;
 pointer-events: none;
 position: absolute;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 padding: var(--n-padding-single);
 transition: color .3s var(--n-bezier);
 `, [cE("wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 overflow: hidden;
 text-overflow: ellipsis;
 `)]), cB("base-selection-placeholder", `
 color: var(--n-placeholder-color);
 `, [cE("inner", `
 max-width: 100%;
 overflow: hidden;
 `)]), cB("base-selection-tags", `
 cursor: pointer;
 outline: none;
 box-sizing: border-box;
 position: relative;
 z-index: auto;
 display: flex;
 padding: var(--n-padding-multiple);
 flex-wrap: wrap;
 align-items: center;
 width: 100%;
 vertical-align: bottom;
 background-color: var(--n-color);
 border-radius: inherit;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("base-selection-label", `
 height: var(--n-height);
 display: inline-flex;
 width: 100%;
 vertical-align: bottom;
 cursor: pointer;
 outline: none;
 z-index: auto;
 box-sizing: border-box;
 position: relative;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 border-radius: inherit;
 background-color: var(--n-color);
 align-items: center;
 `, [cB("base-selection-input", `
 font-size: inherit;
 line-height: inherit;
 outline: none;
 cursor: pointer;
 box-sizing: border-box;
 border:none;
 width: 100%;
 padding: var(--n-padding-single);
 background-color: #0000;
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 caret-color: var(--n-caret-color);
 `, [cE("content", `
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap; 
 `)]), cE("render-label", `
 color: var(--n-text-color);
 `)]), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
 box-shadow: var(--n-box-shadow-hover);
 border: var(--n-border-hover);
 `)]), cM("focus", [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus);
 border: var(--n-border-focus);
 `)]), cM("active", [cE("state-border", `
 box-shadow: var(--n-box-shadow-active);
 border: var(--n-border-active);
 `), cB("base-selection-label", "background-color: var(--n-color-active);"), cB("base-selection-tags", "background-color: var(--n-color-active);")])]), cM("disabled", "cursor: not-allowed;", [cE("arrow", `
 color: var(--n-arrow-color-disabled);
 `), cB("base-selection-label", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cB("base-selection-input", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 `), cE("render-label", `
 color: var(--n-text-color-disabled);
 `)]), cB("base-selection-tags", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `), cB("base-selection-placeholder", `
 cursor: not-allowed;
 color: var(--n-placeholder-color-disabled);
 `)]), cB("base-selection-input-tag", `
 height: calc(var(--n-height) - 6px);
 line-height: calc(var(--n-height) - 6px);
 outline: none;
 display: none;
 position: relative;
 margin-bottom: 3px;
 max-width: 100%;
 vertical-align: bottom;
 `, [cE("input", `
 font-size: inherit;
 font-family: inherit;
 min-width: 1px;
 padding: 0;
 background-color: #0000;
 outline: none;
 border: none;
 max-width: 100%;
 overflow: hidden;
 width: 1em;
 line-height: inherit;
 cursor: pointer;
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 `), cE("mirror", `
 position: absolute;
 left: 0;
 top: 0;
 white-space: pre;
 visibility: hidden;
 user-select: none;
 -webkit-user-select: none;
 opacity: 0;
 `)]), ["warning", "error"].map((status) => cM(`${status}-status`, [cE("state-border", `border: var(--n-border-${status});`), cNotM("disabled", [c$1("&:hover", [cE("state-border", `
 box-shadow: var(--n-box-shadow-hover-${status});
 border: var(--n-border-hover-${status});
 `)]), cM("active", [cE("state-border", `
 box-shadow: var(--n-box-shadow-active-${status});
 border: var(--n-border-active-${status});
 `), cB("base-selection-label", `background-color: var(--n-color-active-${status});`), cB("base-selection-tags", `background-color: var(--n-color-active-${status});`)]), cM("focus", [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))]), cB("base-selection-popover", `
 margin-bottom: -3px;
 display: flex;
 flex-wrap: wrap;
 margin-right: -8px;
 `), cB("base-selection-tag-wrapper", `
 max-width: 100%;
 display: inline-flex;
 padding: 0 7px 3px 0;
 `, [c$1("&:last-child", "padding-right: 0;"), cB("tag", `
 font-size: 14px;
 max-width: 100%;
 `, [cE("content", `
 line-height: 1.25;
 text-overflow: ellipsis;
 overflow: hidden;
 `)])])]);
      const NInternalSelection = vue.defineComponent({
        name: "InternalSelection",
        props: Object.assign(Object.assign({}, useTheme.props), {
          clsPrefix: {
            type: String,
            required: true
          },
          bordered: {
            type: Boolean,
            default: void 0
          },
          active: Boolean,
          pattern: {
            type: String,
            default: ""
          },
          placeholder: String,
          selectedOption: {
            type: Object,
            default: null
          },
          selectedOptions: {
            type: Array,
            default: null
          },
          labelField: {
            type: String,
            default: "label"
          },
          valueField: {
            type: String,
            default: "value"
          },
          multiple: Boolean,
          filterable: Boolean,
          clearable: Boolean,
          disabled: Boolean,
          size: {
            type: String,
            default: "medium"
          },
          loading: Boolean,
          autofocus: Boolean,
          showArrow: {
            type: Boolean,
            default: true
          },
          inputProps: Object,
          focused: Boolean,
          renderTag: Function,
          onKeydown: Function,
          onClick: Function,
          onBlur: Function,
          onFocus: Function,
          onDeleteOption: Function,
          maxTagCount: [String, Number],
          ellipsisTagPopoverProps: Object,
          onClear: Function,
          onPatternInput: Function,
          onPatternFocus: Function,
          onPatternBlur: Function,
          renderLabel: Function,
          status: String,
          inlineThemeDisabled: Boolean,
          ignoreComposition: {
            type: Boolean,
            default: true
          },
          onResize: Function
        }),
        setup(props) {
          const {
            mergedClsPrefixRef,
            mergedRtlRef
          } = useConfig(props);
          const rtlEnabledRef = useRtl("InternalSelection", mergedRtlRef, mergedClsPrefixRef);
          const patternInputMirrorRef = vue.ref(null);
          const patternInputRef = vue.ref(null);
          const selfRef = vue.ref(null);
          const multipleElRef = vue.ref(null);
          const singleElRef = vue.ref(null);
          const patternInputWrapperRef = vue.ref(null);
          const counterRef = vue.ref(null);
          const counterWrapperRef = vue.ref(null);
          const overflowRef = vue.ref(null);
          const inputTagElRef = vue.ref(null);
          const showTagsPopoverRef = vue.ref(false);
          const patternInputFocusedRef = vue.ref(false);
          const hoverRef = vue.ref(false);
          const themeRef = useTheme("InternalSelection", "-internal-selection", style$o, internalSelectionLight, props, vue.toRef(props, "clsPrefix"));
          const mergedClearableRef = vue.computed(() => {
            return props.clearable && !props.disabled && (hoverRef.value || props.active);
          });
          const filterablePlaceholderRef = vue.computed(() => {
            return props.selectedOption ? props.renderTag ? props.renderTag({
              option: props.selectedOption,
              handleClose: () => {
              }
            }) : props.renderLabel ? props.renderLabel(props.selectedOption, true) : render(props.selectedOption[props.labelField], props.selectedOption, true) : props.placeholder;
          });
          const labelRef = vue.computed(() => {
            const option = props.selectedOption;
            if (!option) return void 0;
            return option[props.labelField];
          });
          const selectedRef = vue.computed(() => {
            if (props.multiple) {
              return !!(Array.isArray(props.selectedOptions) && props.selectedOptions.length);
            } else {
              return props.selectedOption !== null;
            }
          });
          function syncMirrorWidth() {
            var _a;
            const {
              value: patternInputMirrorEl
            } = patternInputMirrorRef;
            if (patternInputMirrorEl) {
              const {
                value: patternInputEl
              } = patternInputRef;
              if (patternInputEl) {
                patternInputEl.style.width = `${patternInputMirrorEl.offsetWidth}px`;
                if (props.maxTagCount !== "responsive") {
                  (_a = overflowRef.value) === null || _a === void 0 ? void 0 : _a.sync({
                    showAllItemsBeforeCalculate: false
                  });
                }
              }
            }
          }
          function hideInputTag() {
            const {
              value: inputTagEl
            } = inputTagElRef;
            if (inputTagEl) inputTagEl.style.display = "none";
          }
          function showInputTag() {
            const {
              value: inputTagEl
            } = inputTagElRef;
            if (inputTagEl) inputTagEl.style.display = "inline-block";
          }
          vue.watch(vue.toRef(props, "active"), (value) => {
            if (!value) hideInputTag();
          });
          vue.watch(vue.toRef(props, "pattern"), () => {
            if (props.multiple) {
              void vue.nextTick(syncMirrorWidth);
            }
          });
          function doFocus(e) {
            const {
              onFocus
            } = props;
            if (onFocus) onFocus(e);
          }
          function doBlur(e) {
            const {
              onBlur
            } = props;
            if (onBlur) onBlur(e);
          }
          function doDeleteOption(value) {
            const {
              onDeleteOption
            } = props;
            if (onDeleteOption) onDeleteOption(value);
          }
          function doClear(e) {
            const {
              onClear
            } = props;
            if (onClear) onClear(e);
          }
          function doPatternInput(value) {
            const {
              onPatternInput
            } = props;
            if (onPatternInput) onPatternInput(value);
          }
          function handleFocusin(e) {
            var _a;
            if (!e.relatedTarget || !((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget))) {
              doFocus(e);
            }
          }
          function handleFocusout(e) {
            var _a;
            if ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.contains(e.relatedTarget)) return;
            doBlur(e);
          }
          function handleClear(e) {
            doClear(e);
          }
          function handleMouseEnter() {
            hoverRef.value = true;
          }
          function handleMouseLeave() {
            hoverRef.value = false;
          }
          function handleMouseDown(e) {
            if (!props.active || !props.filterable) return;
            if (e.target === patternInputRef.value) return;
            e.preventDefault();
          }
          function handleDeleteOption(option) {
            doDeleteOption(option);
          }
          const isComposingRef2 = vue.ref(false);
          function handlePatternKeyDown(e) {
            if (e.key === "Backspace" && !isComposingRef2.value) {
              if (!props.pattern.length) {
                const {
                  selectedOptions
                } = props;
                if (selectedOptions === null || selectedOptions === void 0 ? void 0 : selectedOptions.length) {
                  handleDeleteOption(selectedOptions[selectedOptions.length - 1]);
                }
              }
            }
          }
          let cachedInputEvent = null;
          function handlePatternInputInput(e) {
            const {
              value: patternInputMirrorEl
            } = patternInputMirrorRef;
            if (patternInputMirrorEl) {
              const inputText = e.target.value;
              patternInputMirrorEl.textContent = inputText;
              syncMirrorWidth();
            }
            if (props.ignoreComposition) {
              if (!isComposingRef2.value) {
                doPatternInput(e);
              } else {
                cachedInputEvent = e;
              }
            } else {
              doPatternInput(e);
            }
          }
          function handleCompositionStart() {
            isComposingRef2.value = true;
          }
          function handleCompositionEnd() {
            isComposingRef2.value = false;
            if (props.ignoreComposition) {
              doPatternInput(cachedInputEvent);
            }
            cachedInputEvent = null;
          }
          function handlePatternInputFocus(e) {
            var _a;
            patternInputFocusedRef.value = true;
            (_a = props.onPatternFocus) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function handlePatternInputBlur(e) {
            var _a;
            patternInputFocusedRef.value = false;
            (_a = props.onPatternBlur) === null || _a === void 0 ? void 0 : _a.call(props, e);
          }
          function blur() {
            var _a, _b;
            if (props.filterable) {
              patternInputFocusedRef.value = false;
              (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.blur();
              (_b = patternInputRef.value) === null || _b === void 0 ? void 0 : _b.blur();
            } else if (props.multiple) {
              const {
                value: multipleEl
              } = multipleElRef;
              multipleEl === null || multipleEl === void 0 ? void 0 : multipleEl.blur();
            } else {
              const {
                value: singleEl
              } = singleElRef;
              singleEl === null || singleEl === void 0 ? void 0 : singleEl.blur();
            }
          }
          function focus() {
            var _a, _b, _c;
            if (props.filterable) {
              patternInputFocusedRef.value = false;
              (_a = patternInputWrapperRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            } else if (props.multiple) {
              (_b = multipleElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
            } else {
              (_c = singleElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
            }
          }
          function focusInput() {
            const {
              value: patternInputEl
            } = patternInputRef;
            if (patternInputEl) {
              showInputTag();
              patternInputEl.focus();
            }
          }
          function blurInput() {
            const {
              value: patternInputEl
            } = patternInputRef;
            if (patternInputEl) {
              patternInputEl.blur();
            }
          }
          function updateCounter(count) {
            const {
              value
            } = counterRef;
            if (value) {
              value.setTextContent(`+${count}`);
            }
          }
          function getCounter() {
            const {
              value
            } = counterWrapperRef;
            return value;
          }
          function getTail() {
            return patternInputRef.value;
          }
          let enterTimerId = null;
          function clearEnterTimer() {
            if (enterTimerId !== null) window.clearTimeout(enterTimerId);
          }
          function handleMouseEnterCounter() {
            if (props.active) return;
            clearEnterTimer();
            enterTimerId = window.setTimeout(() => {
              if (selectedRef.value) {
                showTagsPopoverRef.value = true;
              }
            }, 100);
          }
          function handleMouseLeaveCounter() {
            clearEnterTimer();
          }
          function onPopoverUpdateShow(show) {
            if (!show) {
              clearEnterTimer();
              showTagsPopoverRef.value = false;
            }
          }
          vue.watch(selectedRef, (value) => {
            if (!value) {
              showTagsPopoverRef.value = false;
            }
          });
          vue.onMounted(() => {
            vue.watchEffect(() => {
              const patternInputWrapperEl = patternInputWrapperRef.value;
              if (!patternInputWrapperEl) return;
              if (props.disabled) {
                patternInputWrapperEl.removeAttribute("tabindex");
              } else {
                patternInputWrapperEl.tabIndex = patternInputFocusedRef.value ? -1 : 0;
              }
            });
          });
          useOnResize(selfRef, props.onResize);
          const {
            inlineThemeDisabled
          } = props;
          const cssVarsRef = vue.computed(() => {
            const {
              size: size2
            } = props;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                fontWeight,
                borderRadius,
                color,
                placeholderColor,
                textColor,
                paddingSingle,
                paddingMultiple,
                caretColor,
                colorDisabled,
                textColorDisabled,
                placeholderColorDisabled,
                colorActive,
                boxShadowFocus,
                boxShadowActive,
                boxShadowHover,
                border,
                borderFocus,
                borderHover,
                borderActive,
                arrowColor,
                arrowColorDisabled,
                loadingColor,
colorActiveWarning,
                boxShadowFocusWarning,
                boxShadowActiveWarning,
                boxShadowHoverWarning,
                borderWarning,
                borderFocusWarning,
                borderHoverWarning,
                borderActiveWarning,
colorActiveError,
                boxShadowFocusError,
                boxShadowActiveError,
                boxShadowHoverError,
                borderError,
                borderFocusError,
                borderHoverError,
                borderActiveError,
clearColor,
                clearColorHover,
                clearColorPressed,
                clearSize,
arrowSize: arrowSize2,
                [createKey("height", size2)]: height,
                [createKey("fontSize", size2)]: fontSize2
              }
            } = themeRef.value;
            const paddingSingleDiscrete = getMargin(paddingSingle);
            const paddingMultipleDiscrete = getMargin(paddingMultiple);
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border": border,
              "--n-border-active": borderActive,
              "--n-border-focus": borderFocus,
              "--n-border-hover": borderHover,
              "--n-border-radius": borderRadius,
              "--n-box-shadow-active": boxShadowActive,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-box-shadow-hover": boxShadowHover,
              "--n-caret-color": caretColor,
              "--n-color": color,
              "--n-color-active": colorActive,
              "--n-color-disabled": colorDisabled,
              "--n-font-size": fontSize2,
              "--n-height": height,
              "--n-padding-single-top": paddingSingleDiscrete.top,
              "--n-padding-multiple-top": paddingMultipleDiscrete.top,
              "--n-padding-single-right": paddingSingleDiscrete.right,
              "--n-padding-multiple-right": paddingMultipleDiscrete.right,
              "--n-padding-single-left": paddingSingleDiscrete.left,
              "--n-padding-multiple-left": paddingMultipleDiscrete.left,
              "--n-padding-single-bottom": paddingSingleDiscrete.bottom,
              "--n-padding-multiple-bottom": paddingMultipleDiscrete.bottom,
              "--n-placeholder-color": placeholderColor,
              "--n-placeholder-color-disabled": placeholderColorDisabled,
              "--n-text-color": textColor,
              "--n-text-color-disabled": textColorDisabled,
              "--n-arrow-color": arrowColor,
              "--n-arrow-color-disabled": arrowColorDisabled,
              "--n-loading-color": loadingColor,
"--n-color-active-warning": colorActiveWarning,
              "--n-box-shadow-focus-warning": boxShadowFocusWarning,
              "--n-box-shadow-active-warning": boxShadowActiveWarning,
              "--n-box-shadow-hover-warning": boxShadowHoverWarning,
              "--n-border-warning": borderWarning,
              "--n-border-focus-warning": borderFocusWarning,
              "--n-border-hover-warning": borderHoverWarning,
              "--n-border-active-warning": borderActiveWarning,
"--n-color-active-error": colorActiveError,
              "--n-box-shadow-focus-error": boxShadowFocusError,
              "--n-box-shadow-active-error": boxShadowActiveError,
              "--n-box-shadow-hover-error": boxShadowHoverError,
              "--n-border-error": borderError,
              "--n-border-focus-error": borderFocusError,
              "--n-border-hover-error": borderHoverError,
              "--n-border-active-error": borderActiveError,
"--n-clear-size": clearSize,
              "--n-clear-color": clearColor,
              "--n-clear-color-hover": clearColorHover,
              "--n-clear-color-pressed": clearColorPressed,
"--n-arrow-size": arrowSize2,
"--n-font-weight": fontWeight
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("internal-selection", vue.computed(() => {
            return props.size[0];
          }), cssVarsRef, props) : void 0;
          return {
            mergedTheme: themeRef,
            mergedClearable: mergedClearableRef,
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            patternInputFocused: patternInputFocusedRef,
            filterablePlaceholder: filterablePlaceholderRef,
            label: labelRef,
            selected: selectedRef,
            showTagsPanel: showTagsPopoverRef,
            isComposing: isComposingRef2,
counterRef,
            counterWrapperRef,
            patternInputMirrorRef,
            patternInputRef,
            selfRef,
            multipleElRef,
            singleElRef,
            patternInputWrapperRef,
            overflowRef,
            inputTagElRef,
            handleMouseDown,
            handleFocusin,
            handleClear,
            handleMouseEnter,
            handleMouseLeave,
            handleDeleteOption,
            handlePatternKeyDown,
            handlePatternInputInput,
            handlePatternInputBlur,
            handlePatternInputFocus,
            handleMouseEnterCounter,
            handleMouseLeaveCounter,
            handleFocusout,
            handleCompositionEnd,
            handleCompositionStart,
            onPopoverUpdateShow,
            focus,
            focusInput,
            blur,
            blurInput,
            updateCounter,
            getCounter,
            getTail,
            renderLabel: props.renderLabel,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const {
            status,
            multiple,
            size: size2,
            disabled,
            filterable,
            maxTagCount,
            bordered,
            clsPrefix,
            ellipsisTagPopoverProps,
            onRender,
            renderTag,
            renderLabel
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const maxTagCountResponsive = maxTagCount === "responsive";
          const maxTagCountNumeric = typeof maxTagCount === "number";
          const useMaxTagCount = maxTagCountResponsive || maxTagCountNumeric;
          const suffix2 = vue.h(Wrapper, null, {
            default: () => vue.h(NBaseSuffix, {
              clsPrefix,
              loading: this.loading,
              showArrow: this.showArrow,
              showClear: this.mergedClearable && this.selected,
              onClear: this.handleClear
            }, {
              default: () => {
                var _a, _b;
                return (_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a);
              }
            })
          });
          let body;
          if (multiple) {
            const {
              labelField
            } = this;
            const createTag = (option) => vue.h("div", {
              class: `${clsPrefix}-base-selection-tag-wrapper`,
              key: option.value
            }, renderTag ? renderTag({
              option,
              handleClose: () => {
                this.handleDeleteOption(option);
              }
            }) : vue.h(NTag, {
              size: size2,
              closable: !option.disabled,
              disabled,
              onClose: () => {
                this.handleDeleteOption(option);
              },
              internalCloseIsButtonTag: false,
              internalCloseFocusable: false
            }, {
              default: () => renderLabel ? renderLabel(option, true) : render(option[labelField], option, true)
            }));
            const createOriginalTagNodes = () => (maxTagCountNumeric ? this.selectedOptions.slice(0, maxTagCount) : this.selectedOptions).map(createTag);
            const input = filterable ? vue.h("div", {
              class: `${clsPrefix}-base-selection-input-tag`,
              ref: "inputTagElRef",
              key: "__input-tag__"
            }, vue.h("input", Object.assign({}, this.inputProps, {
              ref: "patternInputRef",
              tabindex: -1,
              disabled,
              value: this.pattern,
              autofocus: this.autofocus,
              class: `${clsPrefix}-base-selection-input-tag__input`,
              onBlur: this.handlePatternInputBlur,
              onFocus: this.handlePatternInputFocus,
              onKeydown: this.handlePatternKeyDown,
              onInput: this.handlePatternInputInput,
              onCompositionstart: this.handleCompositionStart,
              onCompositionend: this.handleCompositionEnd
            })), vue.h("span", {
              ref: "patternInputMirrorRef",
              class: `${clsPrefix}-base-selection-input-tag__mirror`
            }, this.pattern)) : null;
            const renderCounter = maxTagCountResponsive ? () => vue.h("div", {
              class: `${clsPrefix}-base-selection-tag-wrapper`,
              ref: "counterWrapperRef"
            }, vue.h(NTag, {
              size: size2,
              ref: "counterRef",
              onMouseenter: this.handleMouseEnterCounter,
              onMouseleave: this.handleMouseLeaveCounter,
              disabled
            })) : void 0;
            let counter;
            if (maxTagCountNumeric) {
              const rest = this.selectedOptions.length - maxTagCount;
              if (rest > 0) {
                counter = vue.h("div", {
                  class: `${clsPrefix}-base-selection-tag-wrapper`,
                  key: "__counter__"
                }, vue.h(NTag, {
                  size: size2,
                  ref: "counterRef",
                  onMouseenter: this.handleMouseEnterCounter,
                  disabled
                }, {
                  default: () => `+${rest}`
                }));
              }
            }
            const tags = maxTagCountResponsive ? filterable ? vue.h(VOverflow, {
              ref: "overflowRef",
              updateCounter: this.updateCounter,
              getCounter: this.getCounter,
              getTail: this.getTail,
              style: {
                width: "100%",
                display: "flex",
                overflow: "hidden"
              }
            }, {
              default: createOriginalTagNodes,
              counter: renderCounter,
              tail: () => input
            }) : vue.h(VOverflow, {
              ref: "overflowRef",
              updateCounter: this.updateCounter,
              getCounter: this.getCounter,
              style: {
                width: "100%",
                display: "flex",
                overflow: "hidden"
              }
            }, {
              default: createOriginalTagNodes,
              counter: renderCounter
            }) : maxTagCountNumeric && counter ? createOriginalTagNodes().concat(counter) : createOriginalTagNodes();
            const renderPopover = useMaxTagCount ? () => vue.h("div", {
              class: `${clsPrefix}-base-selection-popover`
            }, maxTagCountResponsive ? createOriginalTagNodes() : this.selectedOptions.map(createTag)) : void 0;
            const popoverProps2 = useMaxTagCount ? Object.assign({
              show: this.showTagsPanel,
              trigger: "hover",
              overlap: true,
              placement: "top",
              width: "trigger",
              onUpdateShow: this.onPopoverUpdateShow,
              theme: this.mergedTheme.peers.Popover,
              themeOverrides: this.mergedTheme.peerOverrides.Popover
            }, ellipsisTagPopoverProps) : null;
            const showPlaceholder = this.selected ? false : this.active ? !this.pattern && !this.isComposing : true;
            const placeholder = showPlaceholder ? vue.h("div", {
              class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`
            }, vue.h("div", {
              class: `${clsPrefix}-base-selection-placeholder__inner`
            }, this.placeholder)) : null;
            const popoverTrigger = filterable ? vue.h("div", {
              ref: "patternInputWrapperRef",
              class: `${clsPrefix}-base-selection-tags`
            }, tags, maxTagCountResponsive ? null : input, suffix2) : vue.h("div", {
              ref: "multipleElRef",
              class: `${clsPrefix}-base-selection-tags`,
              tabindex: disabled ? void 0 : 0
            }, tags, suffix2);
            body = vue.h(vue.Fragment, null, useMaxTagCount ? vue.h(NPopover, Object.assign({}, popoverProps2, {
              scrollable: true,
              style: "max-height: calc(var(--v-target-height) * 6.6);"
            }), {
              trigger: () => popoverTrigger,
              default: renderPopover
            }) : popoverTrigger, placeholder);
          } else {
            if (filterable) {
              const hasInput = this.pattern || this.isComposing;
              const showPlaceholder = this.active ? !hasInput : !this.selected;
              const showSelectedLabel = this.active ? false : this.selected;
              body = vue.h("div", {
                ref: "patternInputWrapperRef",
                class: `${clsPrefix}-base-selection-label`,
                title: this.patternInputFocused ? void 0 : getTitleAttribute(this.label)
              }, vue.h("input", Object.assign({}, this.inputProps, {
                ref: "patternInputRef",
                class: `${clsPrefix}-base-selection-input`,
                value: this.active ? this.pattern : "",
                placeholder: "",
                readonly: disabled,
                disabled,
                tabindex: -1,
                autofocus: this.autofocus,
                onFocus: this.handlePatternInputFocus,
                onBlur: this.handlePatternInputBlur,
                onInput: this.handlePatternInputInput,
                onCompositionstart: this.handleCompositionStart,
                onCompositionend: this.handleCompositionEnd
              })), showSelectedLabel ? vue.h("div", {
                class: `${clsPrefix}-base-selection-label__render-label ${clsPrefix}-base-selection-overlay`,
                key: "input"
              }, vue.h("div", {
                class: `${clsPrefix}-base-selection-overlay__wrapper`
              }, renderTag ? renderTag({
                option: this.selectedOption,
                handleClose: () => {
                }
              }) : renderLabel ? renderLabel(this.selectedOption, true) : render(this.label, this.selectedOption, true))) : null, showPlaceholder ? vue.h("div", {
                class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`,
                key: "placeholder"
              }, vue.h("div", {
                class: `${clsPrefix}-base-selection-overlay__wrapper`
              }, this.filterablePlaceholder)) : null, suffix2);
            } else {
              body = vue.h("div", {
                ref: "singleElRef",
                class: `${clsPrefix}-base-selection-label`,
                tabindex: this.disabled ? void 0 : 0
              }, this.label !== void 0 ? vue.h("div", {
                class: `${clsPrefix}-base-selection-input`,
                title: getTitleAttribute(this.label),
                key: "input"
              }, vue.h("div", {
                class: `${clsPrefix}-base-selection-input__content`
              }, renderTag ? renderTag({
                option: this.selectedOption,
                handleClose: () => {
                }
              }) : renderLabel ? renderLabel(this.selectedOption, true) : render(this.label, this.selectedOption, true))) : vue.h("div", {
                class: `${clsPrefix}-base-selection-placeholder ${clsPrefix}-base-selection-overlay`,
                key: "placeholder"
              }, vue.h("div", {
                class: `${clsPrefix}-base-selection-placeholder__inner`
              }, this.placeholder)), suffix2);
            }
          }
          return vue.h("div", {
            ref: "selfRef",
            class: [`${clsPrefix}-base-selection`, this.rtlEnabled && `${clsPrefix}-base-selection--rtl`, this.themeClass, status && `${clsPrefix}-base-selection--${status}-status`, {
              [`${clsPrefix}-base-selection--active`]: this.active,
              [`${clsPrefix}-base-selection--selected`]: this.selected || this.active && this.pattern,
              [`${clsPrefix}-base-selection--disabled`]: this.disabled,
              [`${clsPrefix}-base-selection--multiple`]: this.multiple,


[`${clsPrefix}-base-selection--focus`]: this.focused
            }],
            style: this.cssVars,
            onClick: this.onClick,
            onMouseenter: this.handleMouseEnter,
            onMouseleave: this.handleMouseLeave,
            onKeydown: this.onKeydown,
            onFocusin: this.handleFocusin,
            onFocusout: this.handleFocusout,
            onMousedown: this.handleMouseDown
          }, body, bordered ? vue.h("div", {
            class: `${clsPrefix}-base-selection__border`
          }) : null, bordered ? vue.h("div", {
            class: `${clsPrefix}-base-selection__state-border`
          }) : null);
        }
      });
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut$2
      } = commonVariables$e;
      function fadeInWidthExpandTransition({
        duration: duration2 = ".2s",
        delay = ".1s"
      } = {}) {
        return [c$1("&.fade-in-width-expand-transition-leave-from, &.fade-in-width-expand-transition-enter-to", {
          opacity: 1
        }), c$1("&.fade-in-width-expand-transition-leave-to, &.fade-in-width-expand-transition-enter-from", `
 opacity: 0!important;
 margin-left: 0!important;
 margin-right: 0!important;
 `), c$1("&.fade-in-width-expand-transition-leave-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$2},
 max-width ${duration2} ${cubicBezierEaseInOut$2} ${delay},
 margin-left ${duration2} ${cubicBezierEaseInOut$2} ${delay},
 margin-right ${duration2} ${cubicBezierEaseInOut$2} ${delay};
 `), c$1("&.fade-in-width-expand-transition-enter-active", `
 overflow: hidden;
 transition:
 opacity ${duration2} ${cubicBezierEaseInOut$2} ${delay},
 max-width ${duration2} ${cubicBezierEaseInOut$2},
 margin-left ${duration2} ${cubicBezierEaseInOut$2},
 margin-right ${duration2} ${cubicBezierEaseInOut$2};
 `)];
      }
      const style$n = cB("base-wave", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border-radius: inherit;
`);
      const NBaseWave = vue.defineComponent({
        name: "BaseWave",
        props: {
          clsPrefix: {
            type: String,
            required: true
          }
        },
        setup(props) {
          useStyle("-base-wave", style$n, vue.toRef(props, "clsPrefix"));
          const selfRef = vue.ref(null);
          const activeRef = vue.ref(false);
          let animationTimerId = null;
          vue.onBeforeUnmount(() => {
            if (animationTimerId !== null) {
              window.clearTimeout(animationTimerId);
            }
          });
          return {
            active: activeRef,
            selfRef,
            play() {
              if (animationTimerId !== null) {
                window.clearTimeout(animationTimerId);
                activeRef.value = false;
                animationTimerId = null;
              }
              void vue.nextTick(() => {
                var _a;
                void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetHeight);
                activeRef.value = true;
                animationTimerId = window.setTimeout(() => {
                  activeRef.value = false;
                  animationTimerId = null;
                }, 1e3);
              });
            }
          };
        },
        render() {
          const {
            clsPrefix
          } = this;
          return vue.h("div", {
            ref: "selfRef",
            "aria-hidden": true,
            class: [`${clsPrefix}-base-wave`, this.active && `${clsPrefix}-base-wave--active`]
          });
        }
      });
      const {
        cubicBezierEaseInOut: cubicBezierEaseInOut$1,
        cubicBezierEaseOut,
        cubicBezierEaseIn
      } = commonVariables$e;
      function fadeInHeightExpandTransition({
        overflow = "hidden",
        duration: duration2 = ".3s",
        originalTransition = "",
        leavingDelay = "0s",
        foldPadding = false,
        enterToProps = void 0,
        leaveToProps = void 0,
        reverse = false
      } = {}) {
        const enterClass = reverse ? "leave" : "enter";
        const leaveClass = reverse ? "enter" : "leave";
        return [c$1(`&.fade-in-height-expand-transition-${leaveClass}-from,
 &.fade-in-height-expand-transition-${enterClass}-to`, Object.assign(Object.assign({}, enterToProps), {
          opacity: 1
        })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-to,
 &.fade-in-height-expand-transition-${enterClass}-from`, Object.assign(Object.assign({}, leaveToProps), {
          opacity: 0,
          marginTop: "0 !important",
          marginBottom: "0 !important",
          paddingTop: foldPadding ? "0 !important" : void 0,
          paddingBottom: foldPadding ? "0 !important" : void 0
        })), c$1(`&.fade-in-height-expand-transition-${leaveClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 opacity ${duration2} ${cubicBezierEaseOut} ${leavingDelay},
 margin-top ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 margin-bottom ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-top ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay},
 padding-bottom ${duration2} ${cubicBezierEaseInOut$1} ${leavingDelay}
 ${originalTransition ? `,${originalTransition}` : ""}
 `), c$1(`&.fade-in-height-expand-transition-${enterClass}-active`, `
 overflow: ${overflow};
 transition:
 max-height ${duration2} ${cubicBezierEaseInOut$1},
 opacity ${duration2} ${cubicBezierEaseIn},
 margin-top ${duration2} ${cubicBezierEaseInOut$1},
 margin-bottom ${duration2} ${cubicBezierEaseInOut$1},
 padding-top ${duration2} ${cubicBezierEaseInOut$1},
 padding-bottom ${duration2} ${cubicBezierEaseInOut$1}
 ${originalTransition ? `,${originalTransition}` : ""}
 `)];
      }
      const isChrome = isBrowser$1 && "chrome" in window;
      isBrowser$1 && navigator.userAgent.includes("Firefox");
      const isSafari = isBrowser$1 && navigator.userAgent.includes("Safari") && !isChrome;
      const commonVariables$9 = {
        paddingTiny: "0 8px",
        paddingSmall: "0 10px",
        paddingMedium: "0 12px",
        paddingLarge: "0 14px",
        clearSize: "16px"
      };
      function self$n(vars) {
        const {
          textColor2,
          textColor3,
          textColorDisabled,
          primaryColor,
          primaryColorHover,
          inputColor,
          inputColorDisabled,
          borderColor,
          warningColor,
          warningColorHover,
          errorColor,
          errorColorHover,
          borderRadius,
          lineHeight: lineHeight2,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          actionColor,
          clearColor,
          clearColorHover,
          clearColorPressed,
          placeholderColor,
          placeholderColorDisabled,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          fontWeight
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$9), {
          fontWeight,
          countTextColorDisabled: textColorDisabled,
          countTextColor: textColor3,
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          lineHeight: lineHeight2,
          lineHeightTextarea: lineHeight2,
          borderRadius,
          iconSize: "16px",
          groupLabelColor: actionColor,
          groupLabelTextColor: textColor2,
          textColor: textColor2,
          textColorDisabled,
          textDecorationColor: textColor2,
          caretColor: primaryColor,
          placeholderColor,
          placeholderColorDisabled,
          color: inputColor,
          colorDisabled: inputColorDisabled,
          colorFocus: inputColor,
          groupLabelBorder: `1px solid ${borderColor}`,
          border: `1px solid ${borderColor}`,
          borderHover: `1px solid ${primaryColorHover}`,
          borderDisabled: `1px solid ${borderColor}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
          loadingColor: primaryColor,
loadingColorWarning: warningColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          colorFocusWarning: inputColor,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          boxShadowFocusWarning: `0 0 0 2px ${changeColor(warningColor, {
          alpha: 0.2
        })}`,
          caretColorWarning: warningColor,
loadingColorError: errorColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          colorFocusError: inputColor,
          borderFocusError: `1px solid ${errorColorHover}`,
          boxShadowFocusError: `0 0 0 2px ${changeColor(errorColor, {
          alpha: 0.2
        })}`,
          caretColorError: errorColor,
          clearColor,
          clearColorHover,
          clearColorPressed,
          iconColor,
          iconColorDisabled,
          iconColorHover,
          iconColorPressed,
          suffixTextColor: textColor2
        });
      }
      const inputLight = createTheme({
        name: "Input",
        common: derived,
        peers: {
          Scrollbar: scrollbarLight
        },
        self: self$n
      });
      const inputInjectionKey = createInjectionKey("n-input");
      const style$m = cB("input", `
 max-width: 100%;
 cursor: text;
 line-height: 1.5;
 z-index: auto;
 outline: none;
 box-sizing: border-box;
 position: relative;
 display: inline-flex;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color .3s var(--n-bezier);
 font-size: var(--n-font-size);
 font-weight: var(--n-font-weight);
 --n-padding-vertical: calc((var(--n-height) - 1.5 * var(--n-font-size)) / 2);
`, [
cE("input, textarea", `
 overflow: hidden;
 flex-grow: 1;
 position: relative;
 `),
        cE("input-el, textarea-el, input-mirror, textarea-mirror, separator, placeholder", `
 box-sizing: border-box;
 font-size: inherit;
 line-height: 1.5;
 font-family: inherit;
 border: none;
 outline: none;
 background-color: #0000;
 text-align: inherit;
 transition:
 -webkit-text-fill-color .3s var(--n-bezier),
 caret-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 text-decoration-color .3s var(--n-bezier);
 `),
        cE("input-el, textarea-el", `
 -webkit-appearance: none;
 scrollbar-width: none;
 width: 100%;
 min-width: 0;
 text-decoration-color: var(--n-text-decoration-color);
 color: var(--n-text-color);
 caret-color: var(--n-caret-color);
 background-color: transparent;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `), c$1("&::placeholder", `
 color: #0000;
 -webkit-text-fill-color: transparent !important;
 `), c$1("&:-webkit-autofill ~", [cE("placeholder", "display: none;")])]),
        cM("round", [cNotM("textarea", "border-radius: calc(var(--n-height) / 2);")]),
        cE("placeholder", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: hidden;
 color: var(--n-placeholder-color);
 `, [c$1("span", `
 width: 100%;
 display: inline-block;
 `)]),
        cM("textarea", [cE("placeholder", "overflow: visible;")]),
        cNotM("autosize", "width: 100%;"),
        cM("autosize", [cE("textarea-el, input-el", `
 position: absolute;
 top: 0;
 left: 0;
 height: 100%;
 `)]),
cB("input-wrapper", `
 overflow: hidden;
 display: inline-flex;
 flex-grow: 1;
 position: relative;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 `),
        cE("input-mirror", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre;
 pointer-events: none;
 `),
        cE("input-el", `
 padding: 0;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [c$1("&[type=password]::-ms-reveal", "display: none;"), c$1("+", [cE("placeholder", `
 display: flex;
 align-items: center; 
 `)])]),
        cNotM("textarea", [cE("placeholder", "white-space: nowrap;")]),
        cE("eye", `
 display: flex;
 align-items: center;
 justify-content: center;
 transition: color .3s var(--n-bezier);
 `),
cM("textarea", "width: 100%;", [cB("input-word-count", `
 position: absolute;
 right: var(--n-padding-right);
 bottom: var(--n-padding-vertical);
 `), cM("resizable", [cB("input-wrapper", `
 resize: vertical;
 min-height: var(--n-height);
 `)]), cE("textarea-el, textarea-mirror, placeholder", `
 height: 100%;
 padding-left: 0;
 padding-right: 0;
 padding-top: var(--n-padding-vertical);
 padding-bottom: var(--n-padding-vertical);
 word-break: break-word;
 display: inline-block;
 vertical-align: bottom;
 box-sizing: border-box;
 line-height: var(--n-line-height-textarea);
 margin: 0;
 resize: none;
 white-space: pre-wrap;
 scroll-padding-block-end: var(--n-padding-vertical);
 `), cE("textarea-mirror", `
 width: 100%;
 pointer-events: none;
 overflow: hidden;
 visibility: hidden;
 position: static;
 white-space: pre-wrap;
 overflow-wrap: break-word;
 `)]),
cM("pair", [cE("input-el, placeholder", "text-align: center;"), cE("separator", `
 display: flex;
 align-items: center;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 white-space: nowrap;
 `, [cB("icon", `
 color: var(--n-icon-color);
 `), cB("base-icon", `
 color: var(--n-icon-color);
 `)])]),
        cM("disabled", `
 cursor: not-allowed;
 background-color: var(--n-color-disabled);
 `, [cE("border", "border: var(--n-border-disabled);"), cE("input-el, textarea-el", `
 cursor: not-allowed;
 color: var(--n-text-color-disabled);
 text-decoration-color: var(--n-text-color-disabled);
 `), cE("placeholder", "color: var(--n-placeholder-color-disabled);"), cE("separator", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("base-icon", `
 color: var(--n-icon-color-disabled);
 `)]), cB("input-word-count", `
 color: var(--n-count-text-color-disabled);
 `), cE("suffix, prefix", "color: var(--n-text-color-disabled);", [cB("icon", `
 color: var(--n-icon-color-disabled);
 `), cB("internal-icon", `
 color: var(--n-icon-color-disabled);
 `)])]),
        cNotM("disabled", [cE("eye", `
 color: var(--n-icon-color);
 cursor: pointer;
 `, [c$1("&:hover", `
 color: var(--n-icon-color-hover);
 `), c$1("&:active", `
 color: var(--n-icon-color-pressed);
 `)]), c$1("&:hover", [cE("state-border", "border: var(--n-border-hover);")]), cM("focus", "background-color: var(--n-color-focus);", [cE("state-border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]),
        cE("border, state-border", `
 box-sizing: border-box;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 pointer-events: none;
 border-radius: inherit;
 border: var(--n-border);
 transition:
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `),
        cE("state-border", `
 border-color: #0000;
 z-index: 1;
 `),
        cE("prefix", "margin-right: 4px;"),
        cE("suffix", `
 margin-left: 4px;
 `),
        cE("suffix, prefix", `
 transition: color .3s var(--n-bezier);
 flex-wrap: nowrap;
 flex-shrink: 0;
 line-height: var(--n-height);
 white-space: nowrap;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 color: var(--n-suffix-text-color);
 `, [cB("base-loading", `
 font-size: var(--n-icon-size);
 margin: 0 2px;
 color: var(--n-loading-color);
 `), cB("base-clear", `
 font-size: var(--n-icon-size);
 `, [cE("placeholder", [cB("base-icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)])]), c$1(">", [cB("icon", `
 transition: color .3s var(--n-bezier);
 color: var(--n-icon-color);
 font-size: var(--n-icon-size);
 `)]), cB("base-icon", `
 font-size: var(--n-icon-size);
 `)]),
        cB("input-word-count", `
 pointer-events: none;
 line-height: 1.5;
 font-size: .85em;
 color: var(--n-count-text-color);
 transition: color .3s var(--n-bezier);
 margin-left: 4px;
 font-variant: tabular-nums;
 `),
        ["warning", "error"].map((status) => cM(`${status}-status`, [cNotM("disabled", [cB("base-loading", `
 color: var(--n-loading-color-${status})
 `), cE("input-el, textarea-el", `
 caret-color: var(--n-caret-color-${status});
 `), cE("state-border", `
 border: var(--n-border-${status});
 `), c$1("&:hover", [cE("state-border", `
 border: var(--n-border-hover-${status});
 `)]), c$1("&:focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)]), cM("focus", `
 background-color: var(--n-color-focus-${status});
 `, [cE("state-border", `
 box-shadow: var(--n-box-shadow-focus-${status});
 border: var(--n-border-focus-${status});
 `)])])]))
      ]);
      const safariStyle = cB("input", [cM("disabled", [cE("input-el, textarea-el", `
 -webkit-text-fill-color: var(--n-text-color-disabled);
 `)])]);
      function len(s) {
        let count = 0;
        for (const _ of s) {
          count++;
        }
        return count;
      }
      function isEmptyInputValue(value) {
        return value === "" || value == null;
      }
      function useCursor(inputElRef) {
        const selectionRef = vue.ref(null);
        function recordCursor() {
          const {
            value: input
          } = inputElRef;
          if (!(input === null || input === void 0 ? void 0 : input.focus)) {
            reset();
            return;
          }
          const {
            selectionStart,
            selectionEnd,
            value
          } = input;
          if (selectionStart == null || selectionEnd == null) {
            reset();
            return;
          }
          selectionRef.value = {
            start: selectionStart,
            end: selectionEnd,
            beforeText: value.slice(0, selectionStart),
            afterText: value.slice(selectionEnd)
          };
        }
        function restoreCursor() {
          var _a;
          const {
            value: selection
          } = selectionRef;
          const {
            value: inputEl
          } = inputElRef;
          if (!selection || !inputEl) {
            return;
          }
          const {
            value
          } = inputEl;
          const {
            start,
            beforeText,
            afterText
          } = selection;
          let startPos = value.length;
          if (value.endsWith(afterText)) {
            startPos = value.length - afterText.length;
          } else if (value.startsWith(beforeText)) {
            startPos = beforeText.length;
          } else {
            const beforeLastChar = beforeText[start - 1];
            const newIndex = value.indexOf(beforeLastChar, start - 1);
            if (newIndex !== -1) {
              startPos = newIndex + 1;
            }
          }
          (_a = inputEl.setSelectionRange) === null || _a === void 0 ? void 0 : _a.call(inputEl, startPos, startPos);
        }
        function reset() {
          selectionRef.value = null;
        }
        vue.watch(inputElRef, reset);
        return {
          recordCursor,
          restoreCursor
        };
      }
      const WordCount = vue.defineComponent({
        name: "InputWordCount",
        setup(_, {
          slots
        }) {
          const {
            mergedValueRef,
            maxlengthRef,
            mergedClsPrefixRef,
            countGraphemesRef
          } = vue.inject(inputInjectionKey);
          const wordCountRef = vue.computed(() => {
            const {
              value: mergedValue
            } = mergedValueRef;
            if (mergedValue === null || Array.isArray(mergedValue)) return 0;
            return (countGraphemesRef.value || len)(mergedValue);
          });
          return () => {
            const {
              value: maxlength
            } = maxlengthRef;
            const {
              value: mergedValue
            } = mergedValueRef;
            return vue.h("span", {
              class: `${mergedClsPrefixRef.value}-input-word-count`
            }, resolveSlotWithTypedProps(slots.default, {
              value: mergedValue === null || Array.isArray(mergedValue) ? "" : mergedValue
            }, () => [maxlength === void 0 ? wordCountRef.value : `${wordCountRef.value} / ${maxlength}`]));
          };
        }
      });
      const inputProps = Object.assign(Object.assign({}, useTheme.props), {
        bordered: {
          type: Boolean,
          default: void 0
        },
        type: {
          type: String,
          default: "text"
        },
        placeholder: [Array, String],
        defaultValue: {
          type: [String, Array],
          default: null
        },
        value: [String, Array],
        disabled: {
          type: Boolean,
          default: void 0
        },
        size: String,
        rows: {
          type: [Number, String],
          default: 3
        },
        round: Boolean,
        minlength: [String, Number],
        maxlength: [String, Number],
        clearable: Boolean,
        autosize: {
          type: [Boolean, Object],
          default: false
        },
        pair: Boolean,
        separator: String,
        readonly: {
          type: [String, Boolean],
          default: false
        },
        passivelyActivated: Boolean,
        showPasswordOn: String,
        stateful: {
          type: Boolean,
          default: true
        },
        autofocus: Boolean,
        inputProps: Object,
        resizable: {
          type: Boolean,
          default: true
        },
        showCount: Boolean,
        loading: {
          type: Boolean,
          default: void 0
        },
        allowInput: Function,
        renderCount: Function,
        onMousedown: Function,
        onKeydown: Function,
        onKeyup: [Function, Array],
        onInput: [Function, Array],
        onFocus: [Function, Array],
        onBlur: [Function, Array],
        onClick: [Function, Array],
        onChange: [Function, Array],
        onClear: [Function, Array],
        countGraphemes: Function,
        status: String,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
textDecoration: [String, Array],
        attrSize: {
          type: Number,
          default: 20
        },
        onInputBlur: [Function, Array],
        onInputFocus: [Function, Array],
        onDeactivate: [Function, Array],
        onActivate: [Function, Array],
        onWrapperFocus: [Function, Array],
        onWrapperBlur: [Function, Array],
        internalDeactivateOnEnter: Boolean,
        internalForceFocus: Boolean,
        internalLoadingBeforeSuffix: {
          type: Boolean,
          default: true
        },
showPasswordToggle: Boolean
      });
      const NInput = vue.defineComponent({
        name: "Input",
        props: inputProps,
        slots: Object,
        setup(props) {
          const {
            mergedClsPrefixRef,
            mergedBorderedRef,
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const themeRef = useTheme("Input", "-input", style$m, inputLight, props, mergedClsPrefixRef);
          if (isSafari) {
            useStyle("-input-safari", safariStyle, mergedClsPrefixRef);
          }
          const wrapperElRef = vue.ref(null);
          const textareaElRef = vue.ref(null);
          const textareaMirrorElRef = vue.ref(null);
          const inputMirrorElRef = vue.ref(null);
          const inputElRef = vue.ref(null);
          const inputEl2Ref = vue.ref(null);
          const currentFocusedInputRef = vue.ref(null);
          const focusedInputCursorControl = useCursor(currentFocusedInputRef);
          const textareaScrollbarInstRef = vue.ref(null);
          const {
            localeRef
          } = useLocale("Input");
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const formItem = useFormItem(props);
          const {
            mergedSizeRef,
            mergedDisabledRef,
            mergedStatusRef
          } = formItem;
          const focusedRef = vue.ref(false);
          const hoverRef = vue.ref(false);
          const isComposingRef2 = vue.ref(false);
          const activatedRef = vue.ref(false);
          let syncSource = null;
          const mergedPlaceholderRef = vue.computed(() => {
            const {
              placeholder,
              pair
            } = props;
            if (pair) {
              if (Array.isArray(placeholder)) {
                return placeholder;
              } else if (placeholder === void 0) {
                return ["", ""];
              }
              return [placeholder, placeholder];
            } else if (placeholder === void 0) {
              return [localeRef.value.placeholder];
            } else {
              return [placeholder];
            }
          });
          const showPlaceholder1Ref = vue.computed(() => {
            const {
              value: isComposing
            } = isComposingRef2;
            const {
              value: mergedValue
            } = mergedValueRef;
            const {
              value: mergedPlaceholder
            } = mergedPlaceholderRef;
            return !isComposing && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[0])) && mergedPlaceholder[0];
          });
          const showPlaceholder2Ref = vue.computed(() => {
            const {
              value: isComposing
            } = isComposingRef2;
            const {
              value: mergedValue
            } = mergedValueRef;
            const {
              value: mergedPlaceholder
            } = mergedPlaceholderRef;
            return !isComposing && mergedPlaceholder[1] && (isEmptyInputValue(mergedValue) || Array.isArray(mergedValue) && isEmptyInputValue(mergedValue[1]));
          });
          const mergedFocusRef = useMemo(() => {
            return props.internalForceFocus || focusedRef.value;
          });
          const showClearButton = useMemo(() => {
            if (mergedDisabledRef.value || props.readonly || !props.clearable || !mergedFocusRef.value && !hoverRef.value) {
              return false;
            }
            const {
              value: mergedValue
            } = mergedValueRef;
            const {
              value: mergedFocus
            } = mergedFocusRef;
            if (props.pair) {
              return !!(Array.isArray(mergedValue) && (mergedValue[0] || mergedValue[1])) && (hoverRef.value || mergedFocus);
            } else {
              return !!mergedValue && (hoverRef.value || mergedFocus);
            }
          });
          const mergedShowPasswordOnRef = vue.computed(() => {
            const {
              showPasswordOn
            } = props;
            if (showPasswordOn) {
              return showPasswordOn;
            }
            if (props.showPasswordToggle) return "click";
            return void 0;
          });
          const passwordVisibleRef = vue.ref(false);
          const textDecorationStyleRef = vue.computed(() => {
            const {
              textDecoration
            } = props;
            if (!textDecoration) return ["", ""];
            if (Array.isArray(textDecoration)) {
              return textDecoration.map((v) => ({
                textDecoration: v
              }));
            }
            return [{
              textDecoration
            }];
          });
          const textAreaScrollContainerWidthRef = vue.ref(void 0);
          const updateTextAreaStyle = () => {
            var _a, _b;
            if (props.type === "textarea") {
              const {
                autosize
              } = props;
              if (autosize) {
                textAreaScrollContainerWidthRef.value = (_b = (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.$el) === null || _b === void 0 ? void 0 : _b.offsetWidth;
              }
              if (!textareaElRef.value) return;
              if (typeof autosize === "boolean") return;
              const {
                paddingTop: stylePaddingTop,
                paddingBottom: stylePaddingBottom,
                lineHeight: styleLineHeight
              } = window.getComputedStyle(textareaElRef.value);
              const paddingTop = Number(stylePaddingTop.slice(0, -2));
              const paddingBottom = Number(stylePaddingBottom.slice(0, -2));
              const lineHeight2 = Number(styleLineHeight.slice(0, -2));
              const {
                value: textareaMirrorEl
              } = textareaMirrorElRef;
              if (!textareaMirrorEl) return;
              if (autosize.minRows) {
                const minRows = Math.max(autosize.minRows, 1);
                const styleMinHeight = `${paddingTop + paddingBottom + lineHeight2 * minRows}px`;
                textareaMirrorEl.style.minHeight = styleMinHeight;
              }
              if (autosize.maxRows) {
                const styleMaxHeight = `${paddingTop + paddingBottom + lineHeight2 * autosize.maxRows}px`;
                textareaMirrorEl.style.maxHeight = styleMaxHeight;
              }
            }
          };
          const maxlengthRef = vue.computed(() => {
            const {
              maxlength
            } = props;
            return maxlength === void 0 ? void 0 : Number(maxlength);
          });
          vue.onMounted(() => {
            const {
              value
            } = mergedValueRef;
            if (!Array.isArray(value)) {
              syncMirror(value);
            }
          });
          const vm = vue.getCurrentInstance().proxy;
          function doUpdateValue(value, meta) {
            const {
              onUpdateValue,
              "onUpdate:value": _onUpdateValue,
              onInput
            } = props;
            const {
              nTriggerFormInput
            } = formItem;
            if (onUpdateValue) call(onUpdateValue, value, meta);
            if (_onUpdateValue) call(_onUpdateValue, value, meta);
            if (onInput) call(onInput, value, meta);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
          }
          function doChange(value, meta) {
            const {
              onChange
            } = props;
            const {
              nTriggerFormChange
            } = formItem;
            if (onChange) call(onChange, value, meta);
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
          }
          function doBlur(e) {
            const {
              onBlur
            } = props;
            const {
              nTriggerFormBlur
            } = formItem;
            if (onBlur) call(onBlur, e);
            nTriggerFormBlur();
          }
          function doFocus(e) {
            const {
              onFocus
            } = props;
            const {
              nTriggerFormFocus
            } = formItem;
            if (onFocus) call(onFocus, e);
            nTriggerFormFocus();
          }
          function doClear(e) {
            const {
              onClear
            } = props;
            if (onClear) call(onClear, e);
          }
          function doUpdateValueBlur(e) {
            const {
              onInputBlur
            } = props;
            if (onInputBlur) call(onInputBlur, e);
          }
          function doUpdateValueFocus(e) {
            const {
              onInputFocus
            } = props;
            if (onInputFocus) call(onInputFocus, e);
          }
          function doDeactivate() {
            const {
              onDeactivate
            } = props;
            if (onDeactivate) call(onDeactivate);
          }
          function doActivate() {
            const {
              onActivate
            } = props;
            if (onActivate) call(onActivate);
          }
          function doClick(e) {
            const {
              onClick
            } = props;
            if (onClick) call(onClick, e);
          }
          function doWrapperFocus(e) {
            const {
              onWrapperFocus
            } = props;
            if (onWrapperFocus) call(onWrapperFocus, e);
          }
          function doWrapperBlur(e) {
            const {
              onWrapperBlur
            } = props;
            if (onWrapperBlur) call(onWrapperBlur, e);
          }
          function handleCompositionStart() {
            isComposingRef2.value = true;
          }
          function handleCompositionEnd(e) {
            isComposingRef2.value = false;
            if (e.target === inputEl2Ref.value) {
              handleInput(e, 1);
            } else {
              handleInput(e, 0);
            }
          }
          function handleInput(e, index = 0, event = "input") {
            const targetValue = e.target.value;
            syncMirror(targetValue);
            if (e instanceof InputEvent && !e.isComposing) {
              isComposingRef2.value = false;
            }
            if (props.type === "textarea") {
              const {
                value: textareaScrollbarInst
              } = textareaScrollbarInstRef;
              if (textareaScrollbarInst) {
                textareaScrollbarInst.syncUnifiedContainer();
              }
            }
            syncSource = targetValue;
            if (isComposingRef2.value) return;
            focusedInputCursorControl.recordCursor();
            const isIncomingValueValid = allowInput(targetValue);
            if (isIncomingValueValid) {
              if (!props.pair) {
                if (event === "input") {
                  doUpdateValue(targetValue, {
                    source: index
                  });
                } else {
                  doChange(targetValue, {
                    source: index
                  });
                }
              } else {
                let {
                  value
                } = mergedValueRef;
                if (!Array.isArray(value)) {
                  value = ["", ""];
                } else {
                  value = [value[0], value[1]];
                }
                value[index] = targetValue;
                if (event === "input") {
                  doUpdateValue(value, {
                    source: index
                  });
                } else {
                  doChange(value, {
                    source: index
                  });
                }
              }
            }
            vm.$forceUpdate();
            if (!isIncomingValueValid) {
              void vue.nextTick(focusedInputCursorControl.restoreCursor);
            }
          }
          function allowInput(value) {
            const {
              countGraphemes,
              maxlength,
              minlength
            } = props;
            if (countGraphemes) {
              let graphemesCount;
              if (maxlength !== void 0) {
                if (graphemesCount === void 0) {
                  graphemesCount = countGraphemes(value);
                }
                if (graphemesCount > Number(maxlength)) return false;
              }
              if (minlength !== void 0) {
                if (graphemesCount === void 0) {
                  graphemesCount = countGraphemes(value);
                }
                if (graphemesCount < Number(maxlength)) return false;
              }
            }
            const {
              allowInput: allowInput2
            } = props;
            if (typeof allowInput2 === "function") {
              return allowInput2(value);
            }
            return true;
          }
          function handleInputBlur(e) {
            doUpdateValueBlur(e);
            if (e.relatedTarget === wrapperElRef.value) {
              doDeactivate();
            }
            if (!(e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value))) {
              activatedRef.value = false;
            }
            dealWithEvent(e, "blur");
            currentFocusedInputRef.value = null;
          }
          function handleInputFocus(e, index) {
            doUpdateValueFocus(e);
            focusedRef.value = true;
            activatedRef.value = true;
            doActivate();
            dealWithEvent(e, "focus");
            if (index === 0) {
              currentFocusedInputRef.value = inputElRef.value;
            } else if (index === 1) {
              currentFocusedInputRef.value = inputEl2Ref.value;
            } else if (index === 2) {
              currentFocusedInputRef.value = textareaElRef.value;
            }
          }
          function handleWrapperBlur(e) {
            if (props.passivelyActivated) {
              doWrapperBlur(e);
              dealWithEvent(e, "blur");
            }
          }
          function handleWrapperFocus(e) {
            if (props.passivelyActivated) {
              focusedRef.value = true;
              doWrapperFocus(e);
              dealWithEvent(e, "focus");
            }
          }
          function dealWithEvent(e, type) {
            if (e.relatedTarget !== null && (e.relatedTarget === inputElRef.value || e.relatedTarget === inputEl2Ref.value || e.relatedTarget === textareaElRef.value || e.relatedTarget === wrapperElRef.value)) ;
            else {
              if (type === "focus") {
                doFocus(e);
                focusedRef.value = true;
              } else if (type === "blur") {
                doBlur(e);
                focusedRef.value = false;
              }
            }
          }
          function handleChange(e, index) {
            handleInput(e, index, "change");
          }
          function handleClick2(e) {
            doClick(e);
          }
          function handleClear(e) {
            doClear(e);
            clearValue();
          }
          function clearValue() {
            if (props.pair) {
              doUpdateValue(["", ""], {
                source: "clear"
              });
              doChange(["", ""], {
                source: "clear"
              });
            } else {
              doUpdateValue("", {
                source: "clear"
              });
              doChange("", {
                source: "clear"
              });
            }
          }
          function handleMouseDown(e) {
            const {
              onMousedown
            } = props;
            if (onMousedown) onMousedown(e);
            const {
              tagName
            } = e.target;
            if (tagName !== "INPUT" && tagName !== "TEXTAREA") {
              if (props.resizable) {
                const {
                  value: wrapperEl
                } = wrapperElRef;
                if (wrapperEl) {
                  const {
                    left,
                    top,
                    width,
                    height
                  } = wrapperEl.getBoundingClientRect();
                  const resizeHandleSize = 14;
                  if (left + width - resizeHandleSize < e.clientX && e.clientX < left + width && top + height - resizeHandleSize < e.clientY && e.clientY < top + height) {
                    return;
                  }
                }
              }
              e.preventDefault();
              if (!focusedRef.value) {
                focus();
              }
            }
          }
          function handleMouseEnter() {
            var _a;
            hoverRef.value = true;
            if (props.type === "textarea") {
              (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseEnterWrapper();
            }
          }
          function handleMouseLeave() {
            var _a;
            hoverRef.value = false;
            if (props.type === "textarea") {
              (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.handleMouseLeaveWrapper();
            }
          }
          function handlePasswordToggleClick() {
            if (mergedDisabledRef.value) return;
            if (mergedShowPasswordOnRef.value !== "click") return;
            passwordVisibleRef.value = !passwordVisibleRef.value;
          }
          function handlePasswordToggleMousedown(e) {
            if (mergedDisabledRef.value) return;
            e.preventDefault();
            const preventDefaultOnce = (e2) => {
              e2.preventDefault();
              off("mouseup", document, preventDefaultOnce);
            };
            on("mouseup", document, preventDefaultOnce);
            if (mergedShowPasswordOnRef.value !== "mousedown") return;
            passwordVisibleRef.value = true;
            const hidePassword = () => {
              passwordVisibleRef.value = false;
              off("mouseup", document, hidePassword);
            };
            on("mouseup", document, hidePassword);
          }
          function handleWrapperKeyup(e) {
            if (props.onKeyup) call(props.onKeyup, e);
          }
          function handleWrapperKeydown(e) {
            if (props.onKeydown) call(props.onKeydown, e);
            switch (e.key) {
              case "Escape":
                handleWrapperKeydownEsc();
                break;
              case "Enter":
                handleWrapperKeydownEnter(e);
                break;
            }
          }
          function handleWrapperKeydownEnter(e) {
            var _a, _b;
            if (props.passivelyActivated) {
              const {
                value: focused
              } = activatedRef;
              if (focused) {
                if (props.internalDeactivateOnEnter) {
                  handleWrapperKeydownEsc();
                }
                return;
              }
              e.preventDefault();
              if (props.type === "textarea") {
                (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              } else {
                (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
              }
            }
          }
          function handleWrapperKeydownEsc() {
            if (props.passivelyActivated) {
              activatedRef.value = false;
              void vue.nextTick(() => {
                var _a;
                (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
              });
            }
          }
          function focus() {
            var _a, _b, _c;
            if (mergedDisabledRef.value) return;
            if (props.passivelyActivated) {
              (_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            } else {
              (_b = textareaElRef.value) === null || _b === void 0 ? void 0 : _b.focus();
              (_c = inputElRef.value) === null || _c === void 0 ? void 0 : _c.focus();
            }
          }
          function blur() {
            var _a;
            if ((_a = wrapperElRef.value) === null || _a === void 0 ? void 0 : _a.contains(document.activeElement)) {
              document.activeElement.blur();
            }
          }
          function select() {
            var _a, _b;
            (_a = textareaElRef.value) === null || _a === void 0 ? void 0 : _a.select();
            (_b = inputElRef.value) === null || _b === void 0 ? void 0 : _b.select();
          }
          function activate() {
            if (mergedDisabledRef.value) return;
            if (textareaElRef.value) textareaElRef.value.focus();
            else if (inputElRef.value) inputElRef.value.focus();
          }
          function deactivate() {
            const {
              value: wrapperEl
            } = wrapperElRef;
            if ((wrapperEl === null || wrapperEl === void 0 ? void 0 : wrapperEl.contains(document.activeElement)) && wrapperEl !== document.activeElement) {
              handleWrapperKeydownEsc();
            }
          }
          function scrollTo(options) {
            if (props.type === "textarea") {
              const {
                value: textareaEl
              } = textareaElRef;
              textareaEl === null || textareaEl === void 0 ? void 0 : textareaEl.scrollTo(options);
            } else {
              const {
                value: inputEl
              } = inputElRef;
              inputEl === null || inputEl === void 0 ? void 0 : inputEl.scrollTo(options);
            }
          }
          function syncMirror(value) {
            const {
              type,
              pair,
              autosize
            } = props;
            if (!pair && autosize) {
              if (type === "textarea") {
                const {
                  value: textareaMirrorEl
                } = textareaMirrorElRef;
                if (textareaMirrorEl) {
                  textareaMirrorEl.textContent = `${value !== null && value !== void 0 ? value : ""}\r
`;
                }
              } else {
                const {
                  value: inputMirrorEl
                } = inputMirrorElRef;
                if (inputMirrorEl) {
                  if (value) {
                    inputMirrorEl.textContent = value;
                  } else {
                    inputMirrorEl.innerHTML = "&nbsp;";
                  }
                }
              }
            }
          }
          function handleTextAreaMirrorResize() {
            updateTextAreaStyle();
          }
          const placeholderStyleRef = vue.ref({
            top: "0"
          });
          function handleTextAreaScroll(e) {
            var _a;
            const {
              scrollTop
            } = e.target;
            placeholderStyleRef.value.top = `${-scrollTop}px`;
            (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
          }
          let stopWatchMergedValue1 = null;
          vue.watchEffect(() => {
            const {
              autosize,
              type
            } = props;
            if (autosize && type === "textarea") {
              stopWatchMergedValue1 = vue.watch(mergedValueRef, (value) => {
                if (!Array.isArray(value) && value !== syncSource) {
                  syncMirror(value);
                }
              });
            } else {
              stopWatchMergedValue1 === null || stopWatchMergedValue1 === void 0 ? void 0 : stopWatchMergedValue1();
            }
          });
          let stopWatchMergedValue2 = null;
          vue.watchEffect(() => {
            if (props.type === "textarea") {
              stopWatchMergedValue2 = vue.watch(mergedValueRef, (value) => {
                var _a;
                if (!Array.isArray(value) && value !== syncSource) {
                  (_a = textareaScrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.syncUnifiedContainer();
                }
              });
            } else {
              stopWatchMergedValue2 === null || stopWatchMergedValue2 === void 0 ? void 0 : stopWatchMergedValue2();
            }
          });
          vue.provide(inputInjectionKey, {
            mergedValueRef,
            maxlengthRef,
            mergedClsPrefixRef,
            countGraphemesRef: vue.toRef(props, "countGraphemes")
          });
          const exposedProps = {
            wrapperElRef,
            inputElRef,
            textareaElRef,
            isCompositing: isComposingRef2,
            clear: clearValue,
            focus,
            blur,
            select,
            deactivate,
            activate,
            scrollTo
          };
          const rtlEnabledRef = useRtl("Input", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              value: size2
            } = mergedSizeRef;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                color,
                borderRadius,
                textColor,
                caretColor,
                caretColorError,
                caretColorWarning,
                textDecorationColor,
                border,
                borderDisabled,
                borderHover,
                borderFocus,
                placeholderColor,
                placeholderColorDisabled,
                lineHeightTextarea,
                colorDisabled,
                colorFocus,
                textColorDisabled,
                boxShadowFocus,
                iconSize,
                colorFocusWarning,
                boxShadowFocusWarning,
                borderWarning,
                borderFocusWarning,
                borderHoverWarning,
                colorFocusError,
                boxShadowFocusError,
                borderError,
                borderFocusError,
                borderHoverError,
                clearSize,
                clearColor,
                clearColorHover,
                clearColorPressed,
                iconColor,
                iconColorDisabled,
                suffixTextColor,
                countTextColor,
                countTextColorDisabled,
                iconColorHover,
                iconColorPressed,
                loadingColor,
                loadingColorError,
                loadingColorWarning,
                fontWeight,
                [createKey("padding", size2)]: padding,
                [createKey("fontSize", size2)]: fontSize2,
                [createKey("height", size2)]: height
              }
            } = themeRef.value;
            const {
              left: paddingLeft,
              right: paddingRight
            } = getMargin(padding);
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-count-text-color": countTextColor,
              "--n-count-text-color-disabled": countTextColorDisabled,
              "--n-color": color,
              "--n-font-size": fontSize2,
              "--n-font-weight": fontWeight,
              "--n-border-radius": borderRadius,
              "--n-height": height,
              "--n-padding-left": paddingLeft,
              "--n-padding-right": paddingRight,
              "--n-text-color": textColor,
              "--n-caret-color": caretColor,
              "--n-text-decoration-color": textDecorationColor,
              "--n-border": border,
              "--n-border-disabled": borderDisabled,
              "--n-border-hover": borderHover,
              "--n-border-focus": borderFocus,
              "--n-placeholder-color": placeholderColor,
              "--n-placeholder-color-disabled": placeholderColorDisabled,
              "--n-icon-size": iconSize,
              "--n-line-height-textarea": lineHeightTextarea,
              "--n-color-disabled": colorDisabled,
              "--n-color-focus": colorFocus,
              "--n-text-color-disabled": textColorDisabled,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-loading-color": loadingColor,
"--n-caret-color-warning": caretColorWarning,
              "--n-color-focus-warning": colorFocusWarning,
              "--n-box-shadow-focus-warning": boxShadowFocusWarning,
              "--n-border-warning": borderWarning,
              "--n-border-focus-warning": borderFocusWarning,
              "--n-border-hover-warning": borderHoverWarning,
              "--n-loading-color-warning": loadingColorWarning,
"--n-caret-color-error": caretColorError,
              "--n-color-focus-error": colorFocusError,
              "--n-box-shadow-focus-error": boxShadowFocusError,
              "--n-border-error": borderError,
              "--n-border-focus-error": borderFocusError,
              "--n-border-hover-error": borderHoverError,
              "--n-loading-color-error": loadingColorError,
"--n-clear-color": clearColor,
              "--n-clear-size": clearSize,
              "--n-clear-color-hover": clearColorHover,
              "--n-clear-color-pressed": clearColorPressed,
              "--n-icon-color": iconColor,
              "--n-icon-color-hover": iconColorHover,
              "--n-icon-color-pressed": iconColorPressed,
              "--n-icon-color-disabled": iconColorDisabled,
              "--n-suffix-text-color": suffixTextColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("input", vue.computed(() => {
            const {
              value: size2
            } = mergedSizeRef;
            return size2[0];
          }), cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, exposedProps), {
wrapperElRef,
            inputElRef,
            inputMirrorElRef,
            inputEl2Ref,
            textareaElRef,
            textareaMirrorElRef,
            textareaScrollbarInstRef,
rtlEnabled: rtlEnabledRef,
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            passwordVisible: passwordVisibleRef,
            mergedPlaceholder: mergedPlaceholderRef,
            showPlaceholder1: showPlaceholder1Ref,
            showPlaceholder2: showPlaceholder2Ref,
            mergedFocus: mergedFocusRef,
            isComposing: isComposingRef2,
            activated: activatedRef,
            showClearButton,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            textDecorationStyle: textDecorationStyleRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            mergedShowPasswordOn: mergedShowPasswordOnRef,
            placeholderStyle: placeholderStyleRef,
            mergedStatus: mergedStatusRef,
            textAreaScrollContainerWidth: textAreaScrollContainerWidthRef,
handleTextAreaScroll,
            handleCompositionStart,
            handleCompositionEnd,
            handleInput,
            handleInputBlur,
            handleInputFocus,
            handleWrapperBlur,
            handleWrapperFocus,
            handleMouseEnter,
            handleMouseLeave,
            handleMouseDown,
            handleChange,
            handleClick: handleClick2,
            handleClear,
            handlePasswordToggleClick,
            handlePasswordToggleMousedown,
            handleWrapperKeydown,
            handleWrapperKeyup,
            handleTextAreaMirrorResize,
            getTextareaScrollContainer: () => {
              return textareaElRef.value;
            },
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a, _b, _c, _d, _e, _f, _g;
          const {
            mergedClsPrefix,
            mergedStatus,
            themeClass,
            type,
            countGraphemes,
            onRender
          } = this;
          const $slots = this.$slots;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("div", {
            ref: "wrapperElRef",
            class: [`${mergedClsPrefix}-input`, themeClass, mergedStatus && `${mergedClsPrefix}-input--${mergedStatus}-status`, {
              [`${mergedClsPrefix}-input--rtl`]: this.rtlEnabled,
              [`${mergedClsPrefix}-input--disabled`]: this.mergedDisabled,
              [`${mergedClsPrefix}-input--textarea`]: type === "textarea",
              [`${mergedClsPrefix}-input--resizable`]: this.resizable && !this.autosize,
              [`${mergedClsPrefix}-input--autosize`]: this.autosize,
              [`${mergedClsPrefix}-input--round`]: this.round && !(type === "textarea"),
              [`${mergedClsPrefix}-input--pair`]: this.pair,
              [`${mergedClsPrefix}-input--focus`]: this.mergedFocus,
              [`${mergedClsPrefix}-input--stateful`]: this.stateful
            }],
            style: this.cssVars,
            tabindex: !this.mergedDisabled && this.passivelyActivated && !this.activated ? 0 : void 0,
            onFocus: this.handleWrapperFocus,
            onBlur: this.handleWrapperBlur,
            onClick: this.handleClick,
            onMousedown: this.handleMouseDown,
            onMouseenter: this.handleMouseEnter,
            onMouseleave: this.handleMouseLeave,
            onCompositionstart: this.handleCompositionStart,
            onCompositionend: this.handleCompositionEnd,
            onKeyup: this.handleWrapperKeyup,
            onKeydown: this.handleWrapperKeydown
          }, vue.h("div", {
            class: `${mergedClsPrefix}-input-wrapper`
          }, resolveWrappedSlot($slots.prefix, (children) => children && vue.h("div", {
            class: `${mergedClsPrefix}-input__prefix`
          }, children)), type === "textarea" ? vue.h(Scrollbar, {
            ref: "textareaScrollbarInstRef",
            class: `${mergedClsPrefix}-input__textarea`,
            container: this.getTextareaScrollContainer,
            theme: (_b = (_a = this.theme) === null || _a === void 0 ? void 0 : _a.peers) === null || _b === void 0 ? void 0 : _b.Scrollbar,
            themeOverrides: (_d = (_c = this.themeOverrides) === null || _c === void 0 ? void 0 : _c.peers) === null || _d === void 0 ? void 0 : _d.Scrollbar,
            triggerDisplayManually: true,
            useUnifiedContainer: true,
            internalHoistYRail: true
          }, {
            default: () => {
              var _a2, _b2;
              const {
                textAreaScrollContainerWidth
              } = this;
              const scrollContainerWidthStyle = {
                width: this.autosize && textAreaScrollContainerWidth && `${textAreaScrollContainerWidth}px`
              };
              return vue.h(vue.Fragment, null, vue.h("textarea", Object.assign({}, this.inputProps, {
                ref: "textareaElRef",
                class: [`${mergedClsPrefix}-input__textarea-el`, (_a2 = this.inputProps) === null || _a2 === void 0 ? void 0 : _a2.class],
                autofocus: this.autofocus,
                rows: Number(this.rows),
                placeholder: this.placeholder,
                value: this.mergedValue,
                disabled: this.mergedDisabled,
                maxlength: countGraphemes ? void 0 : this.maxlength,
                minlength: countGraphemes ? void 0 : this.minlength,
                readonly: this.readonly,
                tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
                style: [this.textDecorationStyle[0], (_b2 = this.inputProps) === null || _b2 === void 0 ? void 0 : _b2.style, scrollContainerWidthStyle],
                onBlur: this.handleInputBlur,
                onFocus: (e) => {
                  this.handleInputFocus(e, 2);
                },
                onInput: this.handleInput,
                onChange: this.handleChange,
                onScroll: this.handleTextAreaScroll
              })), this.showPlaceholder1 ? vue.h("div", {
                class: `${mergedClsPrefix}-input__placeholder`,
                style: [this.placeholderStyle, scrollContainerWidthStyle],
                key: "placeholder"
              }, this.mergedPlaceholder[0]) : null, this.autosize ? vue.h(VResizeObserver, {
                onResize: this.handleTextAreaMirrorResize
              }, {
                default: () => vue.h("div", {
                  ref: "textareaMirrorElRef",
                  class: `${mergedClsPrefix}-input__textarea-mirror`,
                  key: "mirror"
                })
              }) : null);
            }
          }) : vue.h("div", {
            class: `${mergedClsPrefix}-input__input`
          }, vue.h("input", Object.assign({
            type: type === "password" && this.mergedShowPasswordOn && this.passwordVisible ? "text" : type
          }, this.inputProps, {
            ref: "inputElRef",
            class: [`${mergedClsPrefix}-input__input-el`, (_e = this.inputProps) === null || _e === void 0 ? void 0 : _e.class],
            style: [this.textDecorationStyle[0], (_f = this.inputProps) === null || _f === void 0 ? void 0 : _f.style],
            tabindex: this.passivelyActivated && !this.activated ? -1 : (_g = this.inputProps) === null || _g === void 0 ? void 0 : _g.tabindex,
            placeholder: this.mergedPlaceholder[0],
            disabled: this.mergedDisabled,
            maxlength: countGraphemes ? void 0 : this.maxlength,
            minlength: countGraphemes ? void 0 : this.minlength,
            value: Array.isArray(this.mergedValue) ? this.mergedValue[0] : this.mergedValue,
            readonly: this.readonly,
            autofocus: this.autofocus,
            size: this.attrSize,
            onBlur: this.handleInputBlur,
            onFocus: (e) => {
              this.handleInputFocus(e, 0);
            },
            onInput: (e) => {
              this.handleInput(e, 0);
            },
            onChange: (e) => {
              this.handleChange(e, 0);
            }
          })), this.showPlaceholder1 ? vue.h("div", {
            class: `${mergedClsPrefix}-input__placeholder`
          }, vue.h("span", null, this.mergedPlaceholder[0])) : null, this.autosize ? vue.h("div", {
            class: `${mergedClsPrefix}-input__input-mirror`,
            key: "mirror",
            ref: "inputMirrorElRef"
          }, " ") : null), !this.pair && resolveWrappedSlot($slots.suffix, (children) => {
            return children || this.clearable || this.showCount || this.mergedShowPasswordOn || this.loading !== void 0 ? vue.h("div", {
              class: `${mergedClsPrefix}-input__suffix`
            }, [resolveWrappedSlot($slots["clear-icon-placeholder"], (children2) => {
              return (this.clearable || children2) && vue.h(NBaseClear, {
                clsPrefix: mergedClsPrefix,
                show: this.showClearButton,
                onClear: this.handleClear
              }, {
                placeholder: () => children2,
                icon: () => {
                  var _a2, _b2;
                  return (_b2 = (_a2 = this.$slots)["clear-icon"]) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
                }
              });
            }), !this.internalLoadingBeforeSuffix ? children : null, this.loading !== void 0 ? vue.h(NBaseSuffix, {
              clsPrefix: mergedClsPrefix,
              loading: this.loading,
              showArrow: false,
              showClear: false,
              style: this.cssVars
            }) : null, this.internalLoadingBeforeSuffix ? children : null, this.showCount && this.type !== "textarea" ? vue.h(WordCount, null, {
              default: (props) => {
                var _a2;
                const {
                  renderCount
                } = this;
                if (renderCount) {
                  return renderCount(props);
                }
                return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
              }
            }) : null, this.mergedShowPasswordOn && this.type === "password" ? vue.h("div", {
              class: `${mergedClsPrefix}-input__eye`,
              onMousedown: this.handlePasswordToggleMousedown,
              onClick: this.handlePasswordToggleClick
            }, this.passwordVisible ? resolveSlot($slots["password-visible-icon"], () => [vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix
            }, {
              default: () => vue.h(EyeIcon, null)
            })]) : resolveSlot($slots["password-invisible-icon"], () => [vue.h(NBaseIcon, {
              clsPrefix: mergedClsPrefix
            }, {
              default: () => vue.h(EyeOffIcon, null)
            })])) : null]) : null;
          })), this.pair ? vue.h("span", {
            class: `${mergedClsPrefix}-input__separator`
          }, resolveSlot($slots.separator, () => [this.separator])) : null, this.pair ? vue.h("div", {
            class: `${mergedClsPrefix}-input-wrapper`
          }, vue.h("div", {
            class: `${mergedClsPrefix}-input__input`
          }, vue.h("input", {
            ref: "inputEl2Ref",
            type: this.type,
            class: `${mergedClsPrefix}-input__input-el`,
            tabindex: this.passivelyActivated && !this.activated ? -1 : void 0,
            placeholder: this.mergedPlaceholder[1],
            disabled: this.mergedDisabled,
            maxlength: countGraphemes ? void 0 : this.maxlength,
            minlength: countGraphemes ? void 0 : this.minlength,
            value: Array.isArray(this.mergedValue) ? this.mergedValue[1] : void 0,
            readonly: this.readonly,
            style: this.textDecorationStyle[1],
            onBlur: this.handleInputBlur,
            onFocus: (e) => {
              this.handleInputFocus(e, 1);
            },
            onInput: (e) => {
              this.handleInput(e, 1);
            },
            onChange: (e) => {
              this.handleChange(e, 1);
            }
          }), this.showPlaceholder2 ? vue.h("div", {
            class: `${mergedClsPrefix}-input__placeholder`
          }, vue.h("span", null, this.mergedPlaceholder[1])) : null), resolveWrappedSlot($slots.suffix, (children) => {
            return (this.clearable || children) && vue.h("div", {
              class: `${mergedClsPrefix}-input__suffix`
            }, [this.clearable && vue.h(NBaseClear, {
              clsPrefix: mergedClsPrefix,
              show: this.showClearButton,
              onClear: this.handleClear
            }, {
              icon: () => {
                var _a2;
                return (_a2 = $slots["clear-icon"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
              },
              placeholder: () => {
                var _a2;
                return (_a2 = $slots["clear-icon-placeholder"]) === null || _a2 === void 0 ? void 0 : _a2.call($slots);
              }
            }), children]);
          })) : null, this.mergedBordered ? vue.h("div", {
            class: `${mergedClsPrefix}-input__border`
          }) : null, this.mergedBordered ? vue.h("div", {
            class: `${mergedClsPrefix}-input__state-border`
          }) : null, this.showCount && type === "textarea" ? vue.h(WordCount, null, {
            default: (props) => {
              var _a2;
              const {
                renderCount
              } = this;
              if (renderCount) {
                return renderCount(props);
              }
              return (_a2 = $slots.count) === null || _a2 === void 0 ? void 0 : _a2.call($slots, props);
            }
          }) : null);
        }
      });
      function getIsGroup(option) {
        return option.type === "group";
      }
      function getIgnored(option) {
        return option.type === "ignored";
      }
      function patternMatched(pattern, value) {
        try {
          return !!(1 + value.toString().toLowerCase().indexOf(pattern.trim().toLowerCase()));
        } catch (_a) {
          return false;
        }
      }
      function createTmOptions(valueField, childrenField) {
        const options = {
          getIsGroup,
          getIgnored,
          getKey(option) {
            if (getIsGroup(option)) {
              return option.name || option.key || "key-required";
            }
            return option[valueField];
          },
          getChildren(option) {
            return option[childrenField];
          }
        };
        return options;
      }
      function filterOptions(originalOpts, filter, pattern, childrenField) {
        if (!filter) return originalOpts;
        function traverse(options) {
          if (!Array.isArray(options)) return [];
          const filteredOptions = [];
          for (const option of options) {
            if (getIsGroup(option)) {
              const children = traverse(option[childrenField]);
              if (children.length) {
                filteredOptions.push(Object.assign({}, option, {
                  [childrenField]: children
                }));
              }
            } else if (getIgnored(option)) {
              continue;
            } else if (filter(pattern, option)) {
              filteredOptions.push(option);
            }
          }
          return filteredOptions;
        }
        return traverse(originalOpts);
      }
      function createValOptMap(options, valueField, childrenField) {
        const valOptMap = new Map();
        options.forEach((option) => {
          if (getIsGroup(option)) {
            option[childrenField].forEach((selectGroupOption) => {
              valOptMap.set(selectGroupOption[valueField], selectGroupOption);
            });
          } else {
            valOptMap.set(option[valueField], option);
          }
        });
        return valOptMap;
      }
      function createHoverColor(rgb) {
        return composite(rgb, [255, 255, 255, 0.16]);
      }
      function createPressedColor(rgb) {
        return composite(rgb, [0, 0, 0, 0.12]);
      }
      const buttonGroupInjectionKey = createInjectionKey("n-button-group");
      const commonVariables$8 = {
        paddingTiny: "0 6px",
        paddingSmall: "0 10px",
        paddingMedium: "0 14px",
        paddingLarge: "0 18px",
        paddingRoundTiny: "0 10px",
        paddingRoundSmall: "0 14px",
        paddingRoundMedium: "0 18px",
        paddingRoundLarge: "0 22px",
        iconMarginTiny: "6px",
        iconMarginSmall: "6px",
        iconMarginMedium: "6px",
        iconMarginLarge: "6px",
        iconSizeTiny: "14px",
        iconSizeSmall: "18px",
        iconSizeMedium: "18px",
        iconSizeLarge: "20px",
        rippleDuration: ".6s"
      };
      function self$m(vars) {
        const {
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadius,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          opacityDisabled,
          textColor2,
          textColor3,
          primaryColorHover,
          primaryColorPressed,
          borderColor,
          primaryColor,
          baseColor,
          infoColor,
          infoColorHover,
          infoColorPressed,
          successColor,
          successColorHover,
          successColorPressed,
          warningColor,
          warningColorHover,
          warningColorPressed,
          errorColor,
          errorColorHover,
          errorColorPressed,
          fontWeight,
          buttonColor2,
          buttonColor2Hover,
          buttonColor2Pressed,
          fontWeightStrong
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$8), {
          heightTiny,
          heightSmall,
          heightMedium,
          heightLarge,
          borderRadiusTiny: borderRadius,
          borderRadiusSmall: borderRadius,
          borderRadiusMedium: borderRadius,
          borderRadiusLarge: borderRadius,
          fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          opacityDisabled,
colorOpacitySecondary: "0.16",
          colorOpacitySecondaryHover: "0.22",
          colorOpacitySecondaryPressed: "0.28",
          colorSecondary: buttonColor2,
          colorSecondaryHover: buttonColor2Hover,
          colorSecondaryPressed: buttonColor2Pressed,
colorTertiary: buttonColor2,
          colorTertiaryHover: buttonColor2Hover,
          colorTertiaryPressed: buttonColor2Pressed,
colorQuaternary: "#0000",
          colorQuaternaryHover: buttonColor2Hover,
          colorQuaternaryPressed: buttonColor2Pressed,
color: "#0000",
          colorHover: "#0000",
          colorPressed: "#0000",
          colorFocus: "#0000",
          colorDisabled: "#0000",
          textColor: textColor2,
          textColorTertiary: textColor3,
          textColorHover: primaryColorHover,
          textColorPressed: primaryColorPressed,
          textColorFocus: primaryColorHover,
          textColorDisabled: textColor2,
          textColorText: textColor2,
          textColorTextHover: primaryColorHover,
          textColorTextPressed: primaryColorPressed,
          textColorTextFocus: primaryColorHover,
          textColorTextDisabled: textColor2,
          textColorGhost: textColor2,
          textColorGhostHover: primaryColorHover,
          textColorGhostPressed: primaryColorPressed,
          textColorGhostFocus: primaryColorHover,
          textColorGhostDisabled: textColor2,
          border: `1px solid ${borderColor}`,
          borderHover: `1px solid ${primaryColorHover}`,
          borderPressed: `1px solid ${primaryColorPressed}`,
          borderFocus: `1px solid ${primaryColorHover}`,
          borderDisabled: `1px solid ${borderColor}`,
          rippleColor: primaryColor,
colorPrimary: primaryColor,
          colorHoverPrimary: primaryColorHover,
          colorPressedPrimary: primaryColorPressed,
          colorFocusPrimary: primaryColorHover,
          colorDisabledPrimary: primaryColor,
          textColorPrimary: baseColor,
          textColorHoverPrimary: baseColor,
          textColorPressedPrimary: baseColor,
          textColorFocusPrimary: baseColor,
          textColorDisabledPrimary: baseColor,
          textColorTextPrimary: primaryColor,
          textColorTextHoverPrimary: primaryColorHover,
          textColorTextPressedPrimary: primaryColorPressed,
          textColorTextFocusPrimary: primaryColorHover,
          textColorTextDisabledPrimary: textColor2,
          textColorGhostPrimary: primaryColor,
          textColorGhostHoverPrimary: primaryColorHover,
          textColorGhostPressedPrimary: primaryColorPressed,
          textColorGhostFocusPrimary: primaryColorHover,
          textColorGhostDisabledPrimary: primaryColor,
          borderPrimary: `1px solid ${primaryColor}`,
          borderHoverPrimary: `1px solid ${primaryColorHover}`,
          borderPressedPrimary: `1px solid ${primaryColorPressed}`,
          borderFocusPrimary: `1px solid ${primaryColorHover}`,
          borderDisabledPrimary: `1px solid ${primaryColor}`,
          rippleColorPrimary: primaryColor,
colorInfo: infoColor,
          colorHoverInfo: infoColorHover,
          colorPressedInfo: infoColorPressed,
          colorFocusInfo: infoColorHover,
          colorDisabledInfo: infoColor,
          textColorInfo: baseColor,
          textColorHoverInfo: baseColor,
          textColorPressedInfo: baseColor,
          textColorFocusInfo: baseColor,
          textColorDisabledInfo: baseColor,
          textColorTextInfo: infoColor,
          textColorTextHoverInfo: infoColorHover,
          textColorTextPressedInfo: infoColorPressed,
          textColorTextFocusInfo: infoColorHover,
          textColorTextDisabledInfo: textColor2,
          textColorGhostInfo: infoColor,
          textColorGhostHoverInfo: infoColorHover,
          textColorGhostPressedInfo: infoColorPressed,
          textColorGhostFocusInfo: infoColorHover,
          textColorGhostDisabledInfo: infoColor,
          borderInfo: `1px solid ${infoColor}`,
          borderHoverInfo: `1px solid ${infoColorHover}`,
          borderPressedInfo: `1px solid ${infoColorPressed}`,
          borderFocusInfo: `1px solid ${infoColorHover}`,
          borderDisabledInfo: `1px solid ${infoColor}`,
          rippleColorInfo: infoColor,
colorSuccess: successColor,
          colorHoverSuccess: successColorHover,
          colorPressedSuccess: successColorPressed,
          colorFocusSuccess: successColorHover,
          colorDisabledSuccess: successColor,
          textColorSuccess: baseColor,
          textColorHoverSuccess: baseColor,
          textColorPressedSuccess: baseColor,
          textColorFocusSuccess: baseColor,
          textColorDisabledSuccess: baseColor,
          textColorTextSuccess: successColor,
          textColorTextHoverSuccess: successColorHover,
          textColorTextPressedSuccess: successColorPressed,
          textColorTextFocusSuccess: successColorHover,
          textColorTextDisabledSuccess: textColor2,
          textColorGhostSuccess: successColor,
          textColorGhostHoverSuccess: successColorHover,
          textColorGhostPressedSuccess: successColorPressed,
          textColorGhostFocusSuccess: successColorHover,
          textColorGhostDisabledSuccess: successColor,
          borderSuccess: `1px solid ${successColor}`,
          borderHoverSuccess: `1px solid ${successColorHover}`,
          borderPressedSuccess: `1px solid ${successColorPressed}`,
          borderFocusSuccess: `1px solid ${successColorHover}`,
          borderDisabledSuccess: `1px solid ${successColor}`,
          rippleColorSuccess: successColor,
colorWarning: warningColor,
          colorHoverWarning: warningColorHover,
          colorPressedWarning: warningColorPressed,
          colorFocusWarning: warningColorHover,
          colorDisabledWarning: warningColor,
          textColorWarning: baseColor,
          textColorHoverWarning: baseColor,
          textColorPressedWarning: baseColor,
          textColorFocusWarning: baseColor,
          textColorDisabledWarning: baseColor,
          textColorTextWarning: warningColor,
          textColorTextHoverWarning: warningColorHover,
          textColorTextPressedWarning: warningColorPressed,
          textColorTextFocusWarning: warningColorHover,
          textColorTextDisabledWarning: textColor2,
          textColorGhostWarning: warningColor,
          textColorGhostHoverWarning: warningColorHover,
          textColorGhostPressedWarning: warningColorPressed,
          textColorGhostFocusWarning: warningColorHover,
          textColorGhostDisabledWarning: warningColor,
          borderWarning: `1px solid ${warningColor}`,
          borderHoverWarning: `1px solid ${warningColorHover}`,
          borderPressedWarning: `1px solid ${warningColorPressed}`,
          borderFocusWarning: `1px solid ${warningColorHover}`,
          borderDisabledWarning: `1px solid ${warningColor}`,
          rippleColorWarning: warningColor,
colorError: errorColor,
          colorHoverError: errorColorHover,
          colorPressedError: errorColorPressed,
          colorFocusError: errorColorHover,
          colorDisabledError: errorColor,
          textColorError: baseColor,
          textColorHoverError: baseColor,
          textColorPressedError: baseColor,
          textColorFocusError: baseColor,
          textColorDisabledError: baseColor,
          textColorTextError: errorColor,
          textColorTextHoverError: errorColorHover,
          textColorTextPressedError: errorColorPressed,
          textColorTextFocusError: errorColorHover,
          textColorTextDisabledError: textColor2,
          textColorGhostError: errorColor,
          textColorGhostHoverError: errorColorHover,
          textColorGhostPressedError: errorColorPressed,
          textColorGhostFocusError: errorColorHover,
          textColorGhostDisabledError: errorColor,
          borderError: `1px solid ${errorColor}`,
          borderHoverError: `1px solid ${errorColorHover}`,
          borderPressedError: `1px solid ${errorColorPressed}`,
          borderFocusError: `1px solid ${errorColorHover}`,
          borderDisabledError: `1px solid ${errorColor}`,
          rippleColorError: errorColor,
          waveOpacity: "0.6",
          fontWeight,
          fontWeightStrong
        });
      }
      const buttonLight = {
        name: "Button",
        common: derived,
        self: self$m
      };
      const style$l = c$1([cB("button", `
 margin: 0;
 font-weight: var(--n-font-weight);
 line-height: 1;
 font-family: inherit;
 padding: var(--n-padding);
 height: var(--n-height);
 font-size: var(--n-font-size);
 border-radius: var(--n-border-radius);
 color: var(--n-text-color);
 background-color: var(--n-color);
 width: var(--n-width);
 white-space: nowrap;
 outline: none;
 position: relative;
 z-index: auto;
 border: none;
 display: inline-flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 align-items: center;
 justify-content: center;
 user-select: none;
 -webkit-user-select: none;
 text-align: center;
 cursor: pointer;
 text-decoration: none;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("color", [cE("border", {
        borderColor: "var(--n-border-color)"
      }), cM("disabled", [cE("border", {
        borderColor: "var(--n-border-color-disabled)"
      })]), cNotM("disabled", [c$1("&:focus", [cE("state-border", {
        borderColor: "var(--n-border-color-focus)"
      })]), c$1("&:hover", [cE("state-border", {
        borderColor: "var(--n-border-color-hover)"
      })]), c$1("&:active", [cE("state-border", {
        borderColor: "var(--n-border-color-pressed)"
      })]), cM("pressed", [cE("state-border", {
        borderColor: "var(--n-border-color-pressed)"
      })])])]), cM("disabled", {
        backgroundColor: "var(--n-color-disabled)",
        color: "var(--n-text-color-disabled)"
      }, [cE("border", {
        border: "var(--n-border-disabled)"
      })]), cNotM("disabled", [c$1("&:focus", {
        backgroundColor: "var(--n-color-focus)",
        color: "var(--n-text-color-focus)"
      }, [cE("state-border", {
        border: "var(--n-border-focus)"
      })]), c$1("&:hover", {
        backgroundColor: "var(--n-color-hover)",
        color: "var(--n-text-color-hover)"
      }, [cE("state-border", {
        border: "var(--n-border-hover)"
      })]), c$1("&:active", {
        backgroundColor: "var(--n-color-pressed)",
        color: "var(--n-text-color-pressed)"
      }, [cE("state-border", {
        border: "var(--n-border-pressed)"
      })]), cM("pressed", {
        backgroundColor: "var(--n-color-pressed)",
        color: "var(--n-text-color-pressed)"
      }, [cE("state-border", {
        border: "var(--n-border-pressed)"
      })])]), cM("loading", "cursor: wait;"), cB("base-wave", `
 pointer-events: none;
 top: 0;
 right: 0;
 bottom: 0;
 left: 0;
 animation-iteration-count: 1;
 animation-duration: var(--n-ripple-duration);
 animation-timing-function: var(--n-bezier-ease-out), var(--n-bezier-ease-out);
 `, [cM("active", {
        zIndex: 1,
        animationName: "button-wave-spread, button-wave-opacity"
      })]), isBrowser$1 && "MozBoxSizing" in document.createElement("div").style ? c$1("&::moz-focus-inner", {
        border: 0
      }) : null, cE("border, state-border", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 border-radius: inherit;
 transition: border-color .3s var(--n-bezier);
 pointer-events: none;
 `), cE("border", {
        border: "var(--n-border)"
      }), cE("state-border", {
        border: "var(--n-border)",
        borderColor: "#0000",
        zIndex: 1
      }), cE("icon", `
 margin: var(--n-icon-margin);
 margin-left: 0;
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 max-width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 position: relative;
 flex-shrink: 0;
 `, [cB("icon-slot", `
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [iconSwitchTransition({
        top: "50%",
        originalTransform: "translateY(-50%)"
      })]), fadeInWidthExpandTransition()]), cE("content", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 min-width: 0;
 `, [c$1("~", [cE("icon", {
        margin: "var(--n-icon-margin)",
        marginRight: 0
      })])]), cM("block", `
 display: flex;
 width: 100%;
 `), cM("dashed", [cE("border, state-border", {
        borderStyle: "dashed !important"
      })]), cM("disabled", {
        cursor: "not-allowed",
        opacity: "var(--n-opacity-disabled)"
      })]), c$1("@keyframes button-wave-spread", {
        from: {
          boxShadow: "0 0 0.5px 0 var(--n-ripple-color)"
        },
        to: {
boxShadow: "0 0 0.5px 4.5px var(--n-ripple-color)"
        }
      }), c$1("@keyframes button-wave-opacity", {
        from: {
          opacity: "var(--n-wave-opacity)"
        },
        to: {
          opacity: 0
        }
      })]);
      const buttonProps = Object.assign(Object.assign({}, useTheme.props), {
        color: String,
        textColor: String,
        text: Boolean,
        block: Boolean,
        loading: Boolean,
        disabled: Boolean,
        circle: Boolean,
        size: String,
        ghost: Boolean,
        round: Boolean,
        secondary: Boolean,
        tertiary: Boolean,
        quaternary: Boolean,
        strong: Boolean,
        focusable: {
          type: Boolean,
          default: true
        },
        keyboard: {
          type: Boolean,
          default: true
        },
        tag: {
          type: String,
          default: "button"
        },
        type: {
          type: String,
          default: "default"
        },
        dashed: Boolean,
        renderIcon: Function,
        iconPlacement: {
          type: String,
          default: "left"
        },
        attrType: {
          type: String,
          default: "button"
        },
        bordered: {
          type: Boolean,
          default: true
        },
        onClick: [Function, Array],
        nativeFocusBehavior: {
          type: Boolean,
          default: !isSafari
        }
      });
      const Button = vue.defineComponent({
        name: "Button",
        props: buttonProps,
        slots: Object,
        setup(props) {
          const selfElRef = vue.ref(null);
          const waveElRef = vue.ref(null);
          const enterPressedRef = vue.ref(false);
          const showBorderRef = useMemo(() => {
            return !props.quaternary && !props.tertiary && !props.secondary && !props.text && (!props.color || props.ghost || props.dashed) && props.bordered;
          });
          const NButtonGroup = vue.inject(buttonGroupInjectionKey, {});
          const {
            mergedSizeRef
          } = useFormItem({}, {
            defaultSize: "medium",
            mergedSize: (NFormItem2) => {
              const {
                size: size2
              } = props;
              if (size2) return size2;
              const {
                size: buttonGroupSize
              } = NButtonGroup;
              if (buttonGroupSize) return buttonGroupSize;
              const {
                mergedSize: formItemSize2
              } = NFormItem2 || {};
              if (formItemSize2) {
                return formItemSize2.value;
              }
              return "medium";
            }
          });
          const mergedFocusableRef = vue.computed(() => {
            return props.focusable && !props.disabled;
          });
          const handleMousedown = (e) => {
            var _a;
            if (!mergedFocusableRef.value) {
              e.preventDefault();
            }
            if (props.nativeFocusBehavior) {
              return;
            }
            e.preventDefault();
            if (props.disabled) {
              return;
            }
            if (mergedFocusableRef.value) {
              (_a = selfElRef.value) === null || _a === void 0 ? void 0 : _a.focus({
                preventScroll: true
              });
            }
          };
          const handleClick2 = (e) => {
            var _a;
            if (!props.disabled && !props.loading) {
              const {
                onClick
              } = props;
              if (onClick) call(onClick, e);
              if (!props.text) {
                (_a = waveElRef.value) === null || _a === void 0 ? void 0 : _a.play();
              }
            }
          };
          const handleKeyup = (e) => {
            switch (e.key) {
              case "Enter":
                if (!props.keyboard) {
                  return;
                }
                enterPressedRef.value = false;
            }
          };
          const handleKeydown = (e) => {
            switch (e.key) {
              case "Enter":
                if (!props.keyboard || props.loading) {
                  e.preventDefault();
                  return;
                }
                enterPressedRef.value = true;
            }
          };
          const handleBlur = () => {
            enterPressedRef.value = false;
          };
          const {
            inlineThemeDisabled,
            mergedClsPrefixRef,
            mergedRtlRef
          } = useConfig(props);
          const themeRef = useTheme("Button", "-button", style$l, buttonLight, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Button", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const theme = themeRef.value;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2,
                cubicBezierEaseOut: cubicBezierEaseOut2
              },
              self: self2
            } = theme;
            const {
              rippleDuration,
              opacityDisabled,
              fontWeight,
              fontWeightStrong
            } = self2;
            const size2 = mergedSizeRef.value;
            const {
              dashed,
              type,
              ghost,
              text,
              color,
              round,
              circle,
              textColor,
              secondary,
              tertiary,
              quaternary,
              strong
            } = props;
            const fontProps = {
              "--n-font-weight": strong ? fontWeightStrong : fontWeight
            };
            let colorProps = {
              "--n-color": "initial",
              "--n-color-hover": "initial",
              "--n-color-pressed": "initial",
              "--n-color-focus": "initial",
              "--n-color-disabled": "initial",
              "--n-ripple-color": "initial",
              "--n-text-color": "initial",
              "--n-text-color-hover": "initial",
              "--n-text-color-pressed": "initial",
              "--n-text-color-focus": "initial",
              "--n-text-color-disabled": "initial"
            };
            const typeIsTertiary = type === "tertiary";
            const typeIsDefault = type === "default";
            const mergedType = typeIsTertiary ? "default" : type;
            if (text) {
              const propTextColor = textColor || color;
              const mergedTextColor = propTextColor || self2[createKey("textColorText", mergedType)];
              colorProps = {
                "--n-color": "#0000",
                "--n-color-hover": "#0000",
                "--n-color-pressed": "#0000",
                "--n-color-focus": "#0000",
                "--n-color-disabled": "#0000",
                "--n-ripple-color": "#0000",
                "--n-text-color": mergedTextColor,
                "--n-text-color-hover": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
                "--n-text-color-pressed": propTextColor ? createPressedColor(propTextColor) : self2[createKey("textColorTextPressed", mergedType)],
                "--n-text-color-focus": propTextColor ? createHoverColor(propTextColor) : self2[createKey("textColorTextHover", mergedType)],
                "--n-text-color-disabled": propTextColor || self2[createKey("textColorTextDisabled", mergedType)]
              };
            } else if (ghost || dashed) {
              const mergedTextColor = textColor || color;
              colorProps = {
                "--n-color": "#0000",
                "--n-color-hover": "#0000",
                "--n-color-pressed": "#0000",
                "--n-color-focus": "#0000",
                "--n-color-disabled": "#0000",
                "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
                "--n-text-color": mergedTextColor || self2[createKey("textColorGhost", mergedType)],
                "--n-text-color-hover": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
                "--n-text-color-pressed": mergedTextColor ? createPressedColor(mergedTextColor) : self2[createKey("textColorGhostPressed", mergedType)],
                "--n-text-color-focus": mergedTextColor ? createHoverColor(mergedTextColor) : self2[createKey("textColorGhostHover", mergedType)],
                "--n-text-color-disabled": mergedTextColor || self2[createKey("textColorGhostDisabled", mergedType)]
              };
            } else if (secondary) {
              const typeTextColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
              const mergedTextColor = color || typeTextColor;
              const isColoredType = type !== "default" && type !== "tertiary";
              colorProps = {
                "--n-color": isColoredType ? changeColor(mergedTextColor, {
                  alpha: Number(self2.colorOpacitySecondary)
                }) : self2.colorSecondary,
                "--n-color-hover": isColoredType ? changeColor(mergedTextColor, {
                  alpha: Number(self2.colorOpacitySecondaryHover)
                }) : self2.colorSecondaryHover,
                "--n-color-pressed": isColoredType ? changeColor(mergedTextColor, {
                  alpha: Number(self2.colorOpacitySecondaryPressed)
                }) : self2.colorSecondaryPressed,
                "--n-color-focus": isColoredType ? changeColor(mergedTextColor, {
                  alpha: Number(self2.colorOpacitySecondaryHover)
                }) : self2.colorSecondaryHover,
                "--n-color-disabled": self2.colorSecondary,
                "--n-ripple-color": "#0000",
                "--n-text-color": mergedTextColor,
                "--n-text-color-hover": mergedTextColor,
                "--n-text-color-pressed": mergedTextColor,
                "--n-text-color-focus": mergedTextColor,
                "--n-text-color-disabled": mergedTextColor
              };
            } else if (tertiary || quaternary) {
              const typeColor = typeIsDefault ? self2.textColor : typeIsTertiary ? self2.textColorTertiary : self2[createKey("color", mergedType)];
              const mergedColor = color || typeColor;
              if (tertiary) {
                colorProps["--n-color"] = self2.colorTertiary;
                colorProps["--n-color-hover"] = self2.colorTertiaryHover;
                colorProps["--n-color-pressed"] = self2.colorTertiaryPressed;
                colorProps["--n-color-focus"] = self2.colorSecondaryHover;
                colorProps["--n-color-disabled"] = self2.colorTertiary;
              } else {
                colorProps["--n-color"] = self2.colorQuaternary;
                colorProps["--n-color-hover"] = self2.colorQuaternaryHover;
                colorProps["--n-color-pressed"] = self2.colorQuaternaryPressed;
                colorProps["--n-color-focus"] = self2.colorQuaternaryHover;
                colorProps["--n-color-disabled"] = self2.colorQuaternary;
              }
              colorProps["--n-ripple-color"] = "#0000";
              colorProps["--n-text-color"] = mergedColor;
              colorProps["--n-text-color-hover"] = mergedColor;
              colorProps["--n-text-color-pressed"] = mergedColor;
              colorProps["--n-text-color-focus"] = mergedColor;
              colorProps["--n-text-color-disabled"] = mergedColor;
            } else {
              colorProps = {
                "--n-color": color || self2[createKey("color", mergedType)],
                "--n-color-hover": color ? createHoverColor(color) : self2[createKey("colorHover", mergedType)],
                "--n-color-pressed": color ? createPressedColor(color) : self2[createKey("colorPressed", mergedType)],
                "--n-color-focus": color ? createHoverColor(color) : self2[createKey("colorFocus", mergedType)],
                "--n-color-disabled": color || self2[createKey("colorDisabled", mergedType)],
                "--n-ripple-color": color || self2[createKey("rippleColor", mergedType)],
                "--n-text-color": textColor || (color ? self2.textColorPrimary : typeIsTertiary ? self2.textColorTertiary : self2[createKey("textColor", mergedType)]),
                "--n-text-color-hover": textColor || (color ? self2.textColorHoverPrimary : self2[createKey("textColorHover", mergedType)]),
                "--n-text-color-pressed": textColor || (color ? self2.textColorPressedPrimary : self2[createKey("textColorPressed", mergedType)]),
                "--n-text-color-focus": textColor || (color ? self2.textColorFocusPrimary : self2[createKey("textColorFocus", mergedType)]),
                "--n-text-color-disabled": textColor || (color ? self2.textColorDisabledPrimary : self2[createKey("textColorDisabled", mergedType)])
              };
            }
            let borderProps = {
              "--n-border": "initial",
              "--n-border-hover": "initial",
              "--n-border-pressed": "initial",
              "--n-border-focus": "initial",
              "--n-border-disabled": "initial"
            };
            if (text) {
              borderProps = {
                "--n-border": "none",
                "--n-border-hover": "none",
                "--n-border-pressed": "none",
                "--n-border-focus": "none",
                "--n-border-disabled": "none"
              };
            } else {
              borderProps = {
                "--n-border": self2[createKey("border", mergedType)],
                "--n-border-hover": self2[createKey("borderHover", mergedType)],
                "--n-border-pressed": self2[createKey("borderPressed", mergedType)],
                "--n-border-focus": self2[createKey("borderFocus", mergedType)],
                "--n-border-disabled": self2[createKey("borderDisabled", mergedType)]
              };
            }
            const {
              [createKey("height", size2)]: height,
              [createKey("fontSize", size2)]: fontSize2,
              [createKey("padding", size2)]: padding,
              [createKey("paddingRound", size2)]: paddingRound,
              [createKey("iconSize", size2)]: iconSize,
              [createKey("borderRadius", size2)]: borderRadius,
              [createKey("iconMargin", size2)]: iconMargin,
              waveOpacity
            } = self2;
            const sizeProps = {
              "--n-width": circle && !text ? height : "initial",
              "--n-height": text ? "initial" : height,
              "--n-font-size": fontSize2,
              "--n-padding": circle ? "initial" : text ? "initial" : round ? paddingRound : padding,
              "--n-icon-size": iconSize,
              "--n-icon-margin": iconMargin,
              "--n-border-radius": text ? "initial" : circle || round ? height : borderRadius
            };
            return Object.assign(Object.assign(Object.assign(Object.assign({
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-bezier-ease-out": cubicBezierEaseOut2,
              "--n-ripple-duration": rippleDuration,
              "--n-opacity-disabled": opacityDisabled,
              "--n-wave-opacity": waveOpacity
            }, fontProps), colorProps), borderProps), sizeProps);
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("button", vue.computed(() => {
            let hash = "";
            const {
              dashed,
              type,
              ghost,
              text,
              color,
              round,
              circle,
              textColor,
              secondary,
              tertiary,
              quaternary,
              strong
            } = props;
            if (dashed) hash += "a";
            if (ghost) hash += "b";
            if (text) hash += "c";
            if (round) hash += "d";
            if (circle) hash += "e";
            if (secondary) hash += "f";
            if (tertiary) hash += "g";
            if (quaternary) hash += "h";
            if (strong) hash += "i";
            if (color) hash += `j${color2Class(color)}`;
            if (textColor) hash += `k${color2Class(textColor)}`;
            const {
              value: size2
            } = mergedSizeRef;
            hash += `l${size2[0]}`;
            hash += `m${type[0]}`;
            return hash;
          }), cssVarsRef, props) : void 0;
          return {
            selfElRef,
            waveElRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedFocusable: mergedFocusableRef,
            mergedSize: mergedSizeRef,
            showBorder: showBorderRef,
            enterPressed: enterPressedRef,
            rtlEnabled: rtlEnabledRef,
            handleMousedown,
            handleKeydown,
            handleBlur,
            handleKeyup,
            handleClick: handleClick2,
            customColorCssVars: vue.computed(() => {
              const {
                color
              } = props;
              if (!color) return null;
              const hoverColor = createHoverColor(color);
              return {
                "--n-border-color": color,
                "--n-border-color-hover": hoverColor,
                "--n-border-color-pressed": createPressedColor(color),
                "--n-border-color-focus": hoverColor,
                "--n-border-color-disabled": color
              };
            }),
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const {
            mergedClsPrefix,
            tag: Component,
            onRender
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const children = resolveWrappedSlot(this.$slots.default, (children2) => children2 && vue.h("span", {
            class: `${mergedClsPrefix}-button__content`
          }, children2));
          return vue.h(Component, {
            ref: "selfElRef",
            class: [
              this.themeClass,
              `${mergedClsPrefix}-button`,
              `${mergedClsPrefix}-button--${this.type}-type`,
              `${mergedClsPrefix}-button--${this.mergedSize}-type`,
              this.rtlEnabled && `${mergedClsPrefix}-button--rtl`,
              this.disabled && `${mergedClsPrefix}-button--disabled`,
              this.block && `${mergedClsPrefix}-button--block`,
              this.enterPressed && `${mergedClsPrefix}-button--pressed`,
              !this.text && this.dashed && `${mergedClsPrefix}-button--dashed`,
              this.color && `${mergedClsPrefix}-button--color`,
              this.secondary && `${mergedClsPrefix}-button--secondary`,
              this.loading && `${mergedClsPrefix}-button--loading`,
              this.ghost && `${mergedClsPrefix}-button--ghost`
],
            tabindex: this.mergedFocusable ? 0 : -1,
            type: this.attrType,
            style: this.cssVars,
            disabled: this.disabled,
            onClick: this.handleClick,
            onBlur: this.handleBlur,
            onMousedown: this.handleMousedown,
            onKeyup: this.handleKeyup,
            onKeydown: this.handleKeydown
          }, this.iconPlacement === "right" && children, vue.h(NFadeInExpandTransition, {
            width: true
          }, {
            default: () => resolveWrappedSlot(this.$slots.icon, (children2) => (this.loading || this.renderIcon || children2) && vue.h("span", {
              class: `${mergedClsPrefix}-button__icon`,
              style: {
                margin: isSlotEmpty(this.$slots.default) ? "0" : ""
              }
            }, vue.h(NIconSwitchTransition, null, {
              default: () => this.loading ? vue.h(NBaseLoading, {
                clsPrefix: mergedClsPrefix,
                key: "loading",
                class: `${mergedClsPrefix}-icon-slot`,
                strokeWidth: 20
              }) : vue.h("div", {
                key: "icon",
                class: `${mergedClsPrefix}-icon-slot`,
                role: "none"
              }, this.renderIcon ? this.renderIcon() : children2)
            })))
          }), this.iconPlacement === "left" && children, !this.text ? vue.h(NBaseWave, {
            ref: "waveElRef",
            clsPrefix: mergedClsPrefix
          }) : null, this.showBorder ? vue.h("div", {
            "aria-hidden": true,
            class: `${mergedClsPrefix}-button__border`,
            style: this.customColorCssVars
          }) : null, this.showBorder ? vue.h("div", {
            "aria-hidden": true,
            class: `${mergedClsPrefix}-button__state-border`,
            style: this.customColorCssVars
          }) : null);
        }
      });
      const commonVariables$7 = {
        paddingSmall: "12px 16px 12px",
        paddingMedium: "19px 24px 20px",
        paddingLarge: "23px 32px 24px",
        paddingHuge: "27px 40px 28px",
        titleFontSizeSmall: "16px",
        titleFontSizeMedium: "18px",
        titleFontSizeLarge: "18px",
        titleFontSizeHuge: "18px",
        closeIconSize: "18px",
        closeSize: "22px"
      };
      function self$l(vars) {
        const {
          primaryColor,
          borderRadius,
          lineHeight: lineHeight2,
          fontSize: fontSize2,
          cardColor,
          textColor2,
          textColor1,
          dividerColor,
          fontWeightStrong,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          modalColor,
          boxShadow1,
          popoverColor,
          actionColor
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$7), {
          lineHeight: lineHeight2,
          color: cardColor,
          colorModal: modalColor,
          colorPopover: popoverColor,
          colorTarget: primaryColor,
          colorEmbedded: actionColor,
          colorEmbeddedModal: actionColor,
          colorEmbeddedPopover: actionColor,
          textColor: textColor2,
          titleTextColor: textColor1,
          borderColor: dividerColor,
          actionColor,
          titleFontWeight: fontWeightStrong,
          closeColorHover,
          closeColorPressed,
          closeBorderRadius: borderRadius,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          fontSizeSmall: fontSize2,
          fontSizeMedium: fontSize2,
          fontSizeLarge: fontSize2,
          fontSizeHuge: fontSize2,
          boxShadow: boxShadow1,
          borderRadius
        });
      }
      const cardLight = {
        name: "Card",
        common: derived,
        self: self$l
      };
      const style$k = c$1([cB("card", `
 font-size: var(--n-font-size);
 line-height: var(--n-line-height);
 display: flex;
 flex-direction: column;
 width: 100%;
 box-sizing: border-box;
 position: relative;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 color: var(--n-text-color);
 word-break: break-word;
 transition: 
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [asModal({
        background: "var(--n-color-modal)"
      }), cM("hoverable", [c$1("&:hover", "box-shadow: var(--n-box-shadow);")]), cM("content-segmented", [c$1(">", [cE("content", {
        paddingTop: "var(--n-padding-bottom)"
      })])]), cM("content-soft-segmented", [c$1(">", [cE("content", `
 margin: 0 var(--n-padding-left);
 padding: var(--n-padding-bottom) 0;
 `)])]), cM("footer-segmented", [c$1(">", [cE("footer", {
        paddingTop: "var(--n-padding-bottom)"
      })])]), cM("footer-soft-segmented", [c$1(">", [cE("footer", `
 padding: var(--n-padding-bottom) 0;
 margin: 0 var(--n-padding-left);
 `)])]), c$1(">", [cB("card-header", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 padding:
 var(--n-padding-top)
 var(--n-padding-left)
 var(--n-padding-bottom)
 var(--n-padding-left);
 `, [cE("main", `
 font-weight: var(--n-title-font-weight);
 transition: color .3s var(--n-bezier);
 flex: 1;
 min-width: 0;
 color: var(--n-title-text-color);
 `), cE("extra", `
 display: flex;
 align-items: center;
 font-size: var(--n-font-size);
 font-weight: 400;
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 `), cE("close", `
 margin: 0 0 0 8px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("action", `
 box-sizing: border-box;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 background-clip: padding-box;
 background-color: var(--n-action-color);
 `), cE("content", "flex: 1; min-width: 0;"), cE("content, footer", `
 box-sizing: border-box;
 padding: 0 var(--n-padding-left) var(--n-padding-bottom) var(--n-padding-left);
 font-size: var(--n-font-size);
 `, [c$1("&:first-child", {
        paddingTop: "var(--n-padding-bottom)"
      })]), cE("action", `
 background-color: var(--n-action-color);
 padding: var(--n-padding-bottom) var(--n-padding-left);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 `)]), cB("card-cover", `
 overflow: hidden;
 width: 100%;
 border-radius: var(--n-border-radius) var(--n-border-radius) 0 0;
 `, [c$1("img", `
 display: block;
 width: 100%;
 `)]), cM("bordered", `
 border: 1px solid var(--n-border-color);
 `, [c$1("&:target", "border-color: var(--n-color-target);")]), cM("action-segmented", [c$1(">", [cE("action", [c$1("&:not(:first-child)", {
        borderTop: "1px solid var(--n-border-color)"
      })])])]), cM("content-segmented, content-soft-segmented", [c$1(">", [cE("content", {
        transition: "border-color 0.3s var(--n-bezier)"
      }, [c$1("&:not(:first-child)", {
        borderTop: "1px solid var(--n-border-color)"
      })])])]), cM("footer-segmented, footer-soft-segmented", [c$1(">", [cE("footer", {
        transition: "border-color 0.3s var(--n-bezier)"
      }, [c$1("&:not(:first-child)", {
        borderTop: "1px solid var(--n-border-color)"
      })])])]), cM("embedded", `
 background-color: var(--n-color-embedded);
 `)]), insideModal(cB("card", `
 background: var(--n-color-modal);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-modal);
 `)])), insidePopover(cB("card", `
 background: var(--n-color-popover);
 `, [cM("embedded", `
 background-color: var(--n-color-embedded-popover);
 `)]))]);
      const cardBaseProps = {
        title: [String, Function],
        contentClass: String,
        contentStyle: [Object, String],
        headerClass: String,
        headerStyle: [Object, String],
        headerExtraClass: String,
        headerExtraStyle: [Object, String],
        footerClass: String,
        footerStyle: [Object, String],
        embedded: Boolean,
        segmented: {
          type: [Boolean, Object],
          default: false
        },
        size: {
          type: String,
          default: "medium"
        },
        bordered: {
          type: Boolean,
          default: true
        },
        closable: Boolean,
        hoverable: Boolean,
        role: String,
        onClose: [Function, Array],
        tag: {
          type: String,
          default: "div"
        },
        cover: Function,
        content: [String, Function],
        footer: Function,
        action: Function,
        headerExtra: Function,
        closeFocusable: Boolean
      };
      const cardBasePropKeys = keysOf(cardBaseProps);
      const cardProps = Object.assign(Object.assign({}, useTheme.props), cardBaseProps);
      const NCard = vue.defineComponent({
        name: "Card",
        props: cardProps,
        slots: Object,
        setup(props) {
          const handleCloseClick = () => {
            const {
              onClose
            } = props;
            if (onClose) call(onClose);
          };
          const {
            inlineThemeDisabled,
            mergedClsPrefixRef,
            mergedRtlRef
          } = useConfig(props);
          const themeRef = useTheme("Card", "-card", style$k, cardLight, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Card", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              size: size2
            } = props;
            const {
              self: {
                color,
                colorModal,
                colorTarget,
                textColor,
                titleTextColor,
                titleFontWeight,
                borderColor,
                actionColor,
                borderRadius,
                lineHeight: lineHeight2,
                closeIconColor,
                closeIconColorHover,
                closeIconColorPressed,
                closeColorHover,
                closeColorPressed,
                closeBorderRadius,
                closeIconSize,
                closeSize,
                boxShadow,
                colorPopover,
                colorEmbedded,
                colorEmbeddedModal,
                colorEmbeddedPopover,
                [createKey("padding", size2)]: padding,
                [createKey("fontSize", size2)]: fontSize2,
                [createKey("titleFontSize", size2)]: titleFontSize
              },
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              }
            } = themeRef.value;
            const {
              top: paddingTop,
              left: paddingLeft,
              bottom: paddingBottom
            } = getMargin(padding);
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-color": color,
              "--n-color-modal": colorModal,
              "--n-color-popover": colorPopover,
              "--n-color-embedded": colorEmbedded,
              "--n-color-embedded-modal": colorEmbeddedModal,
              "--n-color-embedded-popover": colorEmbeddedPopover,
              "--n-color-target": colorTarget,
              "--n-text-color": textColor,
              "--n-line-height": lineHeight2,
              "--n-action-color": actionColor,
              "--n-title-text-color": titleTextColor,
              "--n-title-font-weight": titleFontWeight,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-border-color": borderColor,
              "--n-box-shadow": boxShadow,
"--n-padding-top": paddingTop,
              "--n-padding-bottom": paddingBottom,
              "--n-padding-left": paddingLeft,
              "--n-font-size": fontSize2,
              "--n-title-font-size": titleFontSize,
              "--n-close-size": closeSize,
              "--n-close-icon-size": closeIconSize,
              "--n-close-border-radius": closeBorderRadius
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("card", vue.computed(() => {
            return props.size[0];
          }), cssVarsRef, props) : void 0;
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: themeRef,
            handleCloseClick,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const {
            segmented,
            bordered,
            hoverable,
            mergedClsPrefix,
            rtlEnabled,
            onRender,
            embedded,
            tag: Component,
            $slots
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h(Component, {
            class: [`${mergedClsPrefix}-card`, this.themeClass, embedded && `${mergedClsPrefix}-card--embedded`, {
              [`${mergedClsPrefix}-card--rtl`]: rtlEnabled,
              [`${mergedClsPrefix}-card--content${typeof segmented !== "boolean" && segmented.content === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.content,
              [`${mergedClsPrefix}-card--footer${typeof segmented !== "boolean" && segmented.footer === "soft" ? "-soft" : ""}-segmented`]: segmented === true || segmented !== false && segmented.footer,
              [`${mergedClsPrefix}-card--action-segmented`]: segmented === true || segmented !== false && segmented.action,
              [`${mergedClsPrefix}-card--bordered`]: bordered,
              [`${mergedClsPrefix}-card--hoverable`]: hoverable
            }],
            style: this.cssVars,
            role: this.role
          }, resolveWrappedSlot($slots.cover, (children) => {
            const mergedChildren = this.cover ? ensureValidVNode([this.cover()]) : children;
            return mergedChildren && vue.h("div", {
              class: `${mergedClsPrefix}-card-cover`,
              role: "none"
            }, mergedChildren);
          }), resolveWrappedSlot($slots.header, (children) => {
            const {
              title
            } = this;
            const mergedChildren = title ? ensureValidVNode(typeof title === "function" ? [title()] : [title]) : children;
            return mergedChildren || this.closable ? vue.h("div", {
              class: [`${mergedClsPrefix}-card-header`, this.headerClass],
              style: this.headerStyle,
              role: "heading"
            }, vue.h("div", {
              class: `${mergedClsPrefix}-card-header__main`,
              role: "heading"
            }, mergedChildren), resolveWrappedSlot($slots["header-extra"], (children2) => {
              const mergedChildren2 = this.headerExtra ? ensureValidVNode([this.headerExtra()]) : children2;
              return mergedChildren2 && vue.h("div", {
                class: [`${mergedClsPrefix}-card-header__extra`, this.headerExtraClass],
                style: this.headerExtraStyle
              }, mergedChildren2);
            }), this.closable && vue.h(NBaseClose, {
              clsPrefix: mergedClsPrefix,
              class: `${mergedClsPrefix}-card-header__close`,
              onClick: this.handleCloseClick,
              focusable: this.closeFocusable,
              absolute: true
            })) : null;
          }), resolveWrappedSlot($slots.default, (children) => {
            const {
              content
            } = this;
            const mergedChildren = content ? ensureValidVNode(typeof content === "function" ? [content()] : [content]) : children;
            return mergedChildren && vue.h("div", {
              class: [`${mergedClsPrefix}-card__content`, this.contentClass],
              style: this.contentStyle,
              role: "none"
            }, mergedChildren);
          }), resolveWrappedSlot($slots.footer, (children) => {
            const mergedChildren = this.footer ? ensureValidVNode([this.footer()]) : children;
            return mergedChildren && vue.h("div", {
              class: [`${mergedClsPrefix}-card__footer`, this.footerClass],
              style: this.footerStyle,
              role: "none"
            }, mergedChildren);
          }), resolveWrappedSlot($slots.action, (children) => {
            const mergedChildren = this.action ? ensureValidVNode([this.action()]) : children;
            return mergedChildren && vue.h("div", {
              class: `${mergedClsPrefix}-card__action`,
              role: "none"
            }, mergedChildren);
          }));
        }
      });
      const commonVariables$6 = {
        sizeSmall: "14px",
        sizeMedium: "16px",
        sizeLarge: "18px",
        labelPadding: "0 8px",
        labelFontWeight: "400"
      };
      function self$k(vars) {
        const {
          baseColor,
          inputColorDisabled,
          cardColor,
          modalColor,
          popoverColor,
          textColorDisabled,
          borderColor,
          primaryColor,
          textColor2,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadiusSmall,
          lineHeight: lineHeight2
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$6), {
          labelLineHeight: lineHeight2,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderRadius: borderRadiusSmall,
          color: baseColor,
          colorChecked: primaryColor,
          colorDisabled: inputColorDisabled,
          colorDisabledChecked: inputColorDisabled,
          colorTableHeader: cardColor,
          colorTableHeaderModal: modalColor,
          colorTableHeaderPopover: popoverColor,
          checkMarkColor: baseColor,
          checkMarkColorDisabled: textColorDisabled,
          checkMarkColorDisabledChecked: textColorDisabled,
          border: `1px solid ${borderColor}`,
          borderDisabled: `1px solid ${borderColor}`,
          borderDisabledChecked: `1px solid ${borderColor}`,
          borderChecked: `1px solid ${primaryColor}`,
          borderFocus: `1px solid ${primaryColor}`,
          boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.3
        })}`,
          textColor: textColor2,
          textColorDisabled
        });
      }
      const checkboxLight = {
        name: "Checkbox",
        common: derived,
        self: self$k
      };
      const checkboxGroupInjectionKey = createInjectionKey("n-checkbox-group");
      const checkboxGroupProps = {
        min: Number,
        max: Number,
        size: String,
        value: Array,
        defaultValue: {
          type: Array,
          default: null
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
onChange: [Function, Array]
      };
      const NCheckboxGroup = vue.defineComponent({
        name: "CheckboxGroup",
        props: checkboxGroupProps,
        setup(props) {
          const {
            mergedClsPrefixRef
          } = useConfig(props);
          const formItem = useFormItem(props);
          const {
            mergedSizeRef,
            mergedDisabledRef
          } = formItem;
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.computed(() => props.value);
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const checkedCount = vue.computed(() => {
            var _a;
            return ((_a = mergedValueRef.value) === null || _a === void 0 ? void 0 : _a.length) || 0;
          });
          const valueSetRef = vue.computed(() => {
            if (Array.isArray(mergedValueRef.value)) {
              return new Set(mergedValueRef.value);
            }
            return new Set();
          });
          function toggleCheckbox(checked, checkboxValue) {
            const {
              nTriggerFormInput,
              nTriggerFormChange
            } = formItem;
            const {
              onChange,
              "onUpdate:value": _onUpdateValue,
              onUpdateValue
            } = props;
            if (Array.isArray(mergedValueRef.value)) {
              const groupValue = Array.from(mergedValueRef.value);
              const index = groupValue.findIndex((value) => value === checkboxValue);
              if (checked) {
                if (!~index) {
                  groupValue.push(checkboxValue);
                  if (onUpdateValue) {
                    call(onUpdateValue, groupValue, {
                      actionType: "check",
                      value: checkboxValue
                    });
                  }
                  if (_onUpdateValue) {
                    call(_onUpdateValue, groupValue, {
                      actionType: "check",
                      value: checkboxValue
                    });
                  }
                  nTriggerFormInput();
                  nTriggerFormChange();
                  uncontrolledValueRef.value = groupValue;
                  if (onChange) call(onChange, groupValue);
                }
              } else {
                if (~index) {
                  groupValue.splice(index, 1);
                  if (onUpdateValue) {
                    call(onUpdateValue, groupValue, {
                      actionType: "uncheck",
                      value: checkboxValue
                    });
                  }
                  if (_onUpdateValue) {
                    call(_onUpdateValue, groupValue, {
                      actionType: "uncheck",
                      value: checkboxValue
                    });
                  }
                  if (onChange) call(onChange, groupValue);
                  uncontrolledValueRef.value = groupValue;
                  nTriggerFormInput();
                  nTriggerFormChange();
                }
              }
            } else {
              if (checked) {
                if (onUpdateValue) {
                  call(onUpdateValue, [checkboxValue], {
                    actionType: "check",
                    value: checkboxValue
                  });
                }
                if (_onUpdateValue) {
                  call(_onUpdateValue, [checkboxValue], {
                    actionType: "check",
                    value: checkboxValue
                  });
                }
                if (onChange) call(onChange, [checkboxValue]);
                uncontrolledValueRef.value = [checkboxValue];
                nTriggerFormInput();
                nTriggerFormChange();
              } else {
                if (onUpdateValue) {
                  call(onUpdateValue, [], {
                    actionType: "uncheck",
                    value: checkboxValue
                  });
                }
                if (_onUpdateValue) {
                  call(_onUpdateValue, [], {
                    actionType: "uncheck",
                    value: checkboxValue
                  });
                }
                if (onChange) call(onChange, []);
                uncontrolledValueRef.value = [];
                nTriggerFormInput();
                nTriggerFormChange();
              }
            }
          }
          vue.provide(checkboxGroupInjectionKey, {
            checkedCountRef: checkedCount,
            maxRef: vue.toRef(props, "max"),
            minRef: vue.toRef(props, "min"),
            valueSetRef,
            disabledRef: mergedDisabledRef,
            mergedSizeRef,
            toggleCheckbox
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef
          };
        },
        render() {
          return vue.h("div", {
            class: `${this.mergedClsPrefix}-checkbox-group`,
            role: "group"
          }, this.$slots);
        }
      });
      const renderCheckMark = () => vue.h("svg", {
        viewBox: "0 0 64 64",
        class: "check-icon"
      }, vue.h("path", {
        d: "M50.42,16.76L22.34,39.45l-8.1-11.46c-1.12-1.58-3.3-1.96-4.88-0.84c-1.58,1.12-1.95,3.3-0.84,4.88l10.26,14.51  c0.56,0.79,1.42,1.31,2.38,1.45c0.16,0.02,0.32,0.03,0.48,0.03c0.8,0,1.57-0.27,2.2-0.78l30.99-25.03c1.5-1.21,1.74-3.42,0.52-4.92  C54.13,15.78,51.93,15.55,50.42,16.76z"
      }));
      const renderLineMark = () => vue.h("svg", {
        viewBox: "0 0 100 100",
        class: "line-icon"
      }, vue.h("path", {
        d: "M80.2,55.5H21.4c-2.8,0-5.1-2.5-5.1-5.5l0,0c0-3,2.3-5.5,5.1-5.5h58.7c2.8,0,5.1,2.5,5.1,5.5l0,0C85.2,53.1,82.9,55.5,80.2,55.5z"
      }));
      const style$j = c$1([
        cB("checkbox", `
 font-size: var(--n-font-size);
 outline: none;
 cursor: pointer;
 display: inline-flex;
 flex-wrap: nowrap;
 align-items: flex-start;
 word-break: break-word;
 line-height: var(--n-size);
 --n-merged-color-table: var(--n-color-table);
 `, [cM("show-label", "line-height: var(--n-label-line-height);"), c$1("&:hover", [cB("checkbox-box", [cE("border", "border: var(--n-border-checked);")])]), c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-focus);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cM("inside-table", [cB("checkbox-box", `
 background-color: var(--n-merged-color-table);
 `)]), cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-checked);
 `, [cB("checkbox-icon", [
c$1(".check-icon", `
 opacity: 1;
 transform: scale(1);
 `)
        ])])]), cM("indeterminate", [cB("checkbox-box", [cB("checkbox-icon", [c$1(".check-icon", `
 opacity: 0;
 transform: scale(.5);
 `), c$1(".line-icon", `
 opacity: 1;
 transform: scale(1);
 `)])])]), cM("checked, indeterminate", [c$1("&:focus:not(:active)", [cB("checkbox-box", [cE("border", `
 border: var(--n-border-checked);
 box-shadow: var(--n-box-shadow-focus);
 `)])]), cB("checkbox-box", `
 background-color: var(--n-color-checked);
 border-left: 0;
 border-top: 0;
 `, [cE("border", {
          border: "var(--n-border-checked)"
        })])]), cM("disabled", {
          cursor: "not-allowed"
        }, [cM("checked", [cB("checkbox-box", `
 background-color: var(--n-color-disabled-checked);
 `, [cE("border", {
          border: "var(--n-border-disabled-checked)"
        }), cB("checkbox-icon", [c$1(".check-icon, .line-icon", {
          fill: "var(--n-check-mark-color-disabled-checked)"
        })])])]), cB("checkbox-box", `
 background-color: var(--n-color-disabled);
 `, [cE("border", `
 border: var(--n-border-disabled);
 `), cB("checkbox-icon", [c$1(".check-icon, .line-icon", `
 fill: var(--n-check-mark-color-disabled);
 `)])]), cE("label", `
 color: var(--n-text-color-disabled);
 `)]), cB("checkbox-box-wrapper", `
 position: relative;
 width: var(--n-size);
 flex-shrink: 0;
 flex-grow: 0;
 user-select: none;
 -webkit-user-select: none;
 `), cB("checkbox-box", `
 position: absolute;
 left: 0;
 top: 50%;
 transform: translateY(-50%);
 height: var(--n-size);
 width: var(--n-size);
 display: inline-block;
 box-sizing: border-box;
 border-radius: var(--n-border-radius);
 background-color: var(--n-color);
 transition: background-color 0.3s var(--n-bezier);
 `, [cE("border", `
 transition:
 border-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 border-radius: inherit;
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 border: var(--n-border);
 `), cB("checkbox-icon", `
 display: flex;
 align-items: center;
 justify-content: center;
 position: absolute;
 left: 1px;
 right: 1px;
 top: 1px;
 bottom: 1px;
 `, [c$1(".check-icon, .line-icon", `
 width: 100%;
 fill: var(--n-check-mark-color);
 opacity: 0;
 transform: scale(0.5);
 transform-origin: center;
 transition:
 fill 0.3s var(--n-bezier),
 transform 0.3s var(--n-bezier),
 opacity 0.3s var(--n-bezier),
 border-color 0.3s var(--n-bezier);
 `), iconSwitchTransition({
          left: "1px",
          top: "1px"
        })])]), cE("label", `
 color: var(--n-text-color);
 transition: color .3s var(--n-bezier);
 user-select: none;
 -webkit-user-select: none;
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 `, [c$1("&:empty", {
          display: "none"
        })])]),
insideModal(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-modal);
 `)),
insidePopover(cB("checkbox", `
 --n-merged-color-table: var(--n-color-table-popover);
 `))
      ]);
      const checkboxProps = Object.assign(Object.assign({}, useTheme.props), {
        size: String,
        checked: {
          type: [Boolean, String, Number],
          default: void 0
        },
        defaultChecked: {
          type: [Boolean, String, Number],
          default: false
        },
        value: [String, Number],
        disabled: {
          type: Boolean,
          default: void 0
        },
        indeterminate: Boolean,
        label: String,
        focusable: {
          type: Boolean,
          default: true
        },
        checkedValue: {
          type: [Boolean, String, Number],
          default: true
        },
        uncheckedValue: {
          type: [Boolean, String, Number],
          default: false
        },
        "onUpdate:checked": [Function, Array],
        onUpdateChecked: [Function, Array],
privateInsideTable: Boolean,
onChange: [Function, Array]
      });
      const NCheckbox = vue.defineComponent({
        name: "Checkbox",
        props: checkboxProps,
        setup(props) {
          const NCheckboxGroup2 = vue.inject(checkboxGroupInjectionKey, null);
          const selfRef = vue.ref(null);
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const uncontrolledCheckedRef = vue.ref(props.defaultChecked);
          const controlledCheckedRef = vue.toRef(props, "checked");
          const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
          const renderedCheckedRef = useMemo(() => {
            if (NCheckboxGroup2) {
              const groupValueSet = NCheckboxGroup2.valueSetRef.value;
              if (groupValueSet && props.value !== void 0) {
                return groupValueSet.has(props.value);
              }
              return false;
            } else {
              return mergedCheckedRef.value === props.checkedValue;
            }
          });
          const formItem = useFormItem(props, {
            mergedSize(NFormItem2) {
              const {
                size: size2
              } = props;
              if (size2 !== void 0) return size2;
              if (NCheckboxGroup2) {
                const {
                  value: mergedSize
                } = NCheckboxGroup2.mergedSizeRef;
                if (mergedSize !== void 0) {
                  return mergedSize;
                }
              }
              if (NFormItem2) {
                const {
                  mergedSize
                } = NFormItem2;
                if (mergedSize !== void 0) return mergedSize.value;
              }
              return "medium";
            },
            mergedDisabled(NFormItem2) {
              const {
                disabled
              } = props;
              if (disabled !== void 0) return disabled;
              if (NCheckboxGroup2) {
                if (NCheckboxGroup2.disabledRef.value) return true;
                const {
                  maxRef: {
                    value: max
                  },
                  checkedCountRef
                } = NCheckboxGroup2;
                if (max !== void 0 && checkedCountRef.value >= max && !renderedCheckedRef.value) {
                  return true;
                }
                const {
                  minRef: {
                    value: min
                  }
                } = NCheckboxGroup2;
                if (min !== void 0 && checkedCountRef.value <= min && renderedCheckedRef.value) {
                  return true;
                }
              }
              if (NFormItem2) {
                return NFormItem2.disabled.value;
              }
              return false;
            }
          });
          const {
            mergedDisabledRef,
            mergedSizeRef
          } = formItem;
          const themeRef = useTheme("Checkbox", "-checkbox", style$j, checkboxLight, props, mergedClsPrefixRef);
          function toggle(e) {
            if (NCheckboxGroup2 && props.value !== void 0) {
              NCheckboxGroup2.toggleCheckbox(!renderedCheckedRef.value, props.value);
            } else {
              const {
                onChange,
                "onUpdate:checked": _onUpdateCheck,
                onUpdateChecked
              } = props;
              const {
                nTriggerFormInput,
                nTriggerFormChange
              } = formItem;
              const nextChecked = renderedCheckedRef.value ? props.uncheckedValue : props.checkedValue;
              if (_onUpdateCheck) {
                call(_onUpdateCheck, nextChecked, e);
              }
              if (onUpdateChecked) {
                call(onUpdateChecked, nextChecked, e);
              }
              if (onChange) call(onChange, nextChecked, e);
              nTriggerFormInput();
              nTriggerFormChange();
              uncontrolledCheckedRef.value = nextChecked;
            }
          }
          function handleClick2(e) {
            if (!mergedDisabledRef.value) {
              toggle(e);
            }
          }
          function handleKeyUp(e) {
            if (mergedDisabledRef.value) return;
            switch (e.key) {
              case " ":
              case "Enter":
                toggle(e);
            }
          }
          function handleKeyDown(e) {
            switch (e.key) {
              case " ":
                e.preventDefault();
            }
          }
          const exposedMethods = {
            focus: () => {
              var _a;
              (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            },
            blur: () => {
              var _a;
              (_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            }
          };
          const rtlEnabledRef = useRtl("Checkbox", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              value: mergedSize
            } = mergedSizeRef;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                borderRadius,
                color,
                colorChecked,
                colorDisabled,
                colorTableHeader,
                colorTableHeaderModal,
                colorTableHeaderPopover,
                checkMarkColor,
                checkMarkColorDisabled,
                border,
                borderFocus,
                borderDisabled,
                borderChecked,
                boxShadowFocus,
                textColor,
                textColorDisabled,
                checkMarkColorDisabledChecked,
                colorDisabledChecked,
                borderDisabledChecked,
                labelPadding,
                labelLineHeight,
                labelFontWeight,
                [createKey("fontSize", mergedSize)]: fontSize2,
                [createKey("size", mergedSize)]: size2
              }
            } = themeRef.value;
            return {
              "--n-label-line-height": labelLineHeight,
              "--n-label-font-weight": labelFontWeight,
              "--n-size": size2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-border": border,
              "--n-border-checked": borderChecked,
              "--n-border-focus": borderFocus,
              "--n-border-disabled": borderDisabled,
              "--n-border-disabled-checked": borderDisabledChecked,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-color": color,
              "--n-color-checked": colorChecked,
              "--n-color-table": colorTableHeader,
              "--n-color-table-modal": colorTableHeaderModal,
              "--n-color-table-popover": colorTableHeaderPopover,
              "--n-color-disabled": colorDisabled,
              "--n-color-disabled-checked": colorDisabledChecked,
              "--n-text-color": textColor,
              "--n-text-color-disabled": textColorDisabled,
              "--n-check-mark-color": checkMarkColor,
              "--n-check-mark-color-disabled": checkMarkColorDisabled,
              "--n-check-mark-color-disabled-checked": checkMarkColorDisabledChecked,
              "--n-font-size": fontSize2,
              "--n-label-padding": labelPadding
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("checkbox", vue.computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
          return Object.assign(formItem, exposedMethods, {
            rtlEnabled: rtlEnabledRef,
            selfRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedDisabled: mergedDisabledRef,
            renderedChecked: renderedCheckedRef,
            mergedTheme: themeRef,
            labelId: createId(),
            handleClick: handleClick2,
            handleKeyUp,
            handleKeyDown,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a;
          const {
            $slots,
            renderedChecked,
            mergedDisabled,
            indeterminate,
            privateInsideTable,
            cssVars,
            labelId,
            label,
            mergedClsPrefix,
            focusable,
            handleKeyUp,
            handleKeyDown,
            handleClick: handleClick2
          } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const labelNode = resolveWrappedSlot($slots.default, (children) => {
            if (label || children) {
              return vue.h("span", {
                class: `${mergedClsPrefix}-checkbox__label`,
                id: labelId
              }, label || children);
            }
            return null;
          });
          return vue.h("div", {
            ref: "selfRef",
            class: [`${mergedClsPrefix}-checkbox`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-checkbox--rtl`, renderedChecked && `${mergedClsPrefix}-checkbox--checked`, mergedDisabled && `${mergedClsPrefix}-checkbox--disabled`, indeterminate && `${mergedClsPrefix}-checkbox--indeterminate`, privateInsideTable && `${mergedClsPrefix}-checkbox--inside-table`, labelNode && `${mergedClsPrefix}-checkbox--show-label`],
            tabindex: mergedDisabled || !focusable ? void 0 : 0,
            role: "checkbox",
            "aria-checked": indeterminate ? "mixed" : renderedChecked,
            "aria-labelledby": labelId,
            style: cssVars,
            onKeyup: handleKeyUp,
            onKeydown: handleKeyDown,
            onClick: handleClick2,
            onMousedown: () => {
              on("selectstart", window, (e) => {
                e.preventDefault();
              }, {
                once: true
              });
            }
          }, vue.h("div", {
            class: `${mergedClsPrefix}-checkbox-box-wrapper`
          }, " ", vue.h("div", {
            class: `${mergedClsPrefix}-checkbox-box`
          }, vue.h(NIconSwitchTransition, null, {
            default: () => this.indeterminate ? vue.h("div", {
              key: "indeterminate",
              class: `${mergedClsPrefix}-checkbox-icon`
            }, renderLineMark()) : vue.h("div", {
              key: "check",
              class: `${mergedClsPrefix}-checkbox-icon`
            }, renderCheckMark())
          }), vue.h("div", {
            class: `${mergedClsPrefix}-checkbox-box__border`
          }))), labelNode);
        }
      });
      const configProviderProps = {
        abstract: Boolean,
        bordered: {
          type: Boolean,
          default: void 0
        },
        clsPrefix: String,
        locale: Object,
        dateLocale: Object,
        namespace: String,
        rtl: Array,
        tag: {
          type: String,
          default: "div"
        },
        hljs: Object,
        katex: Object,
        theme: Object,
        themeOverrides: Object,
        componentOptions: Object,
        icons: Object,
        breakpoints: Object,
        preflightStyleDisabled: Boolean,
        styleMountTarget: Object,
        inlineThemeDisabled: {
          type: Boolean,
          default: void 0
        },
as: {
          type: String,
          validator: () => {
            warn("config-provider", "`as` is deprecated, please use `tag` instead.");
            return true;
          },
          default: void 0
        }
      };
      const NConfigProvider = vue.defineComponent({
        name: "ConfigProvider",
        alias: ["App"],
        props: configProviderProps,
        setup(props) {
          const NConfigProvider2 = vue.inject(configProviderInjectionKey, null);
          const mergedThemeRef = vue.computed(() => {
            const {
              theme
            } = props;
            if (theme === null) return void 0;
            const inheritedTheme = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeRef.value;
            return theme === void 0 ? inheritedTheme : inheritedTheme === void 0 ? theme : Object.assign({}, inheritedTheme, theme);
          });
          const mergedThemeOverridesRef = vue.computed(() => {
            const {
              themeOverrides
            } = props;
            if (themeOverrides === null) return void 0;
            if (themeOverrides === void 0) {
              return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
            } else {
              const inheritedThemeOverrides = NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedThemeOverridesRef.value;
              if (inheritedThemeOverrides === void 0) {
                return themeOverrides;
              } else {
                return merge$1({}, inheritedThemeOverrides, themeOverrides);
              }
            }
          });
          const mergedNamespaceRef = useMemo(() => {
            const {
              namespace: namespace2
            } = props;
            return namespace2 === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedNamespaceRef.value : namespace2;
          });
          const mergedBorderedRef = useMemo(() => {
            const {
              bordered
            } = props;
            return bordered === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBorderedRef.value : bordered;
          });
          const mergedIconsRef = vue.computed(() => {
            const {
              icons
            } = props;
            return icons === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedIconsRef.value : icons;
          });
          const mergedComponentPropsRef = vue.computed(() => {
            const {
              componentOptions
            } = props;
            if (componentOptions !== void 0) return componentOptions;
            return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedComponentPropsRef.value;
          });
          const mergedClsPrefixRef = vue.computed(() => {
            const {
              clsPrefix
            } = props;
            if (clsPrefix !== void 0) return clsPrefix;
            if (NConfigProvider2) return NConfigProvider2.mergedClsPrefixRef.value;
            return defaultClsPrefix;
          });
          const mergedRtlRef = vue.computed(() => {
            var _a;
            const {
              rtl
            } = props;
            if (rtl === void 0) {
              return NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedRtlRef.value;
            }
            const rtlEnabledState = {};
            for (const rtlInfo of rtl) {
              rtlEnabledState[rtlInfo.name] = vue.markRaw(rtlInfo);
              (_a = rtlInfo.peers) === null || _a === void 0 ? void 0 : _a.forEach((peerRtlInfo) => {
                if (!(peerRtlInfo.name in rtlEnabledState)) {
                  rtlEnabledState[peerRtlInfo.name] = vue.markRaw(peerRtlInfo);
                }
              });
            }
            return rtlEnabledState;
          });
          const mergedBreakpointsRef = vue.computed(() => {
            return props.breakpoints || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedBreakpointsRef.value);
          });
          const inlineThemeDisabled = props.inlineThemeDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.inlineThemeDisabled);
          const preflightStyleDisabled = props.preflightStyleDisabled || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.preflightStyleDisabled);
          const styleMountTarget = props.styleMountTarget || (NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget);
          const mergedThemeHashRef = vue.computed(() => {
            const {
              value: theme
            } = mergedThemeRef;
            const {
              value: mergedThemeOverrides
            } = mergedThemeOverridesRef;
            const hasThemeOverrides = mergedThemeOverrides && Object.keys(mergedThemeOverrides).length !== 0;
            const themeName = theme === null || theme === void 0 ? void 0 : theme.name;
            if (themeName) {
              if (hasThemeOverrides) {
                return `${themeName}-${murmur2(JSON.stringify(mergedThemeOverridesRef.value))}`;
              }
              return themeName;
            } else {
              if (hasThemeOverrides) {
                return murmur2(JSON.stringify(mergedThemeOverridesRef.value));
              }
              return "";
            }
          });
          vue.provide(configProviderInjectionKey, {
            mergedThemeHashRef,
            mergedBreakpointsRef,
            mergedRtlRef,
            mergedIconsRef,
            mergedComponentPropsRef,
            mergedBorderedRef,
            mergedNamespaceRef,
            mergedClsPrefixRef,
            mergedLocaleRef: vue.computed(() => {
              const {
                locale
              } = props;
              if (locale === null) return void 0;
              return locale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedLocaleRef.value : locale;
            }),
            mergedDateLocaleRef: vue.computed(() => {
              const {
                dateLocale
              } = props;
              if (dateLocale === null) return void 0;
              return dateLocale === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedDateLocaleRef.value : dateLocale;
            }),
            mergedHljsRef: vue.computed(() => {
              const {
                hljs
              } = props;
              return hljs === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedHljsRef.value : hljs;
            }),
            mergedKatexRef: vue.computed(() => {
              const {
                katex
              } = props;
              return katex === void 0 ? NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.mergedKatexRef.value : katex;
            }),
            mergedThemeRef,
            mergedThemeOverridesRef,
            inlineThemeDisabled: inlineThemeDisabled || false,
            preflightStyleDisabled: preflightStyleDisabled || false,
            styleMountTarget
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            mergedNamespace: mergedNamespaceRef,
            mergedTheme: mergedThemeRef,
            mergedThemeOverrides: mergedThemeOverridesRef
          };
        },
        render() {
          var _a, _b, _c, _d;
          return !this.abstract ? vue.h(this.as || this.tag, {
            class: `${this.mergedClsPrefix || defaultClsPrefix}-config-provider`
          }, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)) : (_d = (_c = this.$slots).default) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
      });
      function self$j(vars) {
        const {
          boxShadow2
        } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }
      const popselectLight = createTheme({
        name: "Popselect",
        common: derived,
        peers: {
          Popover: popoverLight,
          InternalSelectMenu: internalSelectMenuLight
        },
        self: self$j
      });
      const popselectInjectionKey = createInjectionKey("n-popselect");
      const style$i = cB("popselect-menu", `
 box-shadow: var(--n-menu-box-shadow);
`);
      const panelProps$1 = {
        multiple: Boolean,
        value: {
          type: [String, Number, Array],
          default: null
        },
        cancelable: Boolean,
        options: {
          type: Array,
          default: () => []
        },
        size: {
          type: String,
          default: "medium"
        },
        scrollable: Boolean,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        onMouseenter: Function,
        onMouseleave: Function,
        renderLabel: Function,
        showCheckmark: {
          type: Boolean,
          default: void 0
        },
        nodeProps: Function,
        virtualScroll: Boolean,
onChange: [Function, Array]
      };
      const panelPropKeys$1 = keysOf(panelProps$1);
      const NPopselectPanel = vue.defineComponent({
        name: "PopselectPanel",
        props: panelProps$1,
        setup(props) {
          const NPopselect2 = vue.inject(popselectInjectionKey);
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled
          } = useConfig(props);
          const themeRef = useTheme("Popselect", "-pop-select", style$i, popselectLight, NPopselect2.props, mergedClsPrefixRef);
          const treeMateRef = vue.computed(() => {
            return createTreeMate(props.options, createTmOptions("value", "children"));
          });
          function doUpdateValue(value, option) {
            const {
              onUpdateValue,
              "onUpdate:value": _onUpdateValue,
              onChange
            } = props;
            if (onUpdateValue) call(onUpdateValue, value, option);
            if (_onUpdateValue) {
              call(_onUpdateValue, value, option);
            }
            if (onChange) call(onChange, value, option);
          }
          function handleToggle(tmNode) {
            toggle(tmNode.key);
          }
          function handleMenuMousedown(e) {
            if (!happensIn(e, "action") && !happensIn(e, "empty") && !happensIn(e, "header")) {
              e.preventDefault();
            }
          }
          function toggle(value) {
            const {
              value: {
                getNode
              }
            } = treeMateRef;
            if (props.multiple) {
              if (Array.isArray(props.value)) {
                const newValue = [];
                const newOptions = [];
                let shouldAddValue = true;
                props.value.forEach((v) => {
                  if (v === value) {
                    shouldAddValue = false;
                    return;
                  }
                  const tmNode = getNode(v);
                  if (tmNode) {
                    newValue.push(tmNode.key);
                    newOptions.push(tmNode.rawNode);
                  }
                });
                if (shouldAddValue) {
                  newValue.push(value);
                  newOptions.push(getNode(value).rawNode);
                }
                doUpdateValue(newValue, newOptions);
              } else {
                const tmNode = getNode(value);
                if (tmNode) {
                  doUpdateValue([value], [tmNode.rawNode]);
                }
              }
            } else {
              if (props.value === value && props.cancelable) {
                doUpdateValue(null, null);
              } else {
                const tmNode = getNode(value);
                if (tmNode) {
                  doUpdateValue(value, tmNode.rawNode);
                }
                const {
                  "onUpdate:show": _onUpdateShow,
                  onUpdateShow
                } = NPopselect2.props;
                if (_onUpdateShow) call(_onUpdateShow, false);
                if (onUpdateShow) call(onUpdateShow, false);
                NPopselect2.setShow(false);
              }
            }
            void vue.nextTick(() => {
              NPopselect2.syncPosition();
            });
          }
          vue.watch(vue.toRef(props, "options"), () => {
            void vue.nextTick(() => {
              NPopselect2.syncPosition();
            });
          });
          const cssVarsRef = vue.computed(() => {
            const {
              self: {
                menuBoxShadow
              }
            } = themeRef.value;
            return {
              "--n-menu-box-shadow": menuBoxShadow
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, NPopselect2.props) : void 0;
          return {
            mergedTheme: NPopselect2.mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            treeMate: treeMateRef,
            handleToggle,
            handleMenuMousedown,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h(NInternalSelectMenu, {
            clsPrefix: this.mergedClsPrefix,
            focusable: true,
            nodeProps: this.nodeProps,
            class: [`${this.mergedClsPrefix}-popselect-menu`, this.themeClass],
            style: this.cssVars,
            theme: this.mergedTheme.peers.InternalSelectMenu,
            themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu,
            multiple: this.multiple,
            treeMate: this.treeMate,
            size: this.size,
            value: this.value,
            virtualScroll: this.virtualScroll,
            scrollable: this.scrollable,
            renderLabel: this.renderLabel,
            onToggle: this.handleToggle,
            onMouseenter: this.onMouseenter,
            onMouseleave: this.onMouseenter,
            onMousedown: this.handleMenuMousedown,
            showCheckmark: this.showCheckmark
          }, {
            header: () => {
              var _a2, _b;
              return ((_b = (_a2 = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
            },
            action: () => {
              var _a2, _b;
              return ((_b = (_a2 = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
            },
            empty: () => {
              var _a2, _b;
              return ((_b = (_a2 = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a2)) || [];
            }
          });
        }
      });
      const popselectProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), omit(popoverBaseProps, ["showArrow", "arrow"])), {
        placement: Object.assign(Object.assign({}, popoverBaseProps.placement), {
          default: "bottom"
        }),
        trigger: {
          type: String,
          default: "hover"
        }
      }), panelProps$1);
      const NPopselect = vue.defineComponent({
        name: "Popselect",
        props: popselectProps,
        slots: Object,
        inheritAttrs: false,
        __popover__: true,
        setup(props) {
          const {
            mergedClsPrefixRef
          } = useConfig(props);
          const themeRef = useTheme("Popselect", "-popselect", void 0, popselectLight, props, mergedClsPrefixRef);
          const popoverInstRef = vue.ref(null);
          function syncPosition() {
            var _a;
            (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          function setShow(value) {
            var _a;
            (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(value);
          }
          vue.provide(popselectInjectionKey, {
            props,
            mergedThemeRef: themeRef,
            syncPosition,
            setShow
          });
          const exposedMethods = {
            syncPosition,
            setShow
          };
          return Object.assign(Object.assign({}, exposedMethods), {
            popoverInstRef,
            mergedTheme: themeRef
          });
        },
        render() {
          const {
            mergedTheme
          } = this;
          const popoverProps2 = {
            theme: mergedTheme.peers.Popover,
            themeOverrides: mergedTheme.peerOverrides.Popover,
            builtinThemeOverrides: {
              padding: "0"
            },
            ref: "popoverInstRef",
            internalRenderBody: (className, ref2, style2, onMouseenter, onMouseleave) => {
              const {
                $attrs
              } = this;
              return vue.h(NPopselectPanel, Object.assign({}, $attrs, {
                class: [$attrs.class, className],
                style: [$attrs.style, ...style2]
              }, keep(this.$props, panelPropKeys$1), {
                ref: createRefSetter(ref2),
                onMouseenter: mergeEventHandlers([onMouseenter, $attrs.onMouseenter]),
                onMouseleave: mergeEventHandlers([onMouseleave, $attrs.onMouseleave])
              }), {
                header: () => {
                  var _a, _b;
                  return (_b = (_a = this.$slots).header) === null || _b === void 0 ? void 0 : _b.call(_a);
                },
                action: () => {
                  var _a, _b;
                  return (_b = (_a = this.$slots).action) === null || _b === void 0 ? void 0 : _b.call(_a);
                },
                empty: () => {
                  var _a, _b;
                  return (_b = (_a = this.$slots).empty) === null || _b === void 0 ? void 0 : _b.call(_a);
                }
              });
            }
          };
          return vue.h(NPopover, Object.assign({}, omit(this.$props, panelPropKeys$1), popoverProps2, {
            internalDeactivateImmediately: true
          }), {
            trigger: () => {
              var _a, _b;
              return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
          });
        }
      });
      function self$i(vars) {
        const {
          boxShadow2
        } = vars;
        return {
          menuBoxShadow: boxShadow2
        };
      }
      const selectLight = createTheme({
        name: "Select",
        common: derived,
        peers: {
          InternalSelection: internalSelectionLight,
          InternalSelectMenu: internalSelectMenuLight
        },
        self: self$i
      });
      const style$h = c$1([cB("select", `
 z-index: auto;
 outline: none;
 width: 100%;
 position: relative;
 font-weight: var(--n-font-weight);
 `), cB("select-menu", `
 margin: 4px 0;
 box-shadow: var(--n-menu-box-shadow);
 `, [fadeInScaleUpTransition({
        originalTransition: "background-color .3s var(--n-bezier), box-shadow .3s var(--n-bezier)"
      })])]);
      const selectProps = Object.assign(Object.assign({}, useTheme.props), {
        to: useAdjustedTo.propTo,
        bordered: {
          type: Boolean,
          default: void 0
        },
        clearable: Boolean,
        clearFilterAfterSelect: {
          type: Boolean,
          default: true
        },
        options: {
          type: Array,
          default: () => []
        },
        defaultValue: {
          type: [String, Number, Array],
          default: null
        },
        keyboard: {
          type: Boolean,
          default: true
        },
        value: [String, Number, Array],
        placeholder: String,
        menuProps: Object,
        multiple: Boolean,
        size: String,
        menuSize: {
          type: String
        },
        filterable: Boolean,
        disabled: {
          type: Boolean,
          default: void 0
        },
        remote: Boolean,
        loading: Boolean,
        filter: Function,
        placement: {
          type: String,
          default: "bottom-start"
        },
        widthMode: {
          type: String,
          default: "trigger"
        },
        tag: Boolean,
        onCreate: Function,
        fallbackOption: {
          type: [Function, Boolean],
          default: void 0
        },
        show: {
          type: Boolean,
          default: void 0
        },
        showArrow: {
          type: Boolean,
          default: true
        },
        maxTagCount: [Number, String],
        ellipsisTagPopoverProps: Object,
        consistentMenuWidth: {
          type: Boolean,
          default: true
        },
        virtualScroll: {
          type: Boolean,
          default: true
        },
        labelField: {
          type: String,
          default: "label"
        },
        valueField: {
          type: String,
          default: "value"
        },
        childrenField: {
          type: String,
          default: "children"
        },
        renderLabel: Function,
        renderOption: Function,
        renderTag: Function,
        "onUpdate:value": [Function, Array],
        inputProps: Object,
        nodeProps: Function,
        ignoreComposition: {
          type: Boolean,
          default: true
        },
        showOnFocus: Boolean,
onUpdateValue: [Function, Array],
        onBlur: [Function, Array],
        onClear: [Function, Array],
        onFocus: [Function, Array],
        onScroll: [Function, Array],
        onSearch: [Function, Array],
        onUpdateShow: [Function, Array],
        "onUpdate:show": [Function, Array],
        displayDirective: {
          type: String,
          default: "show"
        },
        resetMenuOnOptionsChange: {
          type: Boolean,
          default: true
        },
        status: String,
        showCheckmark: {
          type: Boolean,
          default: true
        },
onChange: [Function, Array],
        items: Array
      });
      const NSelect = vue.defineComponent({
        name: "Select",
        props: selectProps,
        slots: Object,
        setup(props) {
          const {
            mergedClsPrefixRef,
            mergedBorderedRef,
            namespaceRef,
            inlineThemeDisabled
          } = useConfig(props);
          const themeRef = useTheme("Select", "-select", style$h, selectLight, props, mergedClsPrefixRef);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const focusedRef = vue.ref(false);
          const patternRef = vue.ref("");
          const compitableOptionsRef = useCompitable(props, ["items", "options"]);
          const createdOptionsRef = vue.ref([]);
          const beingCreatedOptionsRef = vue.ref([]);
          const localOptionsRef = vue.computed(() => {
            return beingCreatedOptionsRef.value.concat(createdOptionsRef.value).concat(compitableOptionsRef.value);
          });
          const resolvedFilterRef = vue.computed(() => {
            const {
              filter
            } = props;
            if (filter) return filter;
            const {
              labelField,
              valueField
            } = props;
            return (pattern, option) => {
              if (!option) return false;
              const label = option[labelField];
              if (typeof label === "string") {
                return patternMatched(pattern, label);
              }
              const value = option[valueField];
              if (typeof value === "string") {
                return patternMatched(pattern, value);
              }
              if (typeof value === "number") {
                return patternMatched(pattern, String(value));
              }
              return false;
            };
          });
          const filteredOptionsRef = vue.computed(() => {
            if (props.remote) {
              return compitableOptionsRef.value;
            } else {
              const {
                value: localOptions
              } = localOptionsRef;
              const {
                value: pattern
              } = patternRef;
              if (!pattern.length || !props.filterable) {
                return localOptions;
              } else {
                return filterOptions(localOptions, resolvedFilterRef.value, pattern, props.childrenField);
              }
            }
          });
          const treeMateRef = vue.computed(() => {
            const {
              valueField,
              childrenField
            } = props;
            const options = createTmOptions(valueField, childrenField);
            return createTreeMate(filteredOptionsRef.value, options);
          });
          const valOptMapRef = vue.computed(() => createValOptMap(localOptionsRef.value, props.valueField, props.childrenField));
          const uncontrolledShowRef = vue.ref(false);
          const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
          const triggerRef = vue.ref(null);
          const followerRef = vue.ref(null);
          const menuRef = vue.ref(null);
          const {
            localeRef
          } = useLocale("Select");
          const localizedPlaceholderRef = vue.computed(() => {
            var _a;
            return (_a = props.placeholder) !== null && _a !== void 0 ? _a : localeRef.value.placeholder;
          });
          const emptyArray = [];
          const memoValOptMapRef = vue.ref( new Map());
          const wrappedFallbackOptionRef = vue.computed(() => {
            const {
              fallbackOption
            } = props;
            if (fallbackOption === void 0) {
              const {
                labelField,
                valueField
              } = props;
              return (value) => ({
                [labelField]: String(value),
                [valueField]: value
              });
            }
            if (fallbackOption === false) return false;
            return (value) => {
              return Object.assign(fallbackOption(value), {
                value
              });
            };
          });
          function getMergedOptions(values) {
            const remote = props.remote;
            const {
              value: memoValOptMap
            } = memoValOptMapRef;
            const {
              value: valOptMap
            } = valOptMapRef;
            const {
              value: wrappedFallbackOption
            } = wrappedFallbackOptionRef;
            const options = [];
            values.forEach((value) => {
              if (valOptMap.has(value)) {
                options.push(valOptMap.get(value));
              } else if (remote && memoValOptMap.has(value)) {
                options.push(memoValOptMap.get(value));
              } else if (wrappedFallbackOption) {
                const option = wrappedFallbackOption(value);
                if (option) {
                  options.push(option);
                }
              }
            });
            return options;
          }
          const selectedOptionsRef = vue.computed(() => {
            if (props.multiple) {
              const {
                value: values
              } = mergedValueRef;
              if (!Array.isArray(values)) return [];
              return getMergedOptions(values);
            }
            return null;
          });
          const selectedOptionRef = vue.computed(() => {
            const {
              value: mergedValue
            } = mergedValueRef;
            if (!props.multiple && !Array.isArray(mergedValue)) {
              if (mergedValue === null) return null;
              return getMergedOptions([mergedValue])[0] || null;
            }
            return null;
          });
          const formItem = useFormItem(props);
          const {
            mergedSizeRef,
            mergedDisabledRef,
            mergedStatusRef
          } = formItem;
          function doUpdateValue(value, option) {
            const {
              onChange,
              "onUpdate:value": _onUpdateValue,
              onUpdateValue
            } = props;
            const {
              nTriggerFormChange,
              nTriggerFormInput
            } = formItem;
            if (onChange) call(onChange, value, option);
            if (onUpdateValue) call(onUpdateValue, value, option);
            if (_onUpdateValue) {
              call(_onUpdateValue, value, option);
            }
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
            nTriggerFormInput();
          }
          function doBlur(e) {
            const {
              onBlur
            } = props;
            const {
              nTriggerFormBlur
            } = formItem;
            if (onBlur) call(onBlur, e);
            nTriggerFormBlur();
          }
          function doClear() {
            const {
              onClear
            } = props;
            if (onClear) call(onClear);
          }
          function doFocus(e) {
            const {
              onFocus,
              showOnFocus
            } = props;
            const {
              nTriggerFormFocus
            } = formItem;
            if (onFocus) call(onFocus, e);
            nTriggerFormFocus();
            if (showOnFocus) {
              openMenu();
            }
          }
          function doSearch(value) {
            const {
              onSearch
            } = props;
            if (onSearch) call(onSearch, value);
          }
          function doScroll(e) {
            const {
              onScroll
            } = props;
            if (onScroll) call(onScroll, e);
          }
          function updateMemorizedOptions() {
            var _a;
            const {
              remote,
              multiple
            } = props;
            if (remote) {
              const {
                value: memoValOptMap
              } = memoValOptMapRef;
              if (multiple) {
                const {
                  valueField
                } = props;
                (_a = selectedOptionsRef.value) === null || _a === void 0 ? void 0 : _a.forEach((option) => {
                  memoValOptMap.set(option[valueField], option);
                });
              } else {
                const option = selectedOptionRef.value;
                if (option) {
                  memoValOptMap.set(option[props.valueField], option);
                }
              }
            }
          }
          function doUpdateShow(value) {
            const {
              onUpdateShow,
              "onUpdate:show": _onUpdateShow
            } = props;
            if (onUpdateShow) call(onUpdateShow, value);
            if (_onUpdateShow) call(_onUpdateShow, value);
            uncontrolledShowRef.value = value;
          }
          function openMenu() {
            if (!mergedDisabledRef.value) {
              doUpdateShow(true);
              uncontrolledShowRef.value = true;
              if (props.filterable) {
                focusSelectionInput();
              }
            }
          }
          function closeMenu() {
            doUpdateShow(false);
          }
          function handleMenuAfterLeave() {
            patternRef.value = "";
            beingCreatedOptionsRef.value = emptyArray;
          }
          const activeWithoutMenuOpenRef = vue.ref(false);
          function onTriggerInputFocus() {
            if (props.filterable) {
              activeWithoutMenuOpenRef.value = true;
            }
          }
          function onTriggerInputBlur() {
            if (props.filterable) {
              activeWithoutMenuOpenRef.value = false;
              if (!mergedShowRef.value) {
                handleMenuAfterLeave();
              }
            }
          }
          function handleTriggerClick() {
            if (mergedDisabledRef.value) return;
            if (!mergedShowRef.value) {
              openMenu();
            } else {
              if (!props.filterable) {
                closeMenu();
              } else {
                focusSelectionInput();
              }
            }
          }
          function handleTriggerBlur(e) {
            var _a, _b;
            if ((_b = (_a = menuRef.value) === null || _a === void 0 ? void 0 : _a.selfRef) === null || _b === void 0 ? void 0 : _b.contains(e.relatedTarget)) {
              return;
            }
            focusedRef.value = false;
            doBlur(e);
            closeMenu();
          }
          function handleTriggerFocus(e) {
            doFocus(e);
            focusedRef.value = true;
          }
          function handleMenuFocus() {
            focusedRef.value = true;
          }
          function handleMenuBlur(e) {
            var _a;
            if ((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(e.relatedTarget)) return;
            focusedRef.value = false;
            doBlur(e);
            closeMenu();
          }
          function handleMenuTabOut() {
            var _a;
            (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            closeMenu();
          }
          function handleMenuClickOutside(e) {
            var _a;
            if (mergedShowRef.value) {
              if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.$el.contains(getPreciseEventTarget(e)))) {
                closeMenu();
              }
            }
          }
          function createClearedMultipleSelectValue(value) {
            if (!Array.isArray(value)) return [];
            if (wrappedFallbackOptionRef.value) {
              return Array.from(value);
            } else {
              const {
                remote
              } = props;
              const {
                value: valOptMap
              } = valOptMapRef;
              if (remote) {
                const {
                  value: memoValOptMap
                } = memoValOptMapRef;
                return value.filter((v) => valOptMap.has(v) || memoValOptMap.has(v));
              } else {
                return value.filter((v) => valOptMap.has(v));
              }
            }
          }
          function handleToggleByTmNode(tmNode) {
            handleToggleByOption(tmNode.rawNode);
          }
          function handleToggleByOption(option) {
            if (mergedDisabledRef.value) return;
            const {
              tag,
              remote,
              clearFilterAfterSelect,
              valueField
            } = props;
            if (tag && !remote) {
              const {
                value: beingCreatedOptions
              } = beingCreatedOptionsRef;
              const beingCreatedOption = beingCreatedOptions[0] || null;
              if (beingCreatedOption) {
                const createdOptions = createdOptionsRef.value;
                if (!createdOptions.length) {
                  createdOptionsRef.value = [beingCreatedOption];
                } else {
                  createdOptions.push(beingCreatedOption);
                }
                beingCreatedOptionsRef.value = emptyArray;
              }
            }
            if (remote) {
              memoValOptMapRef.value.set(option[valueField], option);
            }
            if (props.multiple) {
              const changedValue = createClearedMultipleSelectValue(mergedValueRef.value);
              const index = changedValue.findIndex((value) => value === option[valueField]);
              if (~index) {
                changedValue.splice(index, 1);
                if (tag && !remote) {
                  const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
                  if (~createdOptionIndex) {
                    createdOptionsRef.value.splice(createdOptionIndex, 1);
                    if (clearFilterAfterSelect) patternRef.value = "";
                  }
                }
              } else {
                changedValue.push(option[valueField]);
                if (clearFilterAfterSelect) patternRef.value = "";
              }
              doUpdateValue(changedValue, getMergedOptions(changedValue));
            } else {
              if (tag && !remote) {
                const createdOptionIndex = getCreatedOptionIndex(option[valueField]);
                if (~createdOptionIndex) {
                  createdOptionsRef.value = [createdOptionsRef.value[createdOptionIndex]];
                } else {
                  createdOptionsRef.value = emptyArray;
                }
              }
              focusSelection();
              closeMenu();
              doUpdateValue(option[valueField], option);
            }
          }
          function getCreatedOptionIndex(optionValue) {
            const createdOptions = createdOptionsRef.value;
            return createdOptions.findIndex((createdOption) => createdOption[props.valueField] === optionValue);
          }
          function handlePatternInput(e) {
            if (!mergedShowRef.value) {
              openMenu();
            }
            const {
              value
            } = e.target;
            patternRef.value = value;
            const {
              tag,
              remote
            } = props;
            doSearch(value);
            if (tag && !remote) {
              if (!value) {
                beingCreatedOptionsRef.value = emptyArray;
                return;
              }
              const {
                onCreate
              } = props;
              const optionBeingCreated = onCreate ? onCreate(value) : {
                [props.labelField]: value,
                [props.valueField]: value
              };
              const {
                valueField,
                labelField
              } = props;
              if (compitableOptionsRef.value.some((option) => {
                return option[valueField] === optionBeingCreated[valueField] || option[labelField] === optionBeingCreated[labelField];
              }) || createdOptionsRef.value.some((option) => {
                return option[valueField] === optionBeingCreated[valueField] || option[labelField] === optionBeingCreated[labelField];
              })) {
                beingCreatedOptionsRef.value = emptyArray;
              } else {
                beingCreatedOptionsRef.value = [optionBeingCreated];
              }
            }
          }
          function handleClear(e) {
            e.stopPropagation();
            const {
              multiple
            } = props;
            if (!multiple && props.filterable) {
              closeMenu();
            }
            doClear();
            if (multiple) {
              doUpdateValue([], []);
            } else {
              doUpdateValue(null, null);
            }
          }
          function handleMenuMousedown(e) {
            if (!happensIn(e, "action") && !happensIn(e, "empty") && !happensIn(e, "header")) {
              e.preventDefault();
            }
          }
          function handleMenuScroll(e) {
            doScroll(e);
          }
          function handleKeydown(e) {
            var _a, _b, _c, _d, _e;
            if (!props.keyboard) {
              e.preventDefault();
              return;
            }
            switch (e.key) {
              case " ":
                if (props.filterable) {
                  break;
                } else {
                  e.preventDefault();
                }
case "Enter":
                if (!((_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.isComposing)) {
                  if (mergedShowRef.value) {
                    const pendingTmNode = (_b = menuRef.value) === null || _b === void 0 ? void 0 : _b.getPendingTmNode();
                    if (pendingTmNode) {
                      handleToggleByTmNode(pendingTmNode);
                    } else if (!props.filterable) {
                      closeMenu();
                      focusSelection();
                    }
                  } else {
                    openMenu();
                    if (props.tag && activeWithoutMenuOpenRef.value) {
                      const beingCreatedOption = beingCreatedOptionsRef.value[0];
                      if (beingCreatedOption) {
                        const optionValue = beingCreatedOption[props.valueField];
                        const {
                          value: mergedValue
                        } = mergedValueRef;
                        if (props.multiple) {
                          if (Array.isArray(mergedValue) && mergedValue.includes(optionValue)) ;
                          else {
                            handleToggleByOption(beingCreatedOption);
                          }
                        } else {
                          handleToggleByOption(beingCreatedOption);
                        }
                      }
                    }
                  }
                }
                e.preventDefault();
                break;
              case "ArrowUp":
                e.preventDefault();
                if (props.loading) return;
                if (mergedShowRef.value) {
                  (_c = menuRef.value) === null || _c === void 0 ? void 0 : _c.prev();
                }
                break;
              case "ArrowDown":
                e.preventDefault();
                if (props.loading) return;
                if (mergedShowRef.value) {
                  (_d = menuRef.value) === null || _d === void 0 ? void 0 : _d.next();
                } else {
                  openMenu();
                }
                break;
              case "Escape":
                if (mergedShowRef.value) {
                  markEventEffectPerformed(e);
                  closeMenu();
                }
                (_e = triggerRef.value) === null || _e === void 0 ? void 0 : _e.focus();
                break;
            }
          }
          function focusSelection() {
            var _a;
            (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
          }
          function focusSelectionInput() {
            var _a;
            (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
          }
          function handleTriggerOrMenuResize() {
            var _a;
            if (!mergedShowRef.value) return;
            (_a = followerRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
          }
          updateMemorizedOptions();
          vue.watch(vue.toRef(props, "options"), updateMemorizedOptions);
          const exposedMethods = {
            focus: () => {
              var _a;
              (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focus();
            },
            focusInput: () => {
              var _a;
              (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.focusInput();
            },
            blur: () => {
              var _a;
              (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.blur();
            },
            blurInput: () => {
              var _a;
              (_a = triggerRef.value) === null || _a === void 0 ? void 0 : _a.blurInput();
            }
          };
          const cssVarsRef = vue.computed(() => {
            const {
              self: {
                menuBoxShadow
              }
            } = themeRef.value;
            return {
              "--n-menu-box-shadow": menuBoxShadow
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("select", void 0, cssVarsRef, props) : void 0;
          return Object.assign(Object.assign({}, exposedMethods), {
            mergedStatus: mergedStatusRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedBordered: mergedBorderedRef,
            namespace: namespaceRef,
            treeMate: treeMateRef,
            isMounted: isMounted(),
            triggerRef,
            menuRef,
            pattern: patternRef,
            uncontrolledShow: uncontrolledShowRef,
            mergedShow: mergedShowRef,
            adjustedTo: useAdjustedTo(props),
            uncontrolledValue: uncontrolledValueRef,
            mergedValue: mergedValueRef,
            followerRef,
            localizedPlaceholder: localizedPlaceholderRef,
            selectedOption: selectedOptionRef,
            selectedOptions: selectedOptionsRef,
            mergedSize: mergedSizeRef,
            mergedDisabled: mergedDisabledRef,
            focused: focusedRef,
            activeWithoutMenuOpen: activeWithoutMenuOpenRef,
            inlineThemeDisabled,
            onTriggerInputFocus,
            onTriggerInputBlur,
            handleTriggerOrMenuResize,
            handleMenuFocus,
            handleMenuBlur,
            handleMenuTabOut,
            handleTriggerClick,
            handleToggle: handleToggleByTmNode,
            handleDeleteOption: handleToggleByOption,
            handlePatternInput,
            handleClear,
            handleTriggerBlur,
            handleTriggerFocus,
            handleKeydown,
            handleMenuAfterLeave,
            handleMenuClickOutside,
            handleMenuScroll,
            handleMenuKeydown: handleKeydown,
            handleMenuMousedown,
            mergedTheme: themeRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          return vue.h("div", {
            class: `${this.mergedClsPrefix}-select`
          }, vue.h(Binder, null, {
            default: () => [vue.h(VTarget, null, {
              default: () => vue.h(NInternalSelection, {
                ref: "triggerRef",
                inlineThemeDisabled: this.inlineThemeDisabled,
                status: this.mergedStatus,
                inputProps: this.inputProps,
                clsPrefix: this.mergedClsPrefix,
                showArrow: this.showArrow,
                maxTagCount: this.maxTagCount,
                ellipsisTagPopoverProps: this.ellipsisTagPopoverProps,
                bordered: this.mergedBordered,
                active: this.activeWithoutMenuOpen || this.mergedShow,
                pattern: this.pattern,
                placeholder: this.localizedPlaceholder,
                selectedOption: this.selectedOption,
                selectedOptions: this.selectedOptions,
                multiple: this.multiple,
                renderTag: this.renderTag,
                renderLabel: this.renderLabel,
                filterable: this.filterable,
                clearable: this.clearable,
                disabled: this.mergedDisabled,
                size: this.mergedSize,
                theme: this.mergedTheme.peers.InternalSelection,
                labelField: this.labelField,
                valueField: this.valueField,
                themeOverrides: this.mergedTheme.peerOverrides.InternalSelection,
                loading: this.loading,
                focused: this.focused,
                onClick: this.handleTriggerClick,
                onDeleteOption: this.handleDeleteOption,
                onPatternInput: this.handlePatternInput,
                onClear: this.handleClear,
                onBlur: this.handleTriggerBlur,
                onFocus: this.handleTriggerFocus,
                onKeydown: this.handleKeydown,
                onPatternBlur: this.onTriggerInputBlur,
                onPatternFocus: this.onTriggerInputFocus,
                onResize: this.handleTriggerOrMenuResize,
                ignoreComposition: this.ignoreComposition
              }, {
                arrow: () => {
                  var _a, _b;
                  return [(_b = (_a = this.$slots).arrow) === null || _b === void 0 ? void 0 : _b.call(_a)];
                }
              })
            }), vue.h(VFollower, {
              ref: "followerRef",
              show: this.mergedShow,
              to: this.adjustedTo,
              teleportDisabled: this.adjustedTo === useAdjustedTo.tdkey,
              containerClass: this.namespace,
              width: this.consistentMenuWidth ? "target" : void 0,
              minWidth: "target",
              placement: this.placement
            }, {
              default: () => vue.h(vue.Transition, {
                name: "fade-in-scale-up-transition",
                appear: this.isMounted,
                onAfterLeave: this.handleMenuAfterLeave
              }, {
                default: () => {
                  var _a, _b, _c;
                  if (!(this.mergedShow || this.displayDirective === "show")) {
                    return null;
                  }
                  (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
                  return vue.withDirectives(vue.h(NInternalSelectMenu, Object.assign({}, this.menuProps, {
                    ref: "menuRef",
                    onResize: this.handleTriggerOrMenuResize,
                    inlineThemeDisabled: this.inlineThemeDisabled,
                    virtualScroll: this.consistentMenuWidth && this.virtualScroll,
                    class: [`${this.mergedClsPrefix}-select-menu`, this.themeClass, (_b = this.menuProps) === null || _b === void 0 ? void 0 : _b.class],
                    clsPrefix: this.mergedClsPrefix,
                    focusable: true,
                    labelField: this.labelField,
                    valueField: this.valueField,
                    autoPending: true,
                    nodeProps: this.nodeProps,
                    theme: this.mergedTheme.peers.InternalSelectMenu,
                    themeOverrides: this.mergedTheme.peerOverrides.InternalSelectMenu,
                    treeMate: this.treeMate,
                    multiple: this.multiple,
                    size: this.menuSize,
                    renderOption: this.renderOption,
                    renderLabel: this.renderLabel,
                    value: this.mergedValue,
                    style: [(_c = this.menuProps) === null || _c === void 0 ? void 0 : _c.style, this.cssVars],
                    onToggle: this.handleToggle,
                    onScroll: this.handleMenuScroll,
                    onFocus: this.handleMenuFocus,
                    onBlur: this.handleMenuBlur,
                    onKeydown: this.handleMenuKeydown,
                    onTabOut: this.handleMenuTabOut,
                    onMousedown: this.handleMenuMousedown,
                    show: this.mergedShow,
                    showCheckmark: this.showCheckmark,
                    resetMenuOnOptionsChange: this.resetMenuOnOptionsChange
                  }), {
                    empty: () => {
                      var _a2, _b2;
                      return [(_b2 = (_a2 = this.$slots).empty) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                    },
                    header: () => {
                      var _a2, _b2;
                      return [(_b2 = (_a2 = this.$slots).header) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                    },
                    action: () => {
                      var _a2, _b2;
                      return [(_b2 = (_a2 = this.$slots).action) === null || _b2 === void 0 ? void 0 : _b2.call(_a2)];
                    }
                  }), this.displayDirective === "show" ? [[vue.vShow, this.mergedShow], [clickoutside, this.handleMenuClickOutside, void 0, {
                    capture: true
                  }]] : [[clickoutside, this.handleMenuClickOutside, void 0, {
                    capture: true
                  }]]);
                }
              })
            })]
          }));
        }
      });
      const commonVariables$5 = {
        itemPaddingSmall: "0 4px",
        itemMarginSmall: "0 0 0 8px",
        itemMarginSmallRtl: "0 8px 0 0",
        itemPaddingMedium: "0 4px",
        itemMarginMedium: "0 0 0 8px",
        itemMarginMediumRtl: "0 8px 0 0",
        itemPaddingLarge: "0 4px",
        itemMarginLarge: "0 0 0 8px",
        itemMarginLargeRtl: "0 8px 0 0",
        buttonIconSizeSmall: "14px",
        buttonIconSizeMedium: "16px",
        buttonIconSizeLarge: "18px",
        inputWidthSmall: "60px",
        selectWidthSmall: "unset",
        inputMarginSmall: "0 0 0 8px",
        inputMarginSmallRtl: "0 8px 0 0",
        selectMarginSmall: "0 0 0 8px",
        prefixMarginSmall: "0 8px 0 0",
        suffixMarginSmall: "0 0 0 8px",
        inputWidthMedium: "60px",
        selectWidthMedium: "unset",
        inputMarginMedium: "0 0 0 8px",
        inputMarginMediumRtl: "0 8px 0 0",
        selectMarginMedium: "0 0 0 8px",
        prefixMarginMedium: "0 8px 0 0",
        suffixMarginMedium: "0 0 0 8px",
        inputWidthLarge: "60px",
        selectWidthLarge: "unset",
        inputMarginLarge: "0 0 0 8px",
        inputMarginLargeRtl: "0 8px 0 0",
        selectMarginLarge: "0 0 0 8px",
        prefixMarginLarge: "0 8px 0 0",
        suffixMarginLarge: "0 0 0 8px"
      };
      function self$h(vars) {
        const {
          textColor2,
          primaryColor,
          primaryColorHover,
          primaryColorPressed,
          inputColorDisabled,
          textColorDisabled,
          borderColor,
          borderRadius,
fontSizeTiny,
          fontSizeSmall,
          fontSizeMedium,
heightTiny,
          heightSmall,
          heightMedium
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$5), {
          buttonColor: "#0000",
          buttonColorHover: "#0000",
          buttonColorPressed: "#0000",
          buttonBorder: `1px solid ${borderColor}`,
          buttonBorderHover: `1px solid ${borderColor}`,
          buttonBorderPressed: `1px solid ${borderColor}`,
          buttonIconColor: textColor2,
          buttonIconColorHover: textColor2,
          buttonIconColorPressed: textColor2,
          itemTextColor: textColor2,
          itemTextColorHover: primaryColorHover,
          itemTextColorPressed: primaryColorPressed,
          itemTextColorActive: primaryColor,
          itemTextColorDisabled: textColorDisabled,
          itemColor: "#0000",
          itemColorHover: "#0000",
          itemColorPressed: "#0000",
          itemColorActive: "#0000",
          itemColorActiveHover: "#0000",
          itemColorDisabled: inputColorDisabled,
          itemBorder: "1px solid #0000",
          itemBorderHover: "1px solid #0000",
          itemBorderPressed: "1px solid #0000",
          itemBorderActive: `1px solid ${primaryColor}`,
          itemBorderDisabled: `1px solid ${borderColor}`,
          itemBorderRadius: borderRadius,
          itemSizeSmall: heightTiny,
          itemSizeMedium: heightSmall,
          itemSizeLarge: heightMedium,
          itemFontSizeSmall: fontSizeTiny,
          itemFontSizeMedium: fontSizeSmall,
          itemFontSizeLarge: fontSizeMedium,
          jumperFontSizeSmall: fontSizeTiny,
          jumperFontSizeMedium: fontSizeSmall,
          jumperFontSizeLarge: fontSizeMedium,
          jumperTextColor: textColor2,
          jumperTextColorDisabled: textColorDisabled
        });
      }
      const paginationLight = createTheme({
        name: "Pagination",
        common: derived,
        peers: {
          Select: selectLight,
          Input: inputLight,
          Popselect: popselectLight
        },
        self: self$h
      });
      const hoverStyleProps = `
 background: var(--n-item-color-hover);
 color: var(--n-item-text-color-hover);
 border: var(--n-item-border-hover);
`;
      const hoverStyleChildren = [cM("button", `
 background: var(--n-button-color-hover);
 border: var(--n-button-border-hover);
 color: var(--n-button-icon-color-hover);
 `)];
      const style$g = cB("pagination", `
 display: flex;
 vertical-align: middle;
 font-size: var(--n-item-font-size);
 flex-wrap: nowrap;
`, [cB("pagination-prefix", `
 display: flex;
 align-items: center;
 margin: var(--n-prefix-margin);
 `), cB("pagination-suffix", `
 display: flex;
 align-items: center;
 margin: var(--n-suffix-margin);
 `), c$1("> *:not(:first-child)", `
 margin: var(--n-item-margin);
 `), cB("select", `
 width: var(--n-select-width);
 `), c$1("&.transition-disabled", [cB("pagination-item", "transition: none!important;")]), cB("pagination-quick-jumper", `
 white-space: nowrap;
 display: flex;
 color: var(--n-jumper-text-color);
 transition: color .3s var(--n-bezier);
 align-items: center;
 font-size: var(--n-jumper-font-size);
 `, [cB("input", `
 margin: var(--n-input-margin);
 width: var(--n-input-width);
 `)]), cB("pagination-item", `
 position: relative;
 cursor: pointer;
 user-select: none;
 -webkit-user-select: none;
 display: flex;
 align-items: center;
 justify-content: center;
 box-sizing: border-box;
 min-width: var(--n-item-size);
 height: var(--n-item-size);
 padding: var(--n-item-padding);
 background-color: var(--n-item-color);
 color: var(--n-item-text-color);
 border-radius: var(--n-item-border-radius);
 border: var(--n-item-border);
 fill: var(--n-button-icon-color);
 transition:
 color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 fill .3s var(--n-bezier);
 `, [cM("button", `
 background: var(--n-button-color);
 color: var(--n-button-icon-color);
 border: var(--n-button-border);
 padding: 0;
 `, [cB("base-icon", `
 font-size: var(--n-button-icon-size);
 `)]), cNotM("disabled", [cM("hover", hoverStyleProps, hoverStyleChildren), c$1("&:hover", hoverStyleProps, hoverStyleChildren), c$1("&:active", `
 background: var(--n-item-color-pressed);
 color: var(--n-item-text-color-pressed);
 border: var(--n-item-border-pressed);
 `, [cM("button", `
 background: var(--n-button-color-pressed);
 border: var(--n-button-border-pressed);
 color: var(--n-button-icon-color-pressed);
 `)]), cM("active", `
 background: var(--n-item-color-active);
 color: var(--n-item-text-color-active);
 border: var(--n-item-border-active);
 `, [c$1("&:hover", `
 background: var(--n-item-color-active-hover);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 color: var(--n-item-text-color-disabled);
 `, [cM("active, button", `
 background-color: var(--n-item-color-disabled);
 border: var(--n-item-border-disabled);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 `, [cB("pagination-quick-jumper", `
 color: var(--n-jumper-text-color-disabled);
 `)]), cM("simple", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 `, [cB("pagination-quick-jumper", [cB("input", `
 margin: 0;
 `)])])]);
      function getDefaultPageSize(paginationProps2) {
        var _a;
        if (!paginationProps2) return 10;
        const {
          defaultPageSize
        } = paginationProps2;
        if (defaultPageSize !== void 0) return defaultPageSize;
        const pageSizeOption = (_a = paginationProps2.pageSizes) === null || _a === void 0 ? void 0 : _a[0];
        if (typeof pageSizeOption === "number") return pageSizeOption;
        return (pageSizeOption === null || pageSizeOption === void 0 ? void 0 : pageSizeOption.value) || 10;
      }
      function createPageItemsInfo(currentPage, pageCount, pageSlot, showQuickJumpDropdown) {
        let hasFastBackward = false;
        let hasFastForward = false;
        let fastBackwardTo = 1;
        let fastForwardTo = pageCount;
        if (pageCount === 1) {
          return {
            hasFastBackward: false,
            hasFastForward: false,
            fastForwardTo,
            fastBackwardTo,
            items: [{
              type: "page",
              label: 1,
              active: currentPage === 1,
              mayBeFastBackward: false,
              mayBeFastForward: false
            }]
          };
        }
        if (pageCount === 2) {
          return {
            hasFastBackward: false,
            hasFastForward: false,
            fastForwardTo,
            fastBackwardTo,
            items: [{
              type: "page",
              label: 1,
              active: currentPage === 1,
              mayBeFastBackward: false,
              mayBeFastForward: false
            }, {
              type: "page",
              label: 2,
              active: currentPage === 2,
              mayBeFastBackward: true,
              mayBeFastForward: false
            }]
          };
        }
        const firstPage = 1;
        const lastPage = pageCount;
        let middleStart = currentPage;
        let middleEnd = currentPage;
        const middleDelta = (pageSlot - 5) / 2;
        middleEnd += Math.ceil(middleDelta);
        middleEnd = Math.min(Math.max(middleEnd, firstPage + pageSlot - 3), lastPage - 2);
        middleStart -= Math.floor(middleDelta);
        middleStart = Math.max(Math.min(middleStart, lastPage - pageSlot + 3), firstPage + 2);
        let leftSplit = false;
        let rightSplit = false;
        if (middleStart > firstPage + 2) leftSplit = true;
        if (middleEnd < lastPage - 2) rightSplit = true;
        const items = [];
        items.push({
          type: "page",
          label: 1,
          active: currentPage === 1,
          mayBeFastBackward: false,
          mayBeFastForward: false
        });
        if (leftSplit) {
          hasFastBackward = true;
          fastBackwardTo = middleStart - 1;
          items.push({
            type: "fast-backward",
            active: false,
            label: void 0,
            options: showQuickJumpDropdown ? createRange(firstPage + 1, middleStart - 1) : null
          });
        } else if (lastPage >= firstPage + 1) {
          items.push({
            type: "page",
            label: firstPage + 1,
            mayBeFastBackward: true,
            mayBeFastForward: false,
            active: currentPage === firstPage + 1
          });
        }
        for (let i = middleStart; i <= middleEnd; ++i) {
          items.push({
            type: "page",
            label: i,
            mayBeFastBackward: false,
            mayBeFastForward: false,
            active: currentPage === i
          });
        }
        if (rightSplit) {
          hasFastForward = true;
          fastForwardTo = middleEnd + 1;
          items.push({
            type: "fast-forward",
            active: false,
            label: void 0,
            options: showQuickJumpDropdown ? createRange(middleEnd + 1, lastPage - 1) : null
          });
        } else if (middleEnd === lastPage - 2 && items[items.length - 1].label !== lastPage - 1) {
          items.push({
            type: "page",
            mayBeFastForward: true,
            mayBeFastBackward: false,
            label: lastPage - 1,
            active: currentPage === lastPage - 1
          });
        }
        if (items[items.length - 1].label !== lastPage) {
          items.push({
            type: "page",
            mayBeFastForward: false,
            mayBeFastBackward: false,
            label: lastPage,
            active: currentPage === lastPage
          });
        }
        return {
          hasFastBackward,
          hasFastForward,
          fastBackwardTo,
          fastForwardTo,
          items
        };
      }
      function createRange(from, to) {
        const range2 = [];
        for (let i = from; i <= to; ++i) {
          range2.push({
            label: `${i}`,
            value: i
          });
        }
        return range2;
      }
      const paginationProps = Object.assign(Object.assign({}, useTheme.props), {
        simple: Boolean,
        page: Number,
        defaultPage: {
          type: Number,
          default: 1
        },
        itemCount: Number,
        pageCount: Number,
        defaultPageCount: {
          type: Number,
          default: 1
        },
        showSizePicker: Boolean,
        pageSize: Number,
        defaultPageSize: Number,
        pageSizes: {
          type: Array,
          default() {
            return [10];
          }
        },
        showQuickJumper: Boolean,
        size: {
          type: String,
          default: "medium"
        },
        disabled: Boolean,
        pageSlot: {
          type: Number,
          default: 9
        },
        selectProps: Object,
        prev: Function,
        next: Function,
        goto: Function,
        prefix: Function,
        suffix: Function,
        label: Function,
        displayOrder: {
          type: Array,
          default: ["pages", "size-picker", "quick-jumper"]
        },
        to: useAdjustedTo.propTo,
        showQuickJumpDropdown: {
          type: Boolean,
          default: true
        },
        "onUpdate:page": [Function, Array],
        onUpdatePage: [Function, Array],
        "onUpdate:pageSize": [Function, Array],
        onUpdatePageSize: [Function, Array],
onPageSizeChange: [Function, Array],
onChange: [Function, Array]
      });
      const NPagination = vue.defineComponent({
        name: "Pagination",
        props: paginationProps,
        slots: Object,
        setup(props) {
          const {
            mergedComponentPropsRef,
            mergedClsPrefixRef,
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const themeRef = useTheme("Pagination", "-pagination", style$g, paginationLight, props, mergedClsPrefixRef);
          const {
            localeRef
          } = useLocale("Pagination");
          const selfRef = vue.ref(null);
          const uncontrolledPageRef = vue.ref(props.defaultPage);
          const uncontrolledPageSizeRef = vue.ref(getDefaultPageSize(props));
          const mergedPageRef = useMergedState(vue.toRef(props, "page"), uncontrolledPageRef);
          const mergedPageSizeRef = useMergedState(vue.toRef(props, "pageSize"), uncontrolledPageSizeRef);
          const mergedPageCountRef = vue.computed(() => {
            const {
              itemCount
            } = props;
            if (itemCount !== void 0) {
              return Math.max(1, Math.ceil(itemCount / mergedPageSizeRef.value));
            }
            const {
              pageCount
            } = props;
            if (pageCount !== void 0) return Math.max(pageCount, 1);
            return 1;
          });
          const jumperValueRef = vue.ref("");
          vue.watchEffect(() => {
            void props.simple;
            jumperValueRef.value = String(mergedPageRef.value);
          });
          const fastForwardActiveRef = vue.ref(false);
          const fastBackwardActiveRef = vue.ref(false);
          const showFastForwardMenuRef = vue.ref(false);
          const showFastBackwardMenuRef = vue.ref(false);
          const handleFastForwardMouseenter = () => {
            if (props.disabled) return;
            fastForwardActiveRef.value = true;
            disableTransitionOneTick();
          };
          const handleFastForwardMouseleave = () => {
            if (props.disabled) return;
            fastForwardActiveRef.value = false;
            disableTransitionOneTick();
          };
          const handleFastBackwardMouseenter = () => {
            fastBackwardActiveRef.value = true;
            disableTransitionOneTick();
          };
          const handleFastBackwardMouseleave = () => {
            fastBackwardActiveRef.value = false;
            disableTransitionOneTick();
          };
          const handleMenuSelect = (value) => {
            doUpdatePage(value);
          };
          const pageItemsInfo = vue.computed(() => createPageItemsInfo(mergedPageRef.value, mergedPageCountRef.value, props.pageSlot, props.showQuickJumpDropdown));
          vue.watchEffect(() => {
            if (!pageItemsInfo.value.hasFastBackward) {
              fastBackwardActiveRef.value = false;
              showFastBackwardMenuRef.value = false;
            } else if (!pageItemsInfo.value.hasFastForward) {
              fastForwardActiveRef.value = false;
              showFastForwardMenuRef.value = false;
            }
          });
          const pageSizeOptionsRef = vue.computed(() => {
            const suffix2 = localeRef.value.selectionSuffix;
            return props.pageSizes.map((size2) => {
              if (typeof size2 === "number") {
                return {
                  label: `${size2} / ${suffix2}`,
                  value: size2
                };
              } else {
                return size2;
              }
            });
          });
          const inputSizeRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.inputSize) || smallerSize(props.size);
          });
          const selectSizeRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Pagination) === null || _b === void 0 ? void 0 : _b.selectSize) || smallerSize(props.size);
          });
          const startIndexRef = vue.computed(() => {
            return (mergedPageRef.value - 1) * mergedPageSizeRef.value;
          });
          const endIndexRef = vue.computed(() => {
            const endIndex = mergedPageRef.value * mergedPageSizeRef.value - 1;
            const {
              itemCount
            } = props;
            if (itemCount !== void 0) {
              return endIndex > itemCount - 1 ? itemCount - 1 : endIndex;
            }
            return endIndex;
          });
          const mergedItemCountRef = vue.computed(() => {
            const {
              itemCount
            } = props;
            if (itemCount !== void 0) return itemCount;
            return (props.pageCount || 1) * mergedPageSizeRef.value;
          });
          const rtlEnabledRef = useRtl("Pagination", mergedRtlRef, mergedClsPrefixRef);
          function disableTransitionOneTick() {
            void vue.nextTick(() => {
              var _a;
              const {
                value: selfEl
              } = selfRef;
              if (!selfEl) return;
              selfEl.classList.add("transition-disabled");
              void ((_a = selfRef.value) === null || _a === void 0 ? void 0 : _a.offsetWidth);
              selfEl.classList.remove("transition-disabled");
            });
          }
          function doUpdatePage(page) {
            if (page === mergedPageRef.value) return;
            const {
              "onUpdate:page": _onUpdatePage,
              onUpdatePage,
              onChange,
              simple
            } = props;
            if (_onUpdatePage) call(_onUpdatePage, page);
            if (onUpdatePage) call(onUpdatePage, page);
            if (onChange) call(onChange, page);
            uncontrolledPageRef.value = page;
            if (simple) {
              jumperValueRef.value = String(page);
            }
          }
          function doUpdatePageSize(pageSize) {
            if (pageSize === mergedPageSizeRef.value) return;
            const {
              "onUpdate:pageSize": _onUpdatePageSize,
              onUpdatePageSize,
              onPageSizeChange
            } = props;
            if (_onUpdatePageSize) call(_onUpdatePageSize, pageSize);
            if (onUpdatePageSize) call(onUpdatePageSize, pageSize);
            if (onPageSizeChange) call(onPageSizeChange, pageSize);
            uncontrolledPageSizeRef.value = pageSize;
            if (mergedPageCountRef.value < mergedPageRef.value) {
              doUpdatePage(mergedPageCountRef.value);
            }
          }
          function forward() {
            if (props.disabled) return;
            const page = Math.min(mergedPageRef.value + 1, mergedPageCountRef.value);
            doUpdatePage(page);
          }
          function backward() {
            if (props.disabled) return;
            const page = Math.max(mergedPageRef.value - 1, 1);
            doUpdatePage(page);
          }
          function fastForward() {
            if (props.disabled) return;
            const page = Math.min(pageItemsInfo.value.fastForwardTo, mergedPageCountRef.value);
            doUpdatePage(page);
          }
          function fastBackward() {
            if (props.disabled) return;
            const page = Math.max(pageItemsInfo.value.fastBackwardTo, 1);
            doUpdatePage(page);
          }
          function handleSizePickerChange(value) {
            doUpdatePageSize(value);
          }
          function doQuickJump() {
            const page = Number.parseInt(jumperValueRef.value);
            if (Number.isNaN(page)) return;
            doUpdatePage(Math.max(1, Math.min(page, mergedPageCountRef.value)));
            if (!props.simple) {
              jumperValueRef.value = "";
            }
          }
          function handleQuickJumperChange() {
            doQuickJump();
          }
          function handlePageItemClick(pageItem) {
            if (props.disabled) return;
            switch (pageItem.type) {
              case "page":
                doUpdatePage(pageItem.label);
                break;
              case "fast-backward":
                fastBackward();
                break;
              case "fast-forward":
                fastForward();
                break;
            }
          }
          function handleJumperInput(value) {
            jumperValueRef.value = value.replace(/\D+/g, "");
          }
          vue.watchEffect(() => {
            void mergedPageRef.value;
            void mergedPageSizeRef.value;
            disableTransitionOneTick();
          });
          const cssVarsRef = vue.computed(() => {
            const {
              size: size2
            } = props;
            const {
              self: {
                buttonBorder,
                buttonBorderHover,
                buttonBorderPressed,
                buttonIconColor,
                buttonIconColorHover,
                buttonIconColorPressed,
                itemTextColor,
                itemTextColorHover,
                itemTextColorPressed,
                itemTextColorActive,
                itemTextColorDisabled,
                itemColor,
                itemColorHover,
                itemColorPressed,
                itemColorActive,
                itemColorActiveHover,
                itemColorDisabled,
                itemBorder,
                itemBorderHover,
                itemBorderPressed,
                itemBorderActive,
                itemBorderDisabled,
                itemBorderRadius,
                jumperTextColor,
                jumperTextColorDisabled,
                buttonColor,
                buttonColorHover,
                buttonColorPressed,
                [createKey("itemPadding", size2)]: itemPadding,
                [createKey("itemMargin", size2)]: itemMargin,
                [createKey("inputWidth", size2)]: inputWidth,
                [createKey("selectWidth", size2)]: selectWidth,
                [createKey("inputMargin", size2)]: inputMargin,
                [createKey("selectMargin", size2)]: selectMargin,
                [createKey("jumperFontSize", size2)]: jumperFontSize,
                [createKey("prefixMargin", size2)]: prefixMargin,
                [createKey("suffixMargin", size2)]: suffixMargin,
                [createKey("itemSize", size2)]: itemSize,
                [createKey("buttonIconSize", size2)]: buttonIconSize,
                [createKey("itemFontSize", size2)]: itemFontSize,
                [`${createKey("itemMargin", size2)}Rtl`]: itemMarginRtl,
                [`${createKey("inputMargin", size2)}Rtl`]: inputMarginRtl
              },
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              }
            } = themeRef.value;
            return {
              "--n-prefix-margin": prefixMargin,
              "--n-suffix-margin": suffixMargin,
              "--n-item-font-size": itemFontSize,
              "--n-select-width": selectWidth,
              "--n-select-margin": selectMargin,
              "--n-input-width": inputWidth,
              "--n-input-margin": inputMargin,
              "--n-input-margin-rtl": inputMarginRtl,
              "--n-item-size": itemSize,
              "--n-item-text-color": itemTextColor,
              "--n-item-text-color-disabled": itemTextColorDisabled,
              "--n-item-text-color-hover": itemTextColorHover,
              "--n-item-text-color-active": itemTextColorActive,
              "--n-item-text-color-pressed": itemTextColorPressed,
              "--n-item-color": itemColor,
              "--n-item-color-hover": itemColorHover,
              "--n-item-color-disabled": itemColorDisabled,
              "--n-item-color-active": itemColorActive,
              "--n-item-color-active-hover": itemColorActiveHover,
              "--n-item-color-pressed": itemColorPressed,
              "--n-item-border": itemBorder,
              "--n-item-border-hover": itemBorderHover,
              "--n-item-border-disabled": itemBorderDisabled,
              "--n-item-border-active": itemBorderActive,
              "--n-item-border-pressed": itemBorderPressed,
              "--n-item-padding": itemPadding,
              "--n-item-border-radius": itemBorderRadius,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-jumper-font-size": jumperFontSize,
              "--n-jumper-text-color": jumperTextColor,
              "--n-jumper-text-color-disabled": jumperTextColorDisabled,
              "--n-item-margin": itemMargin,
              "--n-item-margin-rtl": itemMarginRtl,
              "--n-button-icon-size": buttonIconSize,
              "--n-button-icon-color": buttonIconColor,
              "--n-button-icon-color-hover": buttonIconColorHover,
              "--n-button-icon-color-pressed": buttonIconColorPressed,
              "--n-button-color-hover": buttonColorHover,
              "--n-button-color": buttonColor,
              "--n-button-color-pressed": buttonColorPressed,
              "--n-button-border": buttonBorder,
              "--n-button-border-hover": buttonBorderHover,
              "--n-button-border-pressed": buttonBorderPressed
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("pagination", vue.computed(() => {
            let hash = "";
            const {
              size: size2
            } = props;
            hash += size2[0];
            return hash;
          }), cssVarsRef, props) : void 0;
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            locale: localeRef,
            selfRef,
            mergedPage: mergedPageRef,
            pageItems: vue.computed(() => {
              return pageItemsInfo.value.items;
            }),
            mergedItemCount: mergedItemCountRef,
            jumperValue: jumperValueRef,
            pageSizeOptions: pageSizeOptionsRef,
            mergedPageSize: mergedPageSizeRef,
            inputSize: inputSizeRef,
            selectSize: selectSizeRef,
            mergedTheme: themeRef,
            mergedPageCount: mergedPageCountRef,
            startIndex: startIndexRef,
            endIndex: endIndexRef,
            showFastForwardMenu: showFastForwardMenuRef,
            showFastBackwardMenu: showFastBackwardMenuRef,
            fastForwardActive: fastForwardActiveRef,
            fastBackwardActive: fastBackwardActiveRef,
            handleMenuSelect,
            handleFastForwardMouseenter,
            handleFastForwardMouseleave,
            handleFastBackwardMouseenter,
            handleFastBackwardMouseleave,
            handleJumperInput,
            handleBackwardClick: backward,
            handleForwardClick: forward,
            handlePageItemClick,
            handleSizePickerChange,
            handleQuickJumperChange,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const {
            $slots,
            mergedClsPrefix,
            disabled,
            cssVars,
            mergedPage,
            mergedPageCount,
            pageItems,
            showSizePicker,
            showQuickJumper,
            mergedTheme,
            locale,
            inputSize,
            selectSize,
            mergedPageSize,
            pageSizeOptions,
            jumperValue,
            simple,
            prev,
            next,
            prefix: prefix2,
            suffix: suffix2,
            label,
            goto,
            handleJumperInput,
            handleSizePickerChange,
            handleBackwardClick,
            handlePageItemClick,
            handleForwardClick,
            handleQuickJumperChange,
            onRender
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const renderPrefix = prefix2 || $slots.prefix;
          const renderSuffix = suffix2 || $slots.suffix;
          const renderPrev = prev || $slots.prev;
          const renderNext = next || $slots.next;
          const renderLabel = label || $slots.label;
          return vue.h("div", {
            ref: "selfRef",
            class: [`${mergedClsPrefix}-pagination`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-pagination--rtl`, disabled && `${mergedClsPrefix}-pagination--disabled`, simple && `${mergedClsPrefix}-pagination--simple`],
            style: cssVars
          }, renderPrefix ? vue.h("div", {
            class: `${mergedClsPrefix}-pagination-prefix`
          }, renderPrefix({
            page: mergedPage,
            pageSize: mergedPageSize,
            pageCount: mergedPageCount,
            startIndex: this.startIndex,
            endIndex: this.endIndex,
            itemCount: this.mergedItemCount
          })) : null, this.displayOrder.map((part) => {
            switch (part) {
              case "pages":
                return vue.h(vue.Fragment, null, vue.h("div", {
                  class: [`${mergedClsPrefix}-pagination-item`, !renderPrev && `${mergedClsPrefix}-pagination-item--button`, (mergedPage <= 1 || mergedPage > mergedPageCount || disabled) && `${mergedClsPrefix}-pagination-item--disabled`],
                  onClick: handleBackwardClick
                }, renderPrev ? renderPrev({
                  page: mergedPage,
                  pageSize: mergedPageSize,
                  pageCount: mergedPageCount,
                  startIndex: this.startIndex,
                  endIndex: this.endIndex,
                  itemCount: this.mergedItemCount
                }) : vue.h(NBaseIcon, {
                  clsPrefix: mergedClsPrefix
                }, {
                  default: () => this.rtlEnabled ? vue.h(ForwardIcon, null) : vue.h(BackwardIcon, null)
                })), simple ? vue.h(vue.Fragment, null, vue.h("div", {
                  class: `${mergedClsPrefix}-pagination-quick-jumper`
                }, vue.h(NInput, {
                  value: jumperValue,
                  onUpdateValue: handleJumperInput,
                  size: inputSize,
                  placeholder: "",
                  disabled,
                  theme: mergedTheme.peers.Input,
                  themeOverrides: mergedTheme.peerOverrides.Input,
                  onChange: handleQuickJumperChange
                })), " /", " ", mergedPageCount) : pageItems.map((pageItem, index) => {
                  let contentNode;
                  let onMouseenter;
                  let onMouseleave;
                  const {
                    type
                  } = pageItem;
                  switch (type) {
                    case "page":
                      const pageNode = pageItem.label;
                      if (renderLabel) {
                        contentNode = renderLabel({
                          type: "page",
                          node: pageNode,
                          active: pageItem.active
                        });
                      } else {
                        contentNode = pageNode;
                      }
                      break;
                    case "fast-forward":
                      const fastForwardNode = this.fastForwardActive ? vue.h(NBaseIcon, {
                        clsPrefix: mergedClsPrefix
                      }, {
                        default: () => this.rtlEnabled ? vue.h(FastBackwardIcon, null) : vue.h(FastForwardIcon, null)
                      }) : vue.h(NBaseIcon, {
                        clsPrefix: mergedClsPrefix
                      }, {
                        default: () => vue.h(MoreIcon, null)
                      });
                      if (renderLabel) {
                        contentNode = renderLabel({
                          type: "fast-forward",
                          node: fastForwardNode,
                          active: this.fastForwardActive || this.showFastForwardMenu
                        });
                      } else {
                        contentNode = fastForwardNode;
                      }
                      onMouseenter = this.handleFastForwardMouseenter;
                      onMouseleave = this.handleFastForwardMouseleave;
                      break;
                    case "fast-backward":
                      const fastBackwardNode = this.fastBackwardActive ? vue.h(NBaseIcon, {
                        clsPrefix: mergedClsPrefix
                      }, {
                        default: () => this.rtlEnabled ? vue.h(FastForwardIcon, null) : vue.h(FastBackwardIcon, null)
                      }) : vue.h(NBaseIcon, {
                        clsPrefix: mergedClsPrefix
                      }, {
                        default: () => vue.h(MoreIcon, null)
                      });
                      if (renderLabel) {
                        contentNode = renderLabel({
                          type: "fast-backward",
                          node: fastBackwardNode,
                          active: this.fastBackwardActive || this.showFastBackwardMenu
                        });
                      } else {
                        contentNode = fastBackwardNode;
                      }
                      onMouseenter = this.handleFastBackwardMouseenter;
                      onMouseleave = this.handleFastBackwardMouseleave;
                      break;
                  }
                  const itemNode = vue.h("div", {
                    key: index,
                    class: [`${mergedClsPrefix}-pagination-item`, pageItem.active && `${mergedClsPrefix}-pagination-item--active`, type !== "page" && (type === "fast-backward" && this.showFastBackwardMenu || type === "fast-forward" && this.showFastForwardMenu) && `${mergedClsPrefix}-pagination-item--hover`, disabled && `${mergedClsPrefix}-pagination-item--disabled`, type === "page" && `${mergedClsPrefix}-pagination-item--clickable`],
                    onClick: () => {
                      handlePageItemClick(pageItem);
                    },
                    onMouseenter,
                    onMouseleave
                  }, contentNode);
                  if (type === "page" && !pageItem.mayBeFastBackward && !pageItem.mayBeFastForward) {
                    return itemNode;
                  } else {
                    const key = pageItem.type === "page" ? pageItem.mayBeFastBackward ? "fast-backward" : "fast-forward" : pageItem.type;
                    if (pageItem.type !== "page" && !pageItem.options) {
                      return itemNode;
                    }
                    return vue.h(NPopselect, {
                      to: this.to,
                      key,
                      disabled,
                      trigger: "hover",
                      virtualScroll: true,
                      style: {
                        width: "60px"
                      },
                      theme: mergedTheme.peers.Popselect,
                      themeOverrides: mergedTheme.peerOverrides.Popselect,
                      builtinThemeOverrides: {
                        peers: {
                          InternalSelectMenu: {
                            height: "calc(var(--n-option-height) * 4.6)"
                          }
                        }
                      },
                      nodeProps: () => ({
                        style: {
                          justifyContent: "center"
                        }
                      }),
                      show: type === "page" ? false : type === "fast-backward" ? this.showFastBackwardMenu : this.showFastForwardMenu,
                      onUpdateShow: (value) => {
                        if (type === "page") return;
                        if (value) {
                          if (type === "fast-backward") {
                            this.showFastBackwardMenu = value;
                          } else {
                            this.showFastForwardMenu = value;
                          }
                        } else {
                          this.showFastBackwardMenu = false;
                          this.showFastForwardMenu = false;
                        }
                      },
                      options: pageItem.type !== "page" && pageItem.options ? pageItem.options : [],
                      onUpdateValue: this.handleMenuSelect,
                      scrollable: true,
                      showCheckmark: false
                    }, {
                      default: () => itemNode
                    });
                  }
                }), vue.h("div", {
                  class: [`${mergedClsPrefix}-pagination-item`, !renderNext && `${mergedClsPrefix}-pagination-item--button`, {
                    [`${mergedClsPrefix}-pagination-item--disabled`]: mergedPage < 1 || mergedPage >= mergedPageCount || disabled
                  }],
                  onClick: handleForwardClick
                }, renderNext ? renderNext({
                  page: mergedPage,
                  pageSize: mergedPageSize,
                  pageCount: mergedPageCount,
                  itemCount: this.mergedItemCount,
                  startIndex: this.startIndex,
                  endIndex: this.endIndex
                }) : vue.h(NBaseIcon, {
                  clsPrefix: mergedClsPrefix
                }, {
                  default: () => this.rtlEnabled ? vue.h(BackwardIcon, null) : vue.h(ForwardIcon, null)
                })));
              case "size-picker": {
                return !simple && showSizePicker ? vue.h(NSelect, Object.assign({
                  consistentMenuWidth: false,
                  placeholder: "",
                  showCheckmark: false,
                  to: this.to
                }, this.selectProps, {
                  size: selectSize,
                  options: pageSizeOptions,
                  value: mergedPageSize,
                  disabled,
                  theme: mergedTheme.peers.Select,
                  themeOverrides: mergedTheme.peerOverrides.Select,
                  onUpdateValue: handleSizePickerChange
                })) : null;
              }
              case "quick-jumper":
                return !simple && showQuickJumper ? vue.h("div", {
                  class: `${mergedClsPrefix}-pagination-quick-jumper`
                }, goto ? goto() : resolveSlot(this.$slots.goto, () => [locale.goto]), vue.h(NInput, {
                  value: jumperValue,
                  onUpdateValue: handleJumperInput,
                  size: inputSize,
                  placeholder: "",
                  disabled,
                  theme: mergedTheme.peers.Input,
                  themeOverrides: mergedTheme.peerOverrides.Input,
                  onChange: handleQuickJumperChange
                })) : null;
              default:
                return null;
            }
          }), renderSuffix ? vue.h("div", {
            class: `${mergedClsPrefix}-pagination-suffix`
          }, renderSuffix({
            page: mergedPage,
            pageSize: mergedPageSize,
            pageCount: mergedPageCount,
            startIndex: this.startIndex,
            endIndex: this.endIndex,
            itemCount: this.mergedItemCount
          })) : null);
        }
      });
      const commonVariables$4 = {
        padding: "4px 0",
        optionIconSizeSmall: "14px",
        optionIconSizeMedium: "16px",
        optionIconSizeLarge: "16px",
        optionIconSizeHuge: "18px",
        optionSuffixWidthSmall: "14px",
        optionSuffixWidthMedium: "14px",
        optionSuffixWidthLarge: "16px",
        optionSuffixWidthHuge: "16px",
        optionIconSuffixWidthSmall: "32px",
        optionIconSuffixWidthMedium: "32px",
        optionIconSuffixWidthLarge: "36px",
        optionIconSuffixWidthHuge: "36px",
        optionPrefixWidthSmall: "14px",
        optionPrefixWidthMedium: "14px",
        optionPrefixWidthLarge: "16px",
        optionPrefixWidthHuge: "16px",
        optionIconPrefixWidthSmall: "36px",
        optionIconPrefixWidthMedium: "36px",
        optionIconPrefixWidthLarge: "40px",
        optionIconPrefixWidthHuge: "40px"
      };
      function self$g(vars) {
        const {
          primaryColor,
          textColor2,
          dividerColor,
          hoverColor,
          popoverColor,
          invertedColor,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          fontSizeHuge,
          heightSmall,
          heightMedium,
          heightLarge,
          heightHuge,
          textColor3,
          opacityDisabled
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$4), {
          optionHeightSmall: heightSmall,
          optionHeightMedium: heightMedium,
          optionHeightLarge: heightLarge,
          optionHeightHuge: heightHuge,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          fontSizeHuge,
optionTextColor: textColor2,
          optionTextColorHover: textColor2,
          optionTextColorActive: primaryColor,
          optionTextColorChildActive: primaryColor,
          color: popoverColor,
          dividerColor,
          suffixColor: textColor2,
          prefixColor: textColor2,
          optionColorHover: hoverColor,
          optionColorActive: changeColor(primaryColor, {
            alpha: 0.1
          }),
          groupHeaderTextColor: textColor3,
optionTextColorInverted: "#BBB",
          optionTextColorHoverInverted: "#FFF",
          optionTextColorActiveInverted: "#FFF",
          optionTextColorChildActiveInverted: "#FFF",
          colorInverted: invertedColor,
          dividerColorInverted: "#BBB",
          suffixColorInverted: "#BBB",
          prefixColorInverted: "#BBB",
          optionColorHoverInverted: primaryColor,
          optionColorActiveInverted: primaryColor,
          groupHeaderTextColorInverted: "#AAA",
          optionOpacityDisabled: opacityDisabled
        });
      }
      const dropdownLight = createTheme({
        name: "Dropdown",
        common: derived,
        peers: {
          Popover: popoverLight
        },
        self: self$g
      });
      const commonVars$6 = {
        padding: "8px 14px"
      };
      function self$f(vars) {
        const {
          borderRadius,
          boxShadow2,
          baseColor
        } = vars;
        return Object.assign(Object.assign({}, commonVars$6), {
          borderRadius,
          boxShadow: boxShadow2,
          color: composite(baseColor, "rgba(0, 0, 0, .85)"),
          textColor: baseColor
        });
      }
      const tooltipLight = createTheme({
        name: "Tooltip",
        common: derived,
        peers: {
          Popover: popoverLight
        },
        self: self$f
      });
      const ellipsisLight = createTheme({
        name: "Ellipsis",
        common: derived,
        peers: {
          Tooltip: tooltipLight
        }
      });
      const commonVariables$3 = {
        radioSizeSmall: "14px",
        radioSizeMedium: "16px",
        radioSizeLarge: "18px",
        labelPadding: "0 8px",
        labelFontWeight: "400"
      };
      function self$e(vars) {
        const {
          borderColor,
          primaryColor,
          baseColor,
          textColorDisabled,
          inputColorDisabled,
          textColor2,
          opacityDisabled,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          heightSmall,
          heightMedium,
          heightLarge,
          lineHeight: lineHeight2
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$3), {
          labelLineHeight: lineHeight2,
          buttonHeightSmall: heightSmall,
          buttonHeightMedium: heightMedium,
          buttonHeightLarge: heightLarge,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          boxShadow: `inset 0 0 0 1px ${borderColor}`,
          boxShadowActive: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`,
          boxShadowHover: `inset 0 0 0 1px ${primaryColor}`,
          boxShadowDisabled: `inset 0 0 0 1px ${borderColor}`,
          color: baseColor,
          colorDisabled: inputColorDisabled,
          colorActive: "#0000",
          textColor: textColor2,
          textColorDisabled,
          dotColorActive: primaryColor,
          dotColorDisabled: borderColor,
          buttonBorderColor: borderColor,
          buttonBorderColorActive: primaryColor,
          buttonBorderColorHover: borderColor,
          buttonColor: baseColor,
          buttonColorActive: baseColor,
          buttonTextColor: textColor2,
          buttonTextColorActive: primaryColor,
          buttonTextColorHover: primaryColor,
          opacityDisabled,
          buttonBoxShadowFocus: `inset 0 0 0 1px ${primaryColor}, 0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.3
        })}`,
          buttonBoxShadowHover: "inset 0 0 0 1px #0000",
          buttonBoxShadow: "inset 0 0 0 1px #0000",
          buttonBorderRadius: borderRadius
        });
      }
      const radioLight = {
        name: "Radio",
        common: derived,
        self: self$e
      };
      const commonVariables$2 = {
        thPaddingSmall: "8px",
        thPaddingMedium: "12px",
        thPaddingLarge: "12px",
        tdPaddingSmall: "8px",
        tdPaddingMedium: "12px",
        tdPaddingLarge: "12px",
        sorterSize: "15px",
        resizableContainerSize: "8px",
        resizableSize: "2px",
        filterSize: "15px",
        paginationMargin: "12px 0 0 0",
        emptyPadding: "48px 0",
        actionPadding: "8px 12px",
        actionButtonMargin: "0 8px 0 0"
      };
      function self$d(vars) {
        const {
          cardColor,
          modalColor,
          popoverColor,
          textColor2,
          textColor1,
          tableHeaderColor,
          tableColorHover,
          iconColor,
          primaryColor,
          fontWeightStrong,
          borderRadius,
          lineHeight: lineHeight2,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          dividerColor,
          heightSmall,
          opacityDisabled,
          tableColorStriped
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$2), {
          actionDividerColor: dividerColor,
          lineHeight: lineHeight2,
          borderRadius,
          fontSizeSmall,
          fontSizeMedium,
          fontSizeLarge,
          borderColor: composite(cardColor, dividerColor),
          tdColorHover: composite(cardColor, tableColorHover),
          tdColorSorting: composite(cardColor, tableColorHover),
          tdColorStriped: composite(cardColor, tableColorStriped),
          thColor: composite(cardColor, tableHeaderColor),
          thColorHover: composite(composite(cardColor, tableHeaderColor), tableColorHover),
          thColorSorting: composite(composite(cardColor, tableHeaderColor), tableColorHover),
          tdColor: cardColor,
          tdTextColor: textColor2,
          thTextColor: textColor1,
          thFontWeight: fontWeightStrong,
          thButtonColorHover: tableColorHover,
          thIconColor: iconColor,
          thIconColorActive: primaryColor,
borderColorModal: composite(modalColor, dividerColor),
          tdColorHoverModal: composite(modalColor, tableColorHover),
          tdColorSortingModal: composite(modalColor, tableColorHover),
          tdColorStripedModal: composite(modalColor, tableColorStriped),
          thColorModal: composite(modalColor, tableHeaderColor),
          thColorHoverModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
          thColorSortingModal: composite(composite(modalColor, tableHeaderColor), tableColorHover),
          tdColorModal: modalColor,
borderColorPopover: composite(popoverColor, dividerColor),
          tdColorHoverPopover: composite(popoverColor, tableColorHover),
          tdColorSortingPopover: composite(popoverColor, tableColorHover),
          tdColorStripedPopover: composite(popoverColor, tableColorStriped),
          thColorPopover: composite(popoverColor, tableHeaderColor),
          thColorHoverPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
          thColorSortingPopover: composite(composite(popoverColor, tableHeaderColor), tableColorHover),
          tdColorPopover: popoverColor,
          boxShadowBefore: "inset -12px 0 8px -12px rgba(0, 0, 0, .18)",
          boxShadowAfter: "inset 12px 0 8px -12px rgba(0, 0, 0, .18)",
loadingColor: primaryColor,
          loadingSize: heightSmall,
          opacityLoading: opacityDisabled
        });
      }
      const dataTableLight = createTheme({
        name: "DataTable",
        common: derived,
        peers: {
          Button: buttonLight,
          Checkbox: checkboxLight,
          Radio: radioLight,
          Pagination: paginationLight,
          Scrollbar: scrollbarLight,
          Empty: emptyLight,
          Popover: popoverLight,
          Ellipsis: ellipsisLight,
          Dropdown: dropdownLight
        },
        self: self$d
      });
      const dataTableProps = Object.assign(Object.assign({}, useTheme.props), {
        onUnstableColumnResize: Function,
        pagination: {
          type: [Object, Boolean],
          default: false
        },
        paginateSinglePage: {
          type: Boolean,
          default: true
        },
        minHeight: [Number, String],
        maxHeight: [Number, String],
columns: {
          type: Array,
          default: () => []
        },
        rowClassName: [String, Function],
        rowProps: Function,
        rowKey: Function,
        summary: [Function],
        data: {
          type: Array,
          default: () => []
        },
        loading: Boolean,
        bordered: {
          type: Boolean,
          default: void 0
        },
        bottomBordered: {
          type: Boolean,
          default: void 0
        },
        striped: Boolean,
        scrollX: [Number, String],
        defaultCheckedRowKeys: {
          type: Array,
          default: () => []
        },
        checkedRowKeys: Array,
        singleLine: {
          type: Boolean,
          default: true
        },
        singleColumn: Boolean,
        size: {
          type: String,
          default: "medium"
        },
        remote: Boolean,
        defaultExpandedRowKeys: {
          type: Array,
          default: []
        },
        defaultExpandAll: Boolean,
        expandedRowKeys: Array,
        stickyExpandedRows: Boolean,
        virtualScroll: Boolean,
        virtualScrollX: Boolean,
        virtualScrollHeader: Boolean,
        headerHeight: {
          type: Number,
          default: 28
        },
        heightForRow: Function,
        minRowHeight: {
          type: Number,
          default: 28
        },
        tableLayout: {
          type: String,
          default: "auto"
        },
        allowCheckingNotLoaded: Boolean,
        cascade: {
          type: Boolean,
          default: true
        },
        childrenKey: {
          type: String,
          default: "children"
        },
        indent: {
          type: Number,
          default: 16
        },
        flexHeight: Boolean,
        summaryPlacement: {
          type: String,
          default: "bottom"
        },
        paginationBehaviorOnFilter: {
          type: String,
          default: "current"
        },
        filterIconPopoverProps: Object,
        scrollbarProps: Object,
        renderCell: Function,
        renderExpandIcon: Function,
        spinProps: {
          type: Object,
          default: {}
        },
        getCsvCell: Function,
        getCsvHeader: Function,
        onLoad: Function,
        "onUpdate:page": [Function, Array],
        onUpdatePage: [Function, Array],
        "onUpdate:pageSize": [Function, Array],
        onUpdatePageSize: [Function, Array],
        "onUpdate:sorter": [Function, Array],
        onUpdateSorter: [Function, Array],
        "onUpdate:filters": [Function, Array],
        onUpdateFilters: [Function, Array],
        "onUpdate:checkedRowKeys": [Function, Array],
        onUpdateCheckedRowKeys: [Function, Array],
        "onUpdate:expandedRowKeys": [Function, Array],
        onUpdateExpandedRowKeys: [Function, Array],
        onScroll: Function,
onPageChange: [Function, Array],
        onPageSizeChange: [Function, Array],
        onSorterChange: [Function, Array],
        onFiltersChange: [Function, Array],
        onCheckedRowKeysChange: [Function, Array]
      });
      const dataTableInjectionKey = createInjectionKey("n-data-table");
      const SELECTION_COL_WIDTH = 40;
      const EXPAND_COL_WIDTH = 40;
      function getNumberColWidth(col) {
        if (col.type === "selection") {
          return col.width === void 0 ? SELECTION_COL_WIDTH : depx(col.width);
        }
        if (col.type === "expand") {
          return col.width === void 0 ? EXPAND_COL_WIDTH : depx(col.width);
        }
        if ("children" in col) return void 0;
        if (typeof col.width === "string") {
          return depx(col.width);
        }
        return col.width;
      }
      function getStringColWidth(col) {
        var _a, _b;
        if (col.type === "selection") {
          return formatLength((_a = col.width) !== null && _a !== void 0 ? _a : SELECTION_COL_WIDTH);
        }
        if (col.type === "expand") {
          return formatLength((_b = col.width) !== null && _b !== void 0 ? _b : EXPAND_COL_WIDTH);
        }
        if ("children" in col) {
          return void 0;
        }
        return formatLength(col.width);
      }
      function getColKey(col) {
        if (col.type === "selection") return "__n_selection__";
        if (col.type === "expand") return "__n_expand__";
        return col.key;
      }
      function createShallowClonedObject(object) {
        if (!object) return object;
        if (typeof object === "object") {
          return Object.assign({}, object);
        }
        return object;
      }
      function getFlagOfOrder(order) {
        if (order === "ascend") return 1;
        else if (order === "descend") return -1;
        return 0;
      }
      function clampValueFollowCSSRules(value, min, max) {
        if (max !== void 0) {
          value = Math.min(value, typeof max === "number" ? max : Number.parseFloat(max));
        }
        if (min !== void 0) {
          value = Math.max(value, typeof min === "number" ? min : Number.parseFloat(min));
        }
        return value;
      }
      function createCustomWidthStyle(column, resizedWidth) {
        if (resizedWidth !== void 0) {
          return {
            width: resizedWidth,
            minWidth: resizedWidth,
            maxWidth: resizedWidth
          };
        }
        const width = getStringColWidth(column);
        const {
          minWidth,
          maxWidth
        } = column;
        return {
          width,
          minWidth: formatLength(minWidth) || width,
          maxWidth: formatLength(maxWidth)
        };
      }
      function createRowClassName(row, index, rowClassName) {
        if (typeof rowClassName === "function") return rowClassName(row, index);
        return rowClassName || "";
      }
      function shouldUseArrayInSingleMode(column) {
        return column.filterOptionValues !== void 0 || column.filterOptionValue === void 0 && column.defaultFilterOptionValues !== void 0;
      }
      function isColumnSortable(column) {
        if ("children" in column) return false;
        return !!column.sorter;
      }
      function isColumnResizable(column) {
        if ("children" in column && !!column.children.length) return false;
        return !!column.resizable;
      }
      function isColumnFilterable(column) {
        if ("children" in column) return false;
        return !!column.filter && (!!column.filterOptions || !!column.renderFilterMenu);
      }
      function getNextOrderOf(order) {
        if (!order) return "descend";
        else if (order === "descend") return "ascend";
        return false;
      }
      function createNextSorter(column, currentSortState) {
        if (column.sorter === void 0) return null;
        const {
          customNextSortOrder
        } = column;
        if (currentSortState === null || currentSortState.columnKey !== column.key) {
          return {
            columnKey: column.key,
            sorter: column.sorter,
            order: getNextOrderOf(false)
          };
        } else {
          return Object.assign(Object.assign({}, currentSortState), {
            order: (customNextSortOrder || getNextOrderOf)(currentSortState.order)
          });
        }
      }
      function isColumnSorting(column, mergedSortState) {
        return mergedSortState.find((state) => state.columnKey === column.key && state.order) !== void 0;
      }
      function formatCsvCell(value) {
        if (typeof value === "string") {
          return value.replace(/,/g, "\\,");
        } else if (value === null || value === void 0) {
          return "";
        } else {
          return `${value}`.replace(/,/g, "\\,");
        }
      }
      function generateCsv(columns, data, getCsvCell, getCsvHeader) {
        const exportableColumns = columns.filter((column) => column.type !== "expand" && column.type !== "selection" && column.allowExport !== false);
        const header = exportableColumns.map((col) => {
          return getCsvHeader ? getCsvHeader(col) : col.title;
        }).join(",");
        const rows = data.map((row) => {
          return exportableColumns.map((col) => {
            return getCsvCell ? getCsvCell(row[col.key], row, col) : formatCsvCell(row[col.key]);
          }).join(",");
        });
        return [header, ...rows].join("\n");
      }
      const RenderSafeCheckbox = vue.defineComponent({
        name: "DataTableBodyCheckbox",
        props: {
          rowKey: {
            type: [String, Number],
            required: true
          },
          disabled: {
            type: Boolean,
            required: true
          },
          onUpdateChecked: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const {
            mergedCheckedRowKeySetRef,
            mergedInderminateRowKeySetRef
          } = vue.inject(dataTableInjectionKey);
          return () => {
            const {
              rowKey
            } = props;
            return vue.h(NCheckbox, {
              privateInsideTable: true,
              disabled: props.disabled,
              indeterminate: mergedInderminateRowKeySetRef.value.has(rowKey),
              checked: mergedCheckedRowKeySetRef.value.has(rowKey),
              onUpdateChecked: props.onUpdateChecked
            });
          };
        }
      });
      const style$f = cB("radio", `
 line-height: var(--n-label-line-height);
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 align-items: flex-start;
 flex-wrap: nowrap;
 font-size: var(--n-font-size);
 word-break: break-word;
`, [cM("checked", [cE("dot", `
 background-color: var(--n-color-active);
 `)]), cE("dot-wrapper", `
 position: relative;
 flex-shrink: 0;
 flex-grow: 0;
 width: var(--n-radio-size);
 `), cB("radio-input", `
 position: absolute;
 border: 0;
 width: 0;
 height: 0;
 opacity: 0;
 margin: 0;
 `), cE("dot", `
 position: absolute;
 top: 50%;
 left: 0;
 transform: translateY(-50%);
 height: var(--n-radio-size);
 width: var(--n-radio-size);
 background: var(--n-color);
 box-shadow: var(--n-box-shadow);
 border-radius: 50%;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 opacity: 0;
 position: absolute;
 left: 4px;
 top: 4px;
 height: calc(100% - 8px);
 width: calc(100% - 8px);
 border-radius: 50%;
 transform: scale(.8);
 background: var(--n-dot-color-active);
 transition: 
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .3s var(--n-bezier);
 `), cM("checked", {
        boxShadow: "var(--n-box-shadow-active)"
      }, [c$1("&::before", `
 opacity: 1;
 transform: scale(1);
 `)])]), cE("label", `
 color: var(--n-text-color);
 padding: var(--n-label-padding);
 font-weight: var(--n-label-font-weight);
 display: inline-block;
 transition: color .3s var(--n-bezier);
 `), cNotM("disabled", `
 cursor: pointer;
 `, [c$1("&:hover", [cE("dot", {
        boxShadow: "var(--n-box-shadow-hover)"
      })]), cM("focus", [c$1("&:not(:active)", [cE("dot", {
        boxShadow: "var(--n-box-shadow-focus)"
      })])])]), cM("disabled", `
 cursor: not-allowed;
 `, [cE("dot", {
        boxShadow: "var(--n-box-shadow-disabled)",
        backgroundColor: "var(--n-color-disabled)"
      }, [c$1("&::before", {
        backgroundColor: "var(--n-dot-color-disabled)"
      }), cM("checked", `
 opacity: 1;
 `)]), cE("label", {
        color: "var(--n-text-color-disabled)"
      }), cB("radio-input", `
 cursor: not-allowed;
 `)])]);
      const radioBaseProps = {
        name: String,
        value: {
          type: [String, Number, Boolean],
          default: "on"
        },
        checked: {
          type: Boolean,
          default: void 0
        },
        defaultChecked: Boolean,
        disabled: {
          type: Boolean,
          default: void 0
        },
        label: String,
        size: String,
        onUpdateChecked: [Function, Array],
        "onUpdate:checked": [Function, Array],
checkedValue: {
          type: Boolean,
          default: void 0
        }
      };
      const radioGroupInjectionKey = createInjectionKey("n-radio-group");
      function setup(props) {
        const NRadioGroup2 = vue.inject(radioGroupInjectionKey, null);
        const formItem = useFormItem(props, {
          mergedSize(NFormItem2) {
            const {
              size: size2
            } = props;
            if (size2 !== void 0) return size2;
            if (NRadioGroup2) {
              const {
                mergedSizeRef: {
                  value: mergedSize
                }
              } = NRadioGroup2;
              if (mergedSize !== void 0) {
                return mergedSize;
              }
            }
            if (NFormItem2) {
              return NFormItem2.mergedSize.value;
            }
            return "medium";
          },
          mergedDisabled(NFormItem2) {
            if (props.disabled) return true;
            if (NRadioGroup2 === null || NRadioGroup2 === void 0 ? void 0 : NRadioGroup2.disabledRef.value) return true;
            if (NFormItem2 === null || NFormItem2 === void 0 ? void 0 : NFormItem2.disabled.value) return true;
            return false;
          }
        });
        const {
          mergedSizeRef,
          mergedDisabledRef
        } = formItem;
        const inputRef = vue.ref(null);
        const labelRef = vue.ref(null);
        const uncontrolledCheckedRef = vue.ref(props.defaultChecked);
        const controlledCheckedRef = vue.toRef(props, "checked");
        const mergedCheckedRef = useMergedState(controlledCheckedRef, uncontrolledCheckedRef);
        const renderSafeCheckedRef = useMemo(() => {
          if (NRadioGroup2) return NRadioGroup2.valueRef.value === props.value;
          return mergedCheckedRef.value;
        });
        const mergedNameRef = useMemo(() => {
          const {
            name
          } = props;
          if (name !== void 0) return name;
          if (NRadioGroup2) return NRadioGroup2.nameRef.value;
        });
        const focusRef = vue.ref(false);
        function doUpdateChecked() {
          if (NRadioGroup2) {
            const {
              doUpdateValue
            } = NRadioGroup2;
            const {
              value
            } = props;
            call(doUpdateValue, value);
          } else {
            const {
              onUpdateChecked,
              "onUpdate:checked": _onUpdateChecked
            } = props;
            const {
              nTriggerFormInput,
              nTriggerFormChange
            } = formItem;
            if (onUpdateChecked) call(onUpdateChecked, true);
            if (_onUpdateChecked) call(_onUpdateChecked, true);
            nTriggerFormInput();
            nTriggerFormChange();
            uncontrolledCheckedRef.value = true;
          }
        }
        function toggle() {
          if (mergedDisabledRef.value) return;
          if (!renderSafeCheckedRef.value) {
            doUpdateChecked();
          }
        }
        function handleRadioInputChange() {
          toggle();
          if (inputRef.value) {
            inputRef.value.checked = renderSafeCheckedRef.value;
          }
        }
        function handleRadioInputBlur() {
          focusRef.value = false;
        }
        function handleRadioInputFocus() {
          focusRef.value = true;
        }
        return {
          mergedClsPrefix: NRadioGroup2 ? NRadioGroup2.mergedClsPrefixRef : useConfig(props).mergedClsPrefixRef,
          inputRef,
          labelRef,
          mergedName: mergedNameRef,
          mergedDisabled: mergedDisabledRef,
          renderSafeChecked: renderSafeCheckedRef,
          focus: focusRef,
          mergedSize: mergedSizeRef,
          handleRadioInputChange,
          handleRadioInputBlur,
          handleRadioInputFocus
        };
      }
      const radioProps = Object.assign(Object.assign({}, useTheme.props), radioBaseProps);
      const NRadio = vue.defineComponent({
        name: "Radio",
        props: radioProps,
        setup(props) {
          const radio = setup(props);
          const themeRef = useTheme("Radio", "-radio", style$f, radioLight, props, radio.mergedClsPrefix);
          const cssVarsRef = vue.computed(() => {
            const {
              mergedSize: {
                value: size2
              }
            } = radio;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                boxShadow,
                boxShadowActive,
                boxShadowDisabled,
                boxShadowFocus,
                boxShadowHover,
                color,
                colorDisabled,
                colorActive,
                textColor,
                textColorDisabled,
                dotColorActive,
                dotColorDisabled,
                labelPadding,
                labelLineHeight,
                labelFontWeight,
                [createKey("fontSize", size2)]: fontSize2,
                [createKey("radioSize", size2)]: radioSize
              }
            } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-label-line-height": labelLineHeight,
              "--n-label-font-weight": labelFontWeight,
              "--n-box-shadow": boxShadow,
              "--n-box-shadow-active": boxShadowActive,
              "--n-box-shadow-disabled": boxShadowDisabled,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-box-shadow-hover": boxShadowHover,
              "--n-color": color,
              "--n-color-active": colorActive,
              "--n-color-disabled": colorDisabled,
              "--n-dot-color-active": dotColorActive,
              "--n-dot-color-disabled": dotColorDisabled,
              "--n-font-size": fontSize2,
              "--n-radio-size": radioSize,
              "--n-text-color": textColor,
              "--n-text-color-disabled": textColorDisabled,
              "--n-label-padding": labelPadding
            };
          });
          const {
            inlineThemeDisabled,
            mergedClsPrefixRef,
            mergedRtlRef
          } = useConfig(props);
          const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio", vue.computed(() => radio.mergedSize.value[0]), cssVarsRef, props) : void 0;
          return Object.assign(radio, {
            rtlEnabled: rtlEnabledRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          const {
            $slots,
            mergedClsPrefix,
            onRender,
            label
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("label", {
            class: [`${mergedClsPrefix}-radio`, this.themeClass, this.rtlEnabled && `${mergedClsPrefix}-radio--rtl`, this.mergedDisabled && `${mergedClsPrefix}-radio--disabled`, this.renderSafeChecked && `${mergedClsPrefix}-radio--checked`, this.focus && `${mergedClsPrefix}-radio--focus`],
            style: this.cssVars
          }, vue.h("div", {
            class: `${mergedClsPrefix}-radio__dot-wrapper`
          }, " ", vue.h("div", {
            class: [`${mergedClsPrefix}-radio__dot`, this.renderSafeChecked && `${mergedClsPrefix}-radio__dot--checked`]
          }), vue.h("input", {
            ref: "inputRef",
            type: "radio",
            class: `${mergedClsPrefix}-radio-input`,
            value: this.value,
            name: this.mergedName,
            checked: this.renderSafeChecked,
            disabled: this.mergedDisabled,
            onChange: this.handleRadioInputChange,
            onFocus: this.handleRadioInputFocus,
            onBlur: this.handleRadioInputBlur
          })), resolveWrappedSlot($slots.default, (children) => {
            if (!children && !label) return null;
            return vue.h("div", {
              ref: "labelRef",
              class: `${mergedClsPrefix}-radio__label`
            }, children || label);
          }));
        }
      });
      const style$e = cB("radio-group", `
 display: inline-block;
 font-size: var(--n-font-size);
`, [cE("splitor", `
 display: inline-block;
 vertical-align: bottom;
 width: 1px;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier);
 background: var(--n-button-border-color);
 `, [cM("checked", {
        backgroundColor: "var(--n-button-border-color-active)"
      }), cM("disabled", {
        opacity: "var(--n-opacity-disabled)"
      })]), cM("button-group", `
 white-space: nowrap;
 height: var(--n-height);
 line-height: var(--n-height);
 `, [cB("radio-button", {
        height: "var(--n-height)",
        lineHeight: "var(--n-height)"
      }), cE("splitor", {
        height: "var(--n-height)"
      })]), cB("radio-button", `
 vertical-align: bottom;
 outline: none;
 position: relative;
 user-select: none;
 -webkit-user-select: none;
 display: inline-block;
 box-sizing: border-box;
 padding-left: 14px;
 padding-right: 14px;
 white-space: nowrap;
 transition:
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 background: var(--n-button-color);
 color: var(--n-button-text-color);
 border-top: 1px solid var(--n-button-border-color);
 border-bottom: 1px solid var(--n-button-border-color);
 `, [cB("radio-input", `
 pointer-events: none;
 position: absolute;
 border: 0;
 border-radius: inherit;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 opacity: 0;
 z-index: 1;
 `), cE("state-border", `
 z-index: 1;
 pointer-events: none;
 position: absolute;
 box-shadow: var(--n-button-box-shadow);
 transition: box-shadow .3s var(--n-bezier);
 left: -1px;
 bottom: -1px;
 right: -1px;
 top: -1px;
 `), c$1("&:first-child", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 border-left: 1px solid var(--n-button-border-color);
 `, [cE("state-border", `
 border-top-left-radius: var(--n-button-border-radius);
 border-bottom-left-radius: var(--n-button-border-radius);
 `)]), c$1("&:last-child", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 border-right: 1px solid var(--n-button-border-color);
 `, [cE("state-border", `
 border-top-right-radius: var(--n-button-border-radius);
 border-bottom-right-radius: var(--n-button-border-radius);
 `)]), cNotM("disabled", `
 cursor: pointer;
 `, [c$1("&:hover", [cE("state-border", `
 transition: box-shadow .3s var(--n-bezier);
 box-shadow: var(--n-button-box-shadow-hover);
 `), cNotM("checked", {
        color: "var(--n-button-text-color-hover)"
      })]), cM("focus", [c$1("&:not(:active)", [cE("state-border", {
        boxShadow: "var(--n-button-box-shadow-focus)"
      })])])]), cM("checked", `
 background: var(--n-button-color-active);
 color: var(--n-button-text-color-active);
 border-color: var(--n-button-border-color-active);
 `), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-opacity-disabled);
 `)])]);
      function mapSlot(defaultSlot, value, clsPrefix) {
        var _a;
        const children = [];
        let isButtonGroup = false;
        for (let i = 0; i < defaultSlot.length; ++i) {
          const wrappedInstance = defaultSlot[i];
          const name = (_a = wrappedInstance.type) === null || _a === void 0 ? void 0 : _a.name;
          if (name === "RadioButton") {
            isButtonGroup = true;
          }
          const instanceProps = wrappedInstance.props;
          if (name !== "RadioButton") {
            children.push(wrappedInstance);
            continue;
          }
          if (i === 0) {
            children.push(wrappedInstance);
          } else {
            const lastInstanceProps = children[children.length - 1].props;
            const lastInstanceChecked = value === lastInstanceProps.value;
            const lastInstanceDisabled = lastInstanceProps.disabled;
            const currentInstanceChecked = value === instanceProps.value;
            const currentInstanceDisabled = instanceProps.disabled;
            const lastInstancePriority = (lastInstanceChecked ? 2 : 0) + (!lastInstanceDisabled ? 1 : 0);
            const currentInstancePriority = (currentInstanceChecked ? 2 : 0) + (!currentInstanceDisabled ? 1 : 0);
            const lastInstanceClass = {
              [`${clsPrefix}-radio-group__splitor--disabled`]: lastInstanceDisabled,
              [`${clsPrefix}-radio-group__splitor--checked`]: lastInstanceChecked
            };
            const currentInstanceClass = {
              [`${clsPrefix}-radio-group__splitor--disabled`]: currentInstanceDisabled,
              [`${clsPrefix}-radio-group__splitor--checked`]: currentInstanceChecked
            };
            const splitorClass = lastInstancePriority < currentInstancePriority ? currentInstanceClass : lastInstanceClass;
            children.push(vue.h("div", {
              class: [`${clsPrefix}-radio-group__splitor`, splitorClass]
            }), wrappedInstance);
          }
        }
        return {
          children,
          isButtonGroup
        };
      }
      const radioGroupProps = Object.assign(Object.assign({}, useTheme.props), {
        name: String,
        value: [String, Number, Boolean],
        defaultValue: {
          type: [String, Number, Boolean],
          default: null
        },
        size: String,
        disabled: {
          type: Boolean,
          default: void 0
        },
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array]
      });
      const NRadioGroup = vue.defineComponent({
        name: "RadioGroup",
        props: radioGroupProps,
        setup(props) {
          const selfElRef = vue.ref(null);
          const {
            mergedSizeRef,
            mergedDisabledRef,
            nTriggerFormChange,
            nTriggerFormInput,
            nTriggerFormBlur,
            nTriggerFormFocus
          } = useFormItem(props);
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const themeRef = useTheme("Radio", "-radio-group", style$e, radioLight, props, mergedClsPrefixRef);
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          function doUpdateValue(value) {
            const {
              onUpdateValue,
              "onUpdate:value": _onUpdateValue
            } = props;
            if (onUpdateValue) {
              call(onUpdateValue, value);
            }
            if (_onUpdateValue) {
              call(_onUpdateValue, value);
            }
            uncontrolledValueRef.value = value;
            nTriggerFormChange();
            nTriggerFormInput();
          }
          function handleFocusin(e) {
            const {
              value: selfEl
            } = selfElRef;
            if (!selfEl) return;
            if (selfEl.contains(e.relatedTarget)) return;
            nTriggerFormFocus();
          }
          function handleFocusout(e) {
            const {
              value: selfEl
            } = selfElRef;
            if (!selfEl) return;
            if (selfEl.contains(e.relatedTarget)) return;
            nTriggerFormBlur();
          }
          vue.provide(radioGroupInjectionKey, {
            mergedClsPrefixRef,
            nameRef: vue.toRef(props, "name"),
            valueRef: mergedValueRef,
            disabledRef: mergedDisabledRef,
            mergedSizeRef,
            doUpdateValue
          });
          const rtlEnabledRef = useRtl("Radio", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              value: size2
            } = mergedSizeRef;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                buttonBorderColor,
                buttonBorderColorActive,
                buttonBorderRadius,
                buttonBoxShadow,
                buttonBoxShadowFocus,
                buttonBoxShadowHover,
                buttonColor,
                buttonColorActive,
                buttonTextColor,
                buttonTextColorActive,
                buttonTextColorHover,
                opacityDisabled,
                [createKey("buttonHeight", size2)]: height,
                [createKey("fontSize", size2)]: fontSize2
              }
            } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-button-border-color": buttonBorderColor,
              "--n-button-border-color-active": buttonBorderColorActive,
              "--n-button-border-radius": buttonBorderRadius,
              "--n-button-box-shadow": buttonBoxShadow,
              "--n-button-box-shadow-focus": buttonBoxShadowFocus,
              "--n-button-box-shadow-hover": buttonBoxShadowHover,
              "--n-button-color": buttonColor,
              "--n-button-color-active": buttonColorActive,
              "--n-button-text-color": buttonTextColor,
              "--n-button-text-color-hover": buttonTextColorHover,
              "--n-button-text-color-active": buttonTextColorActive,
              "--n-height": height,
              "--n-opacity-disabled": opacityDisabled
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("radio-group", vue.computed(() => mergedSizeRef.value[0]), cssVarsRef, props) : void 0;
          return {
            selfElRef,
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue: mergedValueRef,
            handleFocusout,
            handleFocusin,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const {
            mergedValue,
            mergedClsPrefix,
            handleFocusin,
            handleFocusout
          } = this;
          const {
            children,
            isButtonGroup
          } = mapSlot(flatten$2(getSlot(this)), mergedValue, mergedClsPrefix);
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("div", {
            onFocusin: handleFocusin,
            onFocusout: handleFocusout,
            ref: "selfElRef",
            class: [`${mergedClsPrefix}-radio-group`, this.rtlEnabled && `${mergedClsPrefix}-radio-group--rtl`, this.themeClass, isButtonGroup && `${mergedClsPrefix}-radio-group--button-group`],
            style: this.cssVars
          }, children);
        }
      });
      const RenderSafeRadio = vue.defineComponent({
        name: "DataTableBodyRadio",
        props: {
          rowKey: {
            type: [String, Number],
            required: true
          },
          disabled: {
            type: Boolean,
            required: true
          },
          onUpdateChecked: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const {
            mergedCheckedRowKeySetRef,
            componentId
          } = vue.inject(dataTableInjectionKey);
          return () => {
            const {
              rowKey
            } = props;
            return vue.h(NRadio, {
              name: componentId,
              disabled: props.disabled,
              checked: mergedCheckedRowKeySetRef.value.has(rowKey),
              onUpdateChecked: props.onUpdateChecked
            });
          };
        }
      });
      const tooltipProps = Object.assign(Object.assign({}, popoverBaseProps), useTheme.props);
      const NTooltip = vue.defineComponent({
        name: "Tooltip",
        props: tooltipProps,
        slots: Object,
        __popover__: true,
        setup(props) {
          const {
            mergedClsPrefixRef
          } = useConfig(props);
          const themeRef = useTheme("Tooltip", "-tooltip", void 0, tooltipLight, props, mergedClsPrefixRef);
          const popoverRef = vue.ref(null);
          const tooltipExposedMethod = {
            syncPosition() {
              popoverRef.value.syncPosition();
            },
            setShow(show) {
              popoverRef.value.setShow(show);
            }
          };
          return Object.assign(Object.assign({}, tooltipExposedMethod), {
            popoverRef,
            mergedTheme: themeRef,
            popoverThemeOverrides: vue.computed(() => {
              return themeRef.value.self;
            })
          });
        },
        render() {
          const {
            mergedTheme,
            internalExtraClass
          } = this;
          return vue.h(NPopover, Object.assign(Object.assign({}, this.$props), {
            theme: mergedTheme.peers.Popover,
            themeOverrides: mergedTheme.peerOverrides.Popover,
            builtinThemeOverrides: this.popoverThemeOverrides,
            internalExtraClass: internalExtraClass.concat("tooltip"),
            ref: "popoverRef"
          }), this.$slots);
        }
      });
      const style$d = cB("ellipsis", {
        overflow: "hidden"
      }, [cNotM("line-clamp", `
 white-space: nowrap;
 display: inline-block;
 vertical-align: bottom;
 max-width: 100%;
 `), cM("line-clamp", `
 display: -webkit-inline-box;
 -webkit-box-orient: vertical;
 `), cM("cursor-pointer", `
 cursor: pointer;
 `)]);
      function createLineClampClass(clsPrefix) {
        return `${clsPrefix}-ellipsis--line-clamp`;
      }
      function createCursorClass(clsPrefix, cursor) {
        return `${clsPrefix}-ellipsis--cursor-${cursor}`;
      }
      const ellipsisProps = Object.assign(Object.assign({}, useTheme.props), {
        expandTrigger: String,
        lineClamp: [Number, String],
        tooltip: {
          type: [Boolean, Object],
          default: true
        }
      });
      const NEllipsis = vue.defineComponent({
        name: "Ellipsis",
        inheritAttrs: false,
        props: ellipsisProps,
        slots: Object,
        setup(props, {
          slots,
          attrs
        }) {
          const mergedClsPrefixRef = useMergedClsPrefix();
          const mergedTheme = useTheme("Ellipsis", "-ellipsis", style$d, ellipsisLight, props, mergedClsPrefixRef);
          const triggerRef = vue.ref(null);
          const triggerInnerRef = vue.ref(null);
          const tooltipRef = vue.ref(null);
          const expandedRef = vue.ref(false);
          const ellipsisStyleRef = vue.computed(() => {
            const {
              lineClamp
            } = props;
            const {
              value: expanded
            } = expandedRef;
            if (lineClamp !== void 0) {
              return {
                textOverflow: "",
                "-webkit-line-clamp": expanded ? "" : lineClamp
              };
            } else {
              return {
                textOverflow: expanded ? "" : "ellipsis",
                "-webkit-line-clamp": ""
              };
            }
          });
          function getTooltipDisabled() {
            let tooltipDisabled = false;
            const {
              value: expanded
            } = expandedRef;
            if (expanded) return true;
            const {
              value: trigger2
            } = triggerRef;
            if (trigger2) {
              const {
                lineClamp
              } = props;
              syncEllipsisStyle(trigger2);
              if (lineClamp !== void 0) {
                tooltipDisabled = trigger2.scrollHeight <= trigger2.offsetHeight;
              } else {
                const {
                  value: triggerInner
                } = triggerInnerRef;
                if (triggerInner) {
                  tooltipDisabled = triggerInner.getBoundingClientRect().width <= trigger2.getBoundingClientRect().width;
                }
              }
              syncCursorStyle(trigger2, tooltipDisabled);
            }
            return tooltipDisabled;
          }
          const handleClickRef = vue.computed(() => {
            return props.expandTrigger === "click" ? () => {
              var _a;
              const {
                value: expanded
              } = expandedRef;
              if (expanded) {
                (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
              }
              expandedRef.value = !expanded;
            } : void 0;
          });
          vue.onDeactivated(() => {
            var _a;
            if (props.tooltip) {
              (_a = tooltipRef.value) === null || _a === void 0 ? void 0 : _a.setShow(false);
            }
          });
          const renderTrigger = () => vue.h("span", Object.assign({}, vue.mergeProps(attrs, {
            class: [`${mergedClsPrefixRef.value}-ellipsis`, props.lineClamp !== void 0 ? createLineClampClass(mergedClsPrefixRef.value) : void 0, props.expandTrigger === "click" ? createCursorClass(mergedClsPrefixRef.value, "pointer") : void 0],
            style: ellipsisStyleRef.value
          }), {
            ref: "triggerRef",
            onClick: handleClickRef.value,
            onMouseenter: (
props.expandTrigger === "click" ? getTooltipDisabled : void 0
            )
          }), props.lineClamp ? slots : vue.h("span", {
            ref: "triggerInnerRef"
          }, slots));
          function syncEllipsisStyle(trigger2) {
            if (!trigger2) return;
            const latestStyle = ellipsisStyleRef.value;
            const lineClampClass = createLineClampClass(mergedClsPrefixRef.value);
            if (props.lineClamp !== void 0) {
              syncTriggerClass(trigger2, lineClampClass, "add");
            } else {
              syncTriggerClass(trigger2, lineClampClass, "remove");
            }
            for (const key in latestStyle) {
              if (trigger2.style[key] !== latestStyle[key]) {
                trigger2.style[key] = latestStyle[key];
              }
            }
          }
          function syncCursorStyle(trigger2, tooltipDisabled) {
            const cursorClass = createCursorClass(mergedClsPrefixRef.value, "pointer");
            if (props.expandTrigger === "click" && !tooltipDisabled) {
              syncTriggerClass(trigger2, cursorClass, "add");
            } else {
              syncTriggerClass(trigger2, cursorClass, "remove");
            }
          }
          function syncTriggerClass(trigger2, styleClass, action) {
            if (action === "add") {
              if (!trigger2.classList.contains(styleClass)) {
                trigger2.classList.add(styleClass);
              }
            } else {
              if (trigger2.classList.contains(styleClass)) {
                trigger2.classList.remove(styleClass);
              }
            }
          }
          return {
            mergedTheme,
            triggerRef,
            triggerInnerRef,
            tooltipRef,
            handleClick: handleClickRef,
            renderTrigger,
            getTooltipDisabled
          };
        },
        render() {
          var _a;
          const {
            tooltip,
            renderTrigger,
            $slots
          } = this;
          if (tooltip) {
            const {
              mergedTheme
            } = this;
            return vue.h(NTooltip, Object.assign({
              ref: "tooltipRef",
              placement: "top"
            }, tooltip, {
              getDisabled: this.getTooltipDisabled,
              theme: mergedTheme.peers.Tooltip,
              themeOverrides: mergedTheme.peerOverrides.Tooltip
            }), {
              trigger: renderTrigger,
              default: (_a = $slots.tooltip) !== null && _a !== void 0 ? _a : $slots.default
            });
          } else {
            return renderTrigger();
          }
        }
      });
      const NPerformantEllipsis = vue.defineComponent({
        name: "PerformantEllipsis",
        props: ellipsisProps,
        inheritAttrs: false,
        setup(props, {
          attrs,
          slots
        }) {
          const mouseEnteredRef = vue.ref(false);
          const mergedClsPrefixRef = useMergedClsPrefix();
          useStyle("-ellipsis", style$d, mergedClsPrefixRef);
          const renderTrigger = () => {
            const {
              lineClamp
            } = props;
            const mergedClsPrefix = mergedClsPrefixRef.value;
            return vue.h("span", Object.assign({}, vue.mergeProps(attrs, {
              class: [`${mergedClsPrefix}-ellipsis`, lineClamp !== void 0 ? createLineClampClass(mergedClsPrefix) : void 0, props.expandTrigger === "click" ? createCursorClass(mergedClsPrefix, "pointer") : void 0],
              style: lineClamp === void 0 ? {
                textOverflow: "ellipsis"
              } : {
                "-webkit-line-clamp": lineClamp
              }
            }), {
              onMouseenter: () => {
                mouseEnteredRef.value = true;
              }
            }), lineClamp ? slots : vue.h("span", null, slots));
          };
          return {
            mouseEntered: mouseEnteredRef,
            renderTrigger
          };
        },
        render() {
          if (this.mouseEntered) {
            return vue.h(NEllipsis, vue.mergeProps({}, this.$attrs, this.$props), this.$slots);
          } else {
            return this.renderTrigger();
          }
        }
      });
      const Cell = vue.defineComponent({
        name: "DataTableCell",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          row: {
            type: Object,
            required: true
          },
          index: {
            type: Number,
            required: true
          },
          column: {
            type: Object,
            required: true
          },
          isSummary: Boolean,
          mergedTheme: {
            type: Object,
            required: true
          },
          renderCell: Function
        },
        render() {
          var _a;
          const {
            isSummary,
            column,
            row,
            renderCell
          } = this;
          let cell;
          const {
            render: render2,
            key,
            ellipsis
          } = column;
          if (render2 && !isSummary) {
            cell = render2(row, this.index);
          } else {
            if (isSummary) {
              cell = (_a = row[key]) === null || _a === void 0 ? void 0 : _a.value;
            } else {
              cell = renderCell ? renderCell(get(row, key), row, column) : get(row, key);
            }
          }
          if (ellipsis) {
            if (typeof ellipsis === "object") {
              const {
                mergedTheme
              } = this;
              if (column.ellipsisComponent === "performant-ellipsis") {
                return vue.h(NPerformantEllipsis, Object.assign({}, ellipsis, {
                  theme: mergedTheme.peers.Ellipsis,
                  themeOverrides: mergedTheme.peerOverrides.Ellipsis
                }), {
                  default: () => cell
                });
              }
              return vue.h(NEllipsis, Object.assign({}, ellipsis, {
                theme: mergedTheme.peers.Ellipsis,
                themeOverrides: mergedTheme.peerOverrides.Ellipsis
              }), {
                default: () => cell
              });
            } else {
              return vue.h("span", {
                class: `${this.clsPrefix}-data-table-td__ellipsis`
              }, cell);
            }
          }
          return cell;
        }
      });
      const ExpandTrigger = vue.defineComponent({
        name: "DataTableExpandTrigger",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          expanded: Boolean,
          loading: Boolean,
          onClick: {
            type: Function,
            required: true
          },
          renderExpandIcon: {
            type: Function
          },
          rowData: {
            type: Object,
            required: true
          }
        },
        render() {
          const {
            clsPrefix
          } = this;
          return vue.h("div", {
            class: [`${clsPrefix}-data-table-expand-trigger`, this.expanded && `${clsPrefix}-data-table-expand-trigger--expanded`],
            onClick: this.onClick,
            onMousedown: (e) => {
              e.preventDefault();
            }
          }, vue.h(NIconSwitchTransition, null, {
            default: () => {
              return this.loading ? vue.h(NBaseLoading, {
                key: "loading",
                clsPrefix: this.clsPrefix,
                radius: 85,
                strokeWidth: 15,
                scale: 0.88
              }) : this.renderExpandIcon ? this.renderExpandIcon({
                expanded: this.expanded,
                rowData: this.rowData
              }) : vue.h(NBaseIcon, {
                clsPrefix,
                key: "base-icon"
              }, {
                default: () => vue.h(ChevronRightIcon, null)
              });
            }
          }));
        }
      });
      const NDataTableFilterMenu = vue.defineComponent({
        name: "DataTableFilterMenu",
        props: {
          column: {
            type: Object,
            required: true
          },
          radioGroupName: {
            type: String,
            required: true
          },
          multiple: {
            type: Boolean,
            required: true
          },
          value: {
            type: [Array, String, Number],
            default: null
          },
          options: {
            type: Array,
            required: true
          },
          onConfirm: {
            type: Function,
            required: true
          },
          onClear: {
            type: Function,
            required: true
          },
          onChange: {
            type: Function,
            required: true
          }
        },
        setup(props) {
          const {
            mergedClsPrefixRef: mergedClsPrefixRefRtl,
            mergedRtlRef
          } = useConfig(props);
          const rtlEnabledRef = useRtl("DataTable", mergedRtlRef, mergedClsPrefixRefRtl);
          const {
            mergedClsPrefixRef,
            mergedThemeRef,
            localeRef
          } = vue.inject(dataTableInjectionKey);
          const temporalValueRef = vue.ref(props.value);
          const checkboxGroupValueRef = vue.computed(() => {
            const {
              value: temporalValue
            } = temporalValueRef;
            if (!Array.isArray(temporalValue)) return null;
            return temporalValue;
          });
          const radioGroupValueRef = vue.computed(() => {
            const {
              value: temporalValue
            } = temporalValueRef;
            if (shouldUseArrayInSingleMode(props.column)) {
              return Array.isArray(temporalValue) && temporalValue.length && temporalValue[0] || null;
            }
            if (!Array.isArray(temporalValue)) return temporalValue;
            return null;
          });
          function doChange(value) {
            props.onChange(value);
          }
          function handleChange(value) {
            if (props.multiple && Array.isArray(value)) {
              temporalValueRef.value = value;
            } else if (shouldUseArrayInSingleMode(props.column) && !Array.isArray(value)) {
              temporalValueRef.value = [value];
            } else {
              temporalValueRef.value = value;
            }
          }
          function handleConfirmClick() {
            doChange(temporalValueRef.value);
            props.onConfirm();
          }
          function handleClearClick() {
            if (props.multiple || shouldUseArrayInSingleMode(props.column)) {
              doChange([]);
            } else {
              doChange(null);
            }
            props.onClear();
          }
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            mergedTheme: mergedThemeRef,
            locale: localeRef,
            checkboxGroupValue: checkboxGroupValueRef,
            radioGroupValue: radioGroupValueRef,
            handleChange,
            handleConfirmClick,
            handleClearClick
          };
        },
        render() {
          const {
            mergedTheme,
            locale,
            mergedClsPrefix
          } = this;
          return vue.h("div", {
            class: [`${mergedClsPrefix}-data-table-filter-menu`, this.rtlEnabled && `${mergedClsPrefix}-data-table-filter-menu--rtl`]
          }, vue.h(Scrollbar, null, {
            default: () => {
              const {
                checkboxGroupValue,
                handleChange
              } = this;
              return this.multiple ? vue.h(NCheckboxGroup, {
                value: checkboxGroupValue,
                class: `${mergedClsPrefix}-data-table-filter-menu__group`,
                onUpdateValue: handleChange
              }, {
                default: () => this.options.map((option) => {
                  return vue.h(NCheckbox, {
                    key: option.value,
                    theme: mergedTheme.peers.Checkbox,
                    themeOverrides: mergedTheme.peerOverrides.Checkbox,
                    value: option.value
                  }, {
                    default: () => option.label
                  });
                })
              }) : vue.h(NRadioGroup, {
                name: this.radioGroupName,
                class: `${mergedClsPrefix}-data-table-filter-menu__group`,
                value: this.radioGroupValue,
                onUpdateValue: this.handleChange
              }, {
                default: () => this.options.map((option) => vue.h(NRadio, {
                  key: option.value,
                  value: option.value,
                  theme: mergedTheme.peers.Radio,
                  themeOverrides: mergedTheme.peerOverrides.Radio
                }, {
                  default: () => option.label
                }))
              });
            }
          }), vue.h("div", {
            class: `${mergedClsPrefix}-data-table-filter-menu__action`
          }, vue.h(Button, {
            size: "tiny",
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button,
            onClick: this.handleClearClick
          }, {
            default: () => locale.clear
          }), vue.h(Button, {
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button,
            type: "primary",
            size: "tiny",
            onClick: this.handleConfirmClick
          }, {
            default: () => locale.confirm
          })));
        }
      });
      const RenderFilter = vue.defineComponent({
        name: "DataTableRenderFilter",
        props: {
          render: {
            type: Function,
            required: true
          },
          active: {
            type: Boolean,
            default: false
          },
          show: {
            type: Boolean,
            default: false
          }
        },
        render() {
          const {
            render: render2,
            active,
            show
          } = this;
          return render2({
            active,
            show
          });
        }
      });
      function createFilterState(currentFilterState, columnKey, mergedFilterValue) {
        const nextFilterState = Object.assign({}, currentFilterState);
        nextFilterState[columnKey] = mergedFilterValue;
        return nextFilterState;
      }
      const FilterButton = vue.defineComponent({
        name: "DataTableFilterButton",
        props: {
          column: {
            type: Object,
            required: true
          },
          options: {
            type: Array,
            default: () => []
          }
        },
        setup(props) {
          const {
            mergedComponentPropsRef
          } = useConfig();
          const {
            mergedThemeRef,
            mergedClsPrefixRef,
            mergedFilterStateRef,
            filterMenuCssVarsRef,
            paginationBehaviorOnFilterRef,
            doUpdatePage,
            doUpdateFilters,
            filterIconPopoverPropsRef
          } = vue.inject(dataTableInjectionKey);
          const showPopoverRef = vue.ref(false);
          const filterStateRef = mergedFilterStateRef;
          const filterMultipleRef = vue.computed(() => {
            return props.column.filterMultiple !== false;
          });
          const mergedFilterValueRef = vue.computed(() => {
            const filterValue = filterStateRef.value[props.column.key];
            if (filterValue === void 0) {
              const {
                value: multiple
              } = filterMultipleRef;
              if (multiple) return [];
              else return null;
            }
            return filterValue;
          });
          const activeRef = vue.computed(() => {
            const {
              value: filterValue
            } = mergedFilterValueRef;
            if (Array.isArray(filterValue)) {
              return filterValue.length > 0;
            }
            return filterValue !== null;
          });
          const mergedRenderFilterRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderFilter) || props.column.renderFilter;
          });
          function handleFilterChange(mergedFilterValue) {
            const nextFilterState = createFilterState(filterStateRef.value, props.column.key, mergedFilterValue);
            doUpdateFilters(nextFilterState, props.column);
            if (paginationBehaviorOnFilterRef.value === "first") {
              doUpdatePage(1);
            }
          }
          function handleFilterMenuCancel() {
            showPopoverRef.value = false;
          }
          function handleFilterMenuConfirm() {
            showPopoverRef.value = false;
          }
          return {
            mergedTheme: mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            active: activeRef,
            showPopover: showPopoverRef,
            mergedRenderFilter: mergedRenderFilterRef,
            filterIconPopoverProps: filterIconPopoverPropsRef,
            filterMultiple: filterMultipleRef,
            mergedFilterValue: mergedFilterValueRef,
            filterMenuCssVars: filterMenuCssVarsRef,
            handleFilterChange,
            handleFilterMenuConfirm,
            handleFilterMenuCancel
          };
        },
        render() {
          const {
            mergedTheme,
            mergedClsPrefix,
            handleFilterMenuCancel,
            filterIconPopoverProps
          } = this;
          return vue.h(NPopover, Object.assign({
            show: this.showPopover,
            onUpdateShow: (v) => this.showPopover = v,
            trigger: "click",
            theme: mergedTheme.peers.Popover,
            themeOverrides: mergedTheme.peerOverrides.Popover,
            placement: "bottom"
          }, filterIconPopoverProps, {
            style: {
              padding: 0
            }
          }), {
            trigger: () => {
              const {
                mergedRenderFilter
              } = this;
              if (mergedRenderFilter) {
                return vue.h(RenderFilter, {
                  "data-data-table-filter": true,
                  render: mergedRenderFilter,
                  active: this.active,
                  show: this.showPopover
                });
              }
              const {
                renderFilterIcon
              } = this.column;
              return vue.h("div", {
                "data-data-table-filter": true,
                class: [`${mergedClsPrefix}-data-table-filter`, {
                  [`${mergedClsPrefix}-data-table-filter--active`]: this.active,
                  [`${mergedClsPrefix}-data-table-filter--show`]: this.showPopover
                }]
              }, renderFilterIcon ? renderFilterIcon({
                active: this.active,
                show: this.showPopover
              }) : vue.h(NBaseIcon, {
                clsPrefix: mergedClsPrefix
              }, {
                default: () => vue.h(FilterIcon, null)
              }));
            },
            default: () => {
              const {
                renderFilterMenu
              } = this.column;
              return renderFilterMenu ? renderFilterMenu({
                hide: handleFilterMenuCancel
              }) : vue.h(NDataTableFilterMenu, {
                style: this.filterMenuCssVars,
                radioGroupName: String(this.column.key),
                multiple: this.filterMultiple,
                value: this.mergedFilterValue,
                options: this.options,
                column: this.column,
                onChange: this.handleFilterChange,
                onClear: this.handleFilterMenuCancel,
                onConfirm: this.handleFilterMenuConfirm
              });
            }
          });
        }
      });
      const ResizeButton = vue.defineComponent({
        name: "ColumnResizeButton",
        props: {
          onResizeStart: Function,
          onResize: Function,
          onResizeEnd: Function
        },
        setup(props) {
          const {
            mergedClsPrefixRef
          } = vue.inject(dataTableInjectionKey);
          const activeRef = vue.ref(false);
          let startX = 0;
          function getMouseX(e) {
            return e.clientX;
          }
          function handleMousedown(e) {
            var _a;
            e.preventDefault();
            const alreadyStarted = activeRef.value;
            startX = getMouseX(e);
            activeRef.value = true;
            if (!alreadyStarted) {
              on("mousemove", window, handleMousemove);
              on("mouseup", window, handleMouseup);
              (_a = props.onResizeStart) === null || _a === void 0 ? void 0 : _a.call(props);
            }
          }
          function handleMousemove(e) {
            var _a;
            (_a = props.onResize) === null || _a === void 0 ? void 0 : _a.call(props, getMouseX(e) - startX);
          }
          function handleMouseup() {
            var _a;
            activeRef.value = false;
            (_a = props.onResizeEnd) === null || _a === void 0 ? void 0 : _a.call(props);
            off("mousemove", window, handleMousemove);
            off("mouseup", window, handleMouseup);
          }
          vue.onBeforeUnmount(() => {
            off("mousemove", window, handleMousemove);
            off("mouseup", window, handleMouseup);
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            active: activeRef,
            handleMousedown
          };
        },
        render() {
          const {
            mergedClsPrefix
          } = this;
          return vue.h("span", {
            "data-data-table-resizable": true,
            class: [`${mergedClsPrefix}-data-table-resize-button`, this.active && `${mergedClsPrefix}-data-table-resize-button--active`],
            onMousedown: this.handleMousedown
          });
        }
      });
      const RenderSorter = vue.defineComponent({
        name: "DataTableRenderSorter",
        props: {
          render: {
            type: Function,
            required: true
          },
          order: {
type: [String, Boolean],
            default: false
          }
        },
        render() {
          const {
            render: render2,
            order
          } = this;
          return render2({
            order
          });
        }
      });
      const SortButton = vue.defineComponent({
        name: "SortIcon",
        props: {
          column: {
            type: Object,
            required: true
          }
        },
        setup(props) {
          const {
            mergedComponentPropsRef
          } = useConfig();
          const {
            mergedSortStateRef,
            mergedClsPrefixRef
          } = vue.inject(dataTableInjectionKey);
          const sortStateRef = vue.computed(() => mergedSortStateRef.value.find((state) => state.columnKey === props.column.key));
          const activeRef = vue.computed(() => {
            return sortStateRef.value !== void 0;
          });
          const mergedSortOrderRef = vue.computed(() => {
            const {
              value: sortState
            } = sortStateRef;
            if (sortState && activeRef.value) {
              return sortState.order;
            }
            return false;
          });
          const mergedRenderSorterRef = vue.computed(() => {
            var _a, _b;
            return ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.DataTable) === null || _b === void 0 ? void 0 : _b.renderSorter) || props.column.renderSorter;
          });
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            active: activeRef,
            mergedSortOrder: mergedSortOrderRef,
            mergedRenderSorter: mergedRenderSorterRef
          };
        },
        render() {
          const {
            mergedRenderSorter,
            mergedSortOrder,
            mergedClsPrefix
          } = this;
          const {
            renderSorterIcon
          } = this.column;
          return mergedRenderSorter ? vue.h(RenderSorter, {
            render: mergedRenderSorter,
            order: mergedSortOrder
          }) : vue.h("span", {
            class: [`${mergedClsPrefix}-data-table-sorter`, mergedSortOrder === "ascend" && `${mergedClsPrefix}-data-table-sorter--asc`, mergedSortOrder === "descend" && `${mergedClsPrefix}-data-table-sorter--desc`]
          }, renderSorterIcon ? renderSorterIcon({
            order: mergedSortOrder
          }) : vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(ArrowDownIcon, null)
          }));
        }
      });
      const dropdownMenuInjectionKey = createInjectionKey("n-dropdown-menu");
      const dropdownInjectionKey = createInjectionKey("n-dropdown");
      const dropdownOptionInjectionKey = createInjectionKey("n-dropdown-option");
      const NDropdownDivider = vue.defineComponent({
        name: "DropdownDivider",
        props: {
          clsPrefix: {
            type: String,
            required: true
          }
        },
        render() {
          return vue.h("div", {
            class: `${this.clsPrefix}-dropdown-divider`
          });
        }
      });
      const NDropdownGroupHeader = vue.defineComponent({
        name: "DropdownGroupHeader",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          }
        },
        setup() {
          const {
            showIconRef,
            hasSubmenuRef
          } = vue.inject(dropdownMenuInjectionKey);
          const {
            renderLabelRef,
            labelFieldRef,
            nodePropsRef,
            renderOptionRef
          } = vue.inject(dropdownInjectionKey);
          return {
            labelField: labelFieldRef,
            showIcon: showIconRef,
            hasSubmenu: hasSubmenuRef,
            renderLabel: renderLabelRef,
            nodeProps: nodePropsRef,
            renderOption: renderOptionRef
          };
        },
        render() {
          var _a;
          const {
            clsPrefix,
            hasSubmenu,
            showIcon,
            nodeProps,
            renderLabel,
            renderOption
          } = this;
          const {
            rawNode
          } = this.tmNode;
          const node = vue.h("div", Object.assign({
            class: `${clsPrefix}-dropdown-option`
          }, nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode)), vue.h("div", {
            class: `${clsPrefix}-dropdown-option-body ${clsPrefix}-dropdown-option-body--group`
          }, vue.h("div", {
            "data-dropdown-option": true,
            class: [`${clsPrefix}-dropdown-option-body__prefix`, showIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
          }, render(rawNode.icon)), vue.h("div", {
            class: `${clsPrefix}-dropdown-option-body__label`,
            "data-dropdown-option": true
          }, renderLabel ? renderLabel(rawNode) : render((_a = rawNode.title) !== null && _a !== void 0 ? _a : rawNode[this.labelField])), vue.h("div", {
            class: [`${clsPrefix}-dropdown-option-body__suffix`, hasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`],
            "data-dropdown-option": true
          })));
          if (renderOption) {
            return renderOption({
              node,
              option: rawNode
            });
          }
          return node;
        }
      });
      function self$c(vars) {
        const {
          textColorBase,
          opacity1,
          opacity2,
          opacity3,
          opacity4,
          opacity5
        } = vars;
        return {
          color: textColorBase,
          opacity1Depth: opacity1,
          opacity2Depth: opacity2,
          opacity3Depth: opacity3,
          opacity4Depth: opacity4,
          opacity5Depth: opacity5
        };
      }
      const iconLight = {
        common: derived,
        self: self$c
      };
      const style$c = cB("icon", `
 height: 1em;
 width: 1em;
 line-height: 1em;
 text-align: center;
 display: inline-block;
 position: relative;
 fill: currentColor;
`, [cM("color-transition", {
        transition: "color .3s var(--n-bezier)"
      }), cM("depth", {
        color: "var(--n-color)"
      }, [c$1("svg", {
        opacity: "var(--n-opacity)",
        transition: "opacity .3s var(--n-bezier)"
      })]), c$1("svg", {
        height: "1em",
        width: "1em"
      })]);
      const iconProps = Object.assign(Object.assign({}, useTheme.props), {
        depth: [String, Number],
        size: [Number, String],
        color: String,
        component: [Object, Function]
      });
      const NIcon = vue.defineComponent({
        _n_icon__: true,
        name: "Icon",
        inheritAttrs: false,
        props: iconProps,
        setup(props) {
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled
          } = useConfig(props);
          const themeRef = useTheme("Icon", "-icon", style$c, iconLight, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              depth
            } = props;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: self2
            } = themeRef.value;
            if (depth !== void 0) {
              const {
                color,
                [`opacity${depth}Depth`]: opacity
              } = self2;
              return {
                "--n-bezier": cubicBezierEaseInOut2,
                "--n-color": color,
                "--n-opacity": opacity
              };
            }
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-color": "",
              "--n-opacity": ""
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("icon", vue.computed(() => `${props.depth || "d"}`), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedStyle: vue.computed(() => {
              const {
                size: size2,
                color
              } = props;
              return {
                fontSize: formatLength(size2),
                color
              };
            }),
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const {
            $parent,
            depth,
            mergedClsPrefix,
            component,
            onRender,
            themeClass
          } = this;
          if ((_a = $parent === null || $parent === void 0 ? void 0 : $parent.$options) === null || _a === void 0 ? void 0 : _a._n_icon__) {
            warn("icon", "don't wrap `n-icon` inside `n-icon`");
          }
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("i", vue.mergeProps(this.$attrs, {
            role: "img",
            class: [`${mergedClsPrefix}-icon`, themeClass, {
              [`${mergedClsPrefix}-icon--depth`]: depth,
              [`${mergedClsPrefix}-icon--color-transition`]: depth !== void 0
            }],
            style: [this.cssVars, this.mergedStyle]
          }), component ? vue.h(component) : this.$slots);
        }
      });
      function isSubmenuNode(rawNode, childrenField) {
        return rawNode.type === "submenu" || rawNode.type === void 0 && rawNode[childrenField] !== void 0;
      }
      function isGroupNode(rawNode) {
        return rawNode.type === "group";
      }
      function isDividerNode(rawNode) {
        return rawNode.type === "divider";
      }
      function isRenderNode(rawNode) {
        return rawNode.type === "render";
      }
      const NDropdownOption = vue.defineComponent({
        name: "DropdownOption",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          },
          parentKey: {
            type: [String, Number],
            default: null
          },
          placement: {
            type: String,
            default: "right-start"
          },
          props: Object,
          scrollable: Boolean
        },
        setup(props) {
          const NDropdown2 = vue.inject(dropdownInjectionKey);
          const {
            hoverKeyRef,
            keyboardKeyRef,
            lastToggledSubmenuKeyRef,
            pendingKeyPathRef,
            activeKeyPathRef,
            animatedRef,
            mergedShowRef,
            renderLabelRef,
            renderIconRef,
            labelFieldRef,
            childrenFieldRef,
            renderOptionRef,
            nodePropsRef,
            menuPropsRef
          } = NDropdown2;
          const NDropdownOption2 = vue.inject(dropdownOptionInjectionKey, null);
          const NDropdownMenu2 = vue.inject(dropdownMenuInjectionKey);
          const NPopoverBody2 = vue.inject(popoverBodyInjectionKey);
          const rawNodeRef = vue.computed(() => props.tmNode.rawNode);
          const hasSubmenuRef = vue.computed(() => {
            const {
              value: childrenField
            } = childrenFieldRef;
            return isSubmenuNode(props.tmNode.rawNode, childrenField);
          });
          const mergedDisabledRef = vue.computed(() => {
            const {
              disabled
            } = props.tmNode;
            return disabled;
          });
          const showSubmenuRef = vue.computed(() => {
            if (!hasSubmenuRef.value) return false;
            const {
              key,
              disabled
            } = props.tmNode;
            if (disabled) return false;
            const {
              value: hoverKey
            } = hoverKeyRef;
            const {
              value: keyboardKey
            } = keyboardKeyRef;
            const {
              value: lastToggledSubmenuKey
            } = lastToggledSubmenuKeyRef;
            const {
              value: pendingKeyPath
            } = pendingKeyPathRef;
            if (hoverKey !== null) return pendingKeyPath.includes(key);
            if (keyboardKey !== null) {
              return pendingKeyPath.includes(key) && pendingKeyPath[pendingKeyPath.length - 1] !== key;
            }
            if (lastToggledSubmenuKey !== null) return pendingKeyPath.includes(key);
            return false;
          });
          const shouldDelayRef = vue.computed(() => {
            return keyboardKeyRef.value === null && !animatedRef.value;
          });
          const deferredShowSubmenuRef = useDeferredTrue(showSubmenuRef, 300, shouldDelayRef);
          const parentEnteringSubmenuRef = vue.computed(() => {
            return !!(NDropdownOption2 === null || NDropdownOption2 === void 0 ? void 0 : NDropdownOption2.enteringSubmenuRef.value);
          });
          const enteringSubmenuRef = vue.ref(false);
          vue.provide(dropdownOptionInjectionKey, {
            enteringSubmenuRef
          });
          function handleSubmenuBeforeEnter() {
            enteringSubmenuRef.value = true;
          }
          function handleSubmenuAfterEnter() {
            enteringSubmenuRef.value = false;
          }
          function handleMouseEnter() {
            const {
              parentKey,
              tmNode
            } = props;
            if (tmNode.disabled) return;
            if (!mergedShowRef.value) return;
            lastToggledSubmenuKeyRef.value = parentKey;
            keyboardKeyRef.value = null;
            hoverKeyRef.value = tmNode.key;
          }
          function handleMouseMove() {
            const {
              tmNode
            } = props;
            if (tmNode.disabled) return;
            if (!mergedShowRef.value) return;
            if (hoverKeyRef.value === tmNode.key) return;
            handleMouseEnter();
          }
          function handleMouseLeave(e) {
            if (props.tmNode.disabled) return;
            if (!mergedShowRef.value) return;
            const {
              relatedTarget
            } = e;
            if (relatedTarget && !happensIn({
              target: relatedTarget
            }, "dropdownOption") && !happensIn({
              target: relatedTarget
            }, "scrollbarRail")) {
              hoverKeyRef.value = null;
            }
          }
          function handleClick2() {
            const {
              value: hasSubmenu
            } = hasSubmenuRef;
            const {
              tmNode
            } = props;
            if (!mergedShowRef.value) return;
            if (!hasSubmenu && !tmNode.disabled) {
              NDropdown2.doSelect(tmNode.key, tmNode.rawNode);
              NDropdown2.doUpdateShow(false);
            }
          }
          return {
            labelField: labelFieldRef,
            renderLabel: renderLabelRef,
            renderIcon: renderIconRef,
            siblingHasIcon: NDropdownMenu2.showIconRef,
            siblingHasSubmenu: NDropdownMenu2.hasSubmenuRef,
            menuProps: menuPropsRef,
            popoverBody: NPopoverBody2,
            animated: animatedRef,
            mergedShowSubmenu: vue.computed(() => {
              return deferredShowSubmenuRef.value && !parentEnteringSubmenuRef.value;
            }),
            rawNode: rawNodeRef,
            hasSubmenu: hasSubmenuRef,
            pending: useMemo(() => {
              const {
                value: pendingKeyPath
              } = pendingKeyPathRef;
              const {
                key
              } = props.tmNode;
              return pendingKeyPath.includes(key);
            }),
            childActive: useMemo(() => {
              const {
                value: activeKeyPath
              } = activeKeyPathRef;
              const {
                key
              } = props.tmNode;
              const index = activeKeyPath.findIndex((k) => key === k);
              if (index === -1) return false;
              return index < activeKeyPath.length - 1;
            }),
            active: useMemo(() => {
              const {
                value: activeKeyPath
              } = activeKeyPathRef;
              const {
                key
              } = props.tmNode;
              const index = activeKeyPath.findIndex((k) => key === k);
              if (index === -1) return false;
              return index === activeKeyPath.length - 1;
            }),
            mergedDisabled: mergedDisabledRef,
            renderOption: renderOptionRef,
            nodeProps: nodePropsRef,
            handleClick: handleClick2,
            handleMouseMove,
            handleMouseEnter,
            handleMouseLeave,
            handleSubmenuBeforeEnter,
            handleSubmenuAfterEnter
          };
        },
        render() {
          var _a, _b;
          const {
            animated,
            rawNode,
            mergedShowSubmenu,
            clsPrefix,
            siblingHasIcon,
            siblingHasSubmenu,
            renderLabel,
            renderIcon,
            renderOption,
            nodeProps,
            props,
            scrollable
          } = this;
          let submenuVNode = null;
          if (mergedShowSubmenu) {
            const submenuNodeProps = (_a = this.menuProps) === null || _a === void 0 ? void 0 : _a.call(this, rawNode, rawNode.children);
            submenuVNode = vue.h(NDropdownMenu, Object.assign({}, submenuNodeProps, {
              clsPrefix,
              scrollable: this.scrollable,
              tmNodes: this.tmNode.children,
              parentKey: this.tmNode.key
            }));
          }
          const builtinProps = {
            class: [`${clsPrefix}-dropdown-option-body`, this.pending && `${clsPrefix}-dropdown-option-body--pending`, this.active && `${clsPrefix}-dropdown-option-body--active`, this.childActive && `${clsPrefix}-dropdown-option-body--child-active`, this.mergedDisabled && `${clsPrefix}-dropdown-option-body--disabled`],
            onMousemove: this.handleMouseMove,
            onMouseenter: this.handleMouseEnter,
            onMouseleave: this.handleMouseLeave,
            onClick: this.handleClick
          };
          const optionNodeProps = nodeProps === null || nodeProps === void 0 ? void 0 : nodeProps(rawNode);
          const node = vue.h("div", Object.assign({
            class: [`${clsPrefix}-dropdown-option`, optionNodeProps === null || optionNodeProps === void 0 ? void 0 : optionNodeProps.class],
            "data-dropdown-option": true
          }, optionNodeProps), vue.h("div", vue.mergeProps(builtinProps, props), [vue.h("div", {
            class: [`${clsPrefix}-dropdown-option-body__prefix`, siblingHasIcon && `${clsPrefix}-dropdown-option-body__prefix--show-icon`]
          }, [renderIcon ? renderIcon(rawNode) : render(rawNode.icon)]), vue.h("div", {
            "data-dropdown-option": true,
            class: `${clsPrefix}-dropdown-option-body__label`
          }, renderLabel ? renderLabel(rawNode) : render((_b = rawNode[this.labelField]) !== null && _b !== void 0 ? _b : rawNode.title)), vue.h("div", {
            "data-dropdown-option": true,
            class: [`${clsPrefix}-dropdown-option-body__suffix`, siblingHasSubmenu && `${clsPrefix}-dropdown-option-body__suffix--has-submenu`]
          }, this.hasSubmenu ? vue.h(NIcon, null, {
            default: () => vue.h(ChevronRightIcon, null)
          }) : null)]), this.hasSubmenu ? vue.h(Binder, null, {
            default: () => [vue.h(VTarget, null, {
              default: () => vue.h("div", {
                class: `${clsPrefix}-dropdown-offset-container`
              }, vue.h(VFollower, {
                show: this.mergedShowSubmenu,
                placement: this.placement,
                to: scrollable ? this.popoverBody || void 0 : void 0,
                teleportDisabled: !scrollable
              }, {
                default: () => {
                  return vue.h("div", {
                    class: `${clsPrefix}-dropdown-menu-wrapper`
                  }, animated ? vue.h(vue.Transition, {
                    onBeforeEnter: this.handleSubmenuBeforeEnter,
                    onAfterEnter: this.handleSubmenuAfterEnter,
                    name: "fade-in-scale-up-transition",
                    appear: true
                  }, {
                    default: () => submenuVNode
                  }) : submenuVNode);
                }
              }))
            })]
          }) : null);
          if (renderOption) {
            return renderOption({
              node,
              option: rawNode
            });
          }
          return node;
        }
      });
      const NDropdownGroup = vue.defineComponent({
        name: "NDropdownGroup",
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          tmNode: {
            type: Object,
            required: true
          },
          parentKey: {
            type: [String, Number],
            default: null
          }
        },
        render() {
          const {
            tmNode,
            parentKey,
            clsPrefix
          } = this;
          const {
            children
          } = tmNode;
          return vue.h(vue.Fragment, null, vue.h(NDropdownGroupHeader, {
            clsPrefix,
            tmNode,
            key: tmNode.key
          }), children === null || children === void 0 ? void 0 : children.map((child) => {
            const {
              rawNode
            } = child;
            if (rawNode.show === false) return null;
            if (isDividerNode(rawNode)) {
              return vue.h(NDropdownDivider, {
                clsPrefix,
                key: child.key
              });
            }
            if (child.isGroup) {
              warn("dropdown", "`group` node is not allowed to be put in `group` node.");
              return null;
            }
            return vue.h(NDropdownOption, {
              clsPrefix,
              tmNode: child,
              parentKey,
              key: child.key
            });
          }));
        }
      });
      const NDropdownRenderOption = vue.defineComponent({
        name: "DropdownRenderOption",
        props: {
          tmNode: {
            type: Object,
            required: true
          }
        },
        render() {
          const {
            rawNode: {
              render: render2,
              props
            }
          } = this.tmNode;
          return vue.h("div", props, [render2 === null || render2 === void 0 ? void 0 : render2()]);
        }
      });
      const NDropdownMenu = vue.defineComponent({
        name: "DropdownMenu",
        props: {
          scrollable: Boolean,
          showArrow: Boolean,
          arrowStyle: [String, Object],
          clsPrefix: {
            type: String,
            required: true
          },
          tmNodes: {
            type: Array,
            default: () => []
          },
          parentKey: {
            type: [String, Number],
            default: null
          }
        },
        setup(props) {
          const {
            renderIconRef,
            childrenFieldRef
          } = vue.inject(dropdownInjectionKey);
          vue.provide(dropdownMenuInjectionKey, {
            showIconRef: vue.computed(() => {
              const renderIcon = renderIconRef.value;
              return props.tmNodes.some((tmNode) => {
                var _a;
                if (tmNode.isGroup) {
                  return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({
                    rawNode: rawChild
                  }) => renderIcon ? renderIcon(rawChild) : rawChild.icon);
                }
                const {
                  rawNode
                } = tmNode;
                return renderIcon ? renderIcon(rawNode) : rawNode.icon;
              });
            }),
            hasSubmenuRef: vue.computed(() => {
              const {
                value: childrenField
              } = childrenFieldRef;
              return props.tmNodes.some((tmNode) => {
                var _a;
                if (tmNode.isGroup) {
                  return (_a = tmNode.children) === null || _a === void 0 ? void 0 : _a.some(({
                    rawNode: rawChild
                  }) => isSubmenuNode(rawChild, childrenField));
                }
                const {
                  rawNode
                } = tmNode;
                return isSubmenuNode(rawNode, childrenField);
              });
            })
          });
          const bodyRef = vue.ref(null);
          vue.provide(modalBodyInjectionKey, null);
          vue.provide(drawerBodyInjectionKey, null);
          vue.provide(popoverBodyInjectionKey, bodyRef);
          return {
            bodyRef
          };
        },
        render() {
          const {
            parentKey,
            clsPrefix,
            scrollable
          } = this;
          const menuOptionsNode = this.tmNodes.map((tmNode) => {
            const {
              rawNode
            } = tmNode;
            if (rawNode.show === false) return null;
            if (isRenderNode(rawNode)) {
              return vue.h(NDropdownRenderOption, {
                tmNode,
                key: tmNode.key
              });
            }
            if (isDividerNode(rawNode)) {
              return vue.h(NDropdownDivider, {
                clsPrefix,
                key: tmNode.key
              });
            }
            if (isGroupNode(rawNode)) {
              return vue.h(NDropdownGroup, {
                clsPrefix,
                tmNode,
                parentKey,
                key: tmNode.key
              });
            }
            return vue.h(NDropdownOption, {
              clsPrefix,
              tmNode,
              parentKey,
              key: tmNode.key,
              props: rawNode.props,
              scrollable
            });
          });
          return vue.h("div", {
            class: [`${clsPrefix}-dropdown-menu`, scrollable && `${clsPrefix}-dropdown-menu--scrollable`],
            ref: "bodyRef"
          }, scrollable ? vue.h(XScrollbar, {
            contentClass: `${clsPrefix}-dropdown-menu__content`
          }, {
            default: () => menuOptionsNode
          }) : menuOptionsNode, this.showArrow ? renderArrow({
            clsPrefix,
            arrowStyle: this.arrowStyle,
            arrowClass: void 0,
            arrowWrapperClass: void 0,
            arrowWrapperStyle: void 0
          }) : null);
        }
      });
      const style$b = cB("dropdown-menu", `
 transform-origin: var(--v-transform-origin);
 background-color: var(--n-color);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 position: relative;
 transition:
 background-color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
`, [fadeInScaleUpTransition(), cB("dropdown-option", `
 position: relative;
 `, [c$1("a", `
 text-decoration: none;
 color: inherit;
 outline: none;
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `)]), cB("dropdown-option-body", `
 display: flex;
 cursor: pointer;
 position: relative;
 height: var(--n-option-height);
 line-height: var(--n-option-height);
 font-size: var(--n-font-size);
 color: var(--n-option-text-color);
 transition: color .3s var(--n-bezier);
 `, [c$1("&::before", `
 content: "";
 position: absolute;
 top: 0;
 bottom: 0;
 left: 4px;
 right: 4px;
 transition: background-color .3s var(--n-bezier);
 border-radius: var(--n-border-radius);
 `), cNotM("disabled", [cM("pending", `
 color: var(--n-option-text-color-hover);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-hover);
 `), c$1("&::before", "background-color: var(--n-option-color-hover);")]), cM("active", `
 color: var(--n-option-text-color-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-active);
 `), c$1("&::before", "background-color: var(--n-option-color-active);")]), cM("child-active", `
 color: var(--n-option-text-color-child-active);
 `, [cE("prefix, suffix", `
 color: var(--n-option-text-color-child-active);
 `)])]), cM("disabled", `
 cursor: not-allowed;
 opacity: var(--n-option-opacity-disabled);
 `), cM("group", `
 font-size: calc(var(--n-font-size) - 1px);
 color: var(--n-group-header-text-color);
 `, [cE("prefix", `
 width: calc(var(--n-option-prefix-width) / 2);
 `, [cM("show-icon", `
 width: calc(var(--n-option-icon-prefix-width) / 2);
 `)])]), cE("prefix", `
 width: var(--n-option-prefix-width);
 display: flex;
 justify-content: center;
 align-items: center;
 color: var(--n-prefix-color);
 transition: color .3s var(--n-bezier);
 z-index: 1;
 `, [cM("show-icon", `
 width: var(--n-option-icon-prefix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cE("label", `
 white-space: nowrap;
 flex: 1;
 z-index: 1;
 `), cE("suffix", `
 box-sizing: border-box;
 flex-grow: 0;
 flex-shrink: 0;
 display: flex;
 justify-content: flex-end;
 align-items: center;
 min-width: var(--n-option-suffix-width);
 padding: 0 8px;
 transition: color .3s var(--n-bezier);
 color: var(--n-suffix-color);
 z-index: 1;
 `, [cM("has-submenu", `
 width: var(--n-option-icon-suffix-width);
 `), cB("icon", `
 font-size: var(--n-option-icon-size);
 `)]), cB("dropdown-menu", "pointer-events: all;")]), cB("dropdown-offset-container", `
 pointer-events: none;
 position: absolute;
 left: 0;
 right: 0;
 top: -4px;
 bottom: -4px;
 `)]), cB("dropdown-divider", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-divider-color);
 height: 1px;
 margin: 4px 0;
 `), cB("dropdown-menu-wrapper", `
 transform-origin: var(--v-transform-origin);
 width: fit-content;
 `), c$1(">", [cB("scrollbar", `
 height: inherit;
 max-height: inherit;
 `)]), cNotM("scrollable", `
 padding: var(--n-padding);
 `), cM("scrollable", [cE("content", `
 padding: var(--n-padding);
 `)])]);
      const dropdownBaseProps = {
        animated: {
          type: Boolean,
          default: true
        },
        keyboard: {
          type: Boolean,
          default: true
        },
        size: {
          type: String,
          default: "medium"
        },
        inverted: Boolean,
        placement: {
          type: String,
          default: "bottom"
        },
        onSelect: [Function, Array],
        options: {
          type: Array,
          default: () => []
        },
        menuProps: Function,
        showArrow: Boolean,
        renderLabel: Function,
        renderIcon: Function,
        renderOption: Function,
        nodeProps: Function,
        labelField: {
          type: String,
          default: "label"
        },
        keyField: {
          type: String,
          default: "key"
        },
        childrenField: {
          type: String,
          default: "children"
        },
value: [String, Number]
      };
      const popoverPropKeys = Object.keys(popoverBaseProps);
      const dropdownProps = Object.assign(Object.assign(Object.assign({}, popoverBaseProps), dropdownBaseProps), useTheme.props);
      const NDropdown = vue.defineComponent({
        name: "Dropdown",
        inheritAttrs: false,
        props: dropdownProps,
        setup(props) {
          const uncontrolledShowRef = vue.ref(false);
          const mergedShowRef = useMergedState(vue.toRef(props, "show"), uncontrolledShowRef);
          const treemateRef = vue.computed(() => {
            const {
              keyField,
              childrenField
            } = props;
            return createTreeMate(props.options, {
              getKey(node) {
                return node[keyField];
              },
              getDisabled(node) {
                return node.disabled === true;
              },
              getIgnored(node) {
                return node.type === "divider" || node.type === "render";
              },
              getChildren(node) {
                return node[childrenField];
              }
            });
          });
          const tmNodesRef = vue.computed(() => {
            return treemateRef.value.treeNodes;
          });
          const hoverKeyRef = vue.ref(null);
          const keyboardKeyRef = vue.ref(null);
          const lastToggledSubmenuKeyRef = vue.ref(null);
          const pendingKeyRef = vue.computed(() => {
            var _a, _b, _c;
            return (_c = (_b = (_a = hoverKeyRef.value) !== null && _a !== void 0 ? _a : keyboardKeyRef.value) !== null && _b !== void 0 ? _b : lastToggledSubmenuKeyRef.value) !== null && _c !== void 0 ? _c : null;
          });
          const pendingKeyPathRef = vue.computed(() => treemateRef.value.getPath(pendingKeyRef.value).keyPath);
          const activeKeyPathRef = vue.computed(() => treemateRef.value.getPath(props.value).keyPath);
          const keyboardEnabledRef = useMemo(() => {
            return props.keyboard && mergedShowRef.value;
          });
          useKeyboard({
            keydown: {
              ArrowUp: {
                prevent: true,
                handler: handleKeydownUp
              },
              ArrowRight: {
                prevent: true,
                handler: handleKeydownRight
              },
              ArrowDown: {
                prevent: true,
                handler: handleKeydownDown
              },
              ArrowLeft: {
                prevent: true,
                handler: handleKeydownLeft
              },
              Enter: {
                prevent: true,
                handler: handleKeydownEnter
              },
              Escape: handleKeydownEsc
            }
          }, keyboardEnabledRef);
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled
          } = useConfig(props);
          const themeRef = useTheme("Dropdown", "-dropdown", style$b, dropdownLight, props, mergedClsPrefixRef);
          vue.provide(dropdownInjectionKey, {
            labelFieldRef: vue.toRef(props, "labelField"),
            childrenFieldRef: vue.toRef(props, "childrenField"),
            renderLabelRef: vue.toRef(props, "renderLabel"),
            renderIconRef: vue.toRef(props, "renderIcon"),
            hoverKeyRef,
            keyboardKeyRef,
            lastToggledSubmenuKeyRef,
            pendingKeyPathRef,
            activeKeyPathRef,
            animatedRef: vue.toRef(props, "animated"),
            mergedShowRef,
            nodePropsRef: vue.toRef(props, "nodeProps"),
            renderOptionRef: vue.toRef(props, "renderOption"),
            menuPropsRef: vue.toRef(props, "menuProps"),
            doSelect,
            doUpdateShow
          });
          vue.watch(mergedShowRef, (value) => {
            if (!props.animated && !value) {
              clearPendingState();
            }
          });
          function doSelect(key, node) {
            const {
              onSelect
            } = props;
            if (onSelect) call(onSelect, key, node);
          }
          function doUpdateShow(value) {
            const {
              "onUpdate:show": _onUpdateShow,
              onUpdateShow
            } = props;
            if (_onUpdateShow) call(_onUpdateShow, value);
            if (onUpdateShow) call(onUpdateShow, value);
            uncontrolledShowRef.value = value;
          }
          function clearPendingState() {
            hoverKeyRef.value = null;
            keyboardKeyRef.value = null;
            lastToggledSubmenuKeyRef.value = null;
          }
          function handleKeydownEsc() {
            doUpdateShow(false);
          }
          function handleKeydownLeft() {
            handleKeydown("left");
          }
          function handleKeydownRight() {
            handleKeydown("right");
          }
          function handleKeydownUp() {
            handleKeydown("up");
          }
          function handleKeydownDown() {
            handleKeydown("down");
          }
          function handleKeydownEnter() {
            const pendingNode = getPendingNode();
            if ((pendingNode === null || pendingNode === void 0 ? void 0 : pendingNode.isLeaf) && mergedShowRef.value) {
              doSelect(pendingNode.key, pendingNode.rawNode);
              doUpdateShow(false);
            }
          }
          function getPendingNode() {
            var _a;
            const {
              value: treeMate
            } = treemateRef;
            const {
              value: pendingKey
            } = pendingKeyRef;
            if (!treeMate || pendingKey === null) return null;
            return (_a = treeMate.getNode(pendingKey)) !== null && _a !== void 0 ? _a : null;
          }
          function handleKeydown(direction) {
            const {
              value: pendingKey
            } = pendingKeyRef;
            const {
              value: {
                getFirstAvailableNode: getFirstAvailableNode2
              }
            } = treemateRef;
            let nextKeyboardKey = null;
            if (pendingKey === null) {
              const firstNode = getFirstAvailableNode2();
              if (firstNode !== null) {
                nextKeyboardKey = firstNode.key;
              }
            } else {
              const currentNode = getPendingNode();
              if (currentNode) {
                let nextNode;
                switch (direction) {
                  case "down":
                    nextNode = currentNode.getNext();
                    break;
                  case "up":
                    nextNode = currentNode.getPrev();
                    break;
                  case "right":
                    nextNode = currentNode.getChild();
                    break;
                  case "left":
                    nextNode = currentNode.getParent();
                    break;
                }
                if (nextNode) nextKeyboardKey = nextNode.key;
              }
            }
            if (nextKeyboardKey !== null) {
              hoverKeyRef.value = null;
              keyboardKeyRef.value = nextKeyboardKey;
            }
          }
          const cssVarsRef = vue.computed(() => {
            const {
              size: size2,
              inverted
            } = props;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: self2
            } = themeRef.value;
            const {
              padding,
              dividerColor,
              borderRadius,
              optionOpacityDisabled,
              [createKey("optionIconSuffixWidth", size2)]: optionIconSuffixWidth,
              [createKey("optionSuffixWidth", size2)]: optionSuffixWidth,
              [createKey("optionIconPrefixWidth", size2)]: optionIconPrefixWidth,
              [createKey("optionPrefixWidth", size2)]: optionPrefixWidth,
              [createKey("fontSize", size2)]: fontSize2,
              [createKey("optionHeight", size2)]: optionHeight,
              [createKey("optionIconSize", size2)]: optionIconSize
            } = self2;
            const vars = {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": fontSize2,
              "--n-padding": padding,
              "--n-border-radius": borderRadius,
              "--n-option-height": optionHeight,
              "--n-option-prefix-width": optionPrefixWidth,
              "--n-option-icon-prefix-width": optionIconPrefixWidth,
              "--n-option-suffix-width": optionSuffixWidth,
              "--n-option-icon-suffix-width": optionIconSuffixWidth,
              "--n-option-icon-size": optionIconSize,
              "--n-divider-color": dividerColor,
              "--n-option-opacity-disabled": optionOpacityDisabled
            };
            if (inverted) {
              vars["--n-color"] = self2.colorInverted;
              vars["--n-option-color-hover"] = self2.optionColorHoverInverted;
              vars["--n-option-color-active"] = self2.optionColorActiveInverted;
              vars["--n-option-text-color"] = self2.optionTextColorInverted;
              vars["--n-option-text-color-hover"] = self2.optionTextColorHoverInverted;
              vars["--n-option-text-color-active"] = self2.optionTextColorActiveInverted;
              vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActiveInverted;
              vars["--n-prefix-color"] = self2.prefixColorInverted;
              vars["--n-suffix-color"] = self2.suffixColorInverted;
              vars["--n-group-header-text-color"] = self2.groupHeaderTextColorInverted;
            } else {
              vars["--n-color"] = self2.color;
              vars["--n-option-color-hover"] = self2.optionColorHover;
              vars["--n-option-color-active"] = self2.optionColorActive;
              vars["--n-option-text-color"] = self2.optionTextColor;
              vars["--n-option-text-color-hover"] = self2.optionTextColorHover;
              vars["--n-option-text-color-active"] = self2.optionTextColorActive;
              vars["--n-option-text-color-child-active"] = self2.optionTextColorChildActive;
              vars["--n-prefix-color"] = self2.prefixColor;
              vars["--n-suffix-color"] = self2.suffixColor;
              vars["--n-group-header-text-color"] = self2.groupHeaderTextColor;
            }
            return vars;
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("dropdown", vue.computed(() => `${props.size[0]}${props.inverted ? "i" : ""}`), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: themeRef,
tmNodes: tmNodesRef,
mergedShow: mergedShowRef,
handleAfterLeave: () => {
              if (!props.animated) return;
              clearPendingState();
            },
            doUpdateShow,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const renderPopoverBody = (className, ref2, style2, onMouseenter, onMouseleave) => {
            var _a;
            const {
              mergedClsPrefix,
              menuProps
            } = this;
            (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
            const menuNodeProps = (menuProps === null || menuProps === void 0 ? void 0 : menuProps(void 0, this.tmNodes.map((v) => v.rawNode))) || {};
            const dropdownProps2 = {
              ref: createRefSetter(ref2),
              class: [className, `${mergedClsPrefix}-dropdown`, this.themeClass],
              clsPrefix: mergedClsPrefix,
              tmNodes: this.tmNodes,
              style: [...style2, this.cssVars],
              showArrow: this.showArrow,
              arrowStyle: this.arrowStyle,
              scrollable: this.scrollable,
              onMouseenter,
              onMouseleave
            };
            return vue.h(NDropdownMenu, vue.mergeProps(this.$attrs, dropdownProps2, menuNodeProps));
          };
          const {
            mergedTheme
          } = this;
          const popoverProps2 = {
            show: this.mergedShow,
            theme: mergedTheme.peers.Popover,
            themeOverrides: mergedTheme.peerOverrides.Popover,
            internalOnAfterLeave: this.handleAfterLeave,
            internalRenderBody: renderPopoverBody,
            onUpdateShow: this.doUpdateShow,
            "onUpdate:show": void 0
          };
          return vue.h(NPopover, Object.assign({}, keep(this.$props, popoverPropKeys), popoverProps2), {
            trigger: () => {
              var _a, _b;
              return (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a);
            }
          });
        }
      });
      const allKey = "_n_all__";
      const noneKey = "_n_none__";
      function createSelectHandler(options, rawPaginatedDataRef, doCheckAll, doUncheckAll) {
        if (!options) return () => {
        };
        return (key) => {
          for (const option of options) {
            switch (key) {
              case allKey:
                doCheckAll(true);
                return;
              case noneKey:
                doUncheckAll(true);
                return;
              default:
                if (typeof option === "object" && option.key === key) {
                  option.onSelect(rawPaginatedDataRef.value);
                  return;
                }
            }
          }
        };
      }
      function createDropdownOptions(options, localeRef) {
        if (!options) return [];
        return options.map((option) => {
          switch (option) {
            case "all":
              return {
                label: localeRef.checkTableAll,
                key: allKey
              };
            case "none":
              return {
                label: localeRef.uncheckTableAll,
                key: noneKey
              };
            default:
              return option;
          }
        });
      }
      const SelectionMenu = vue.defineComponent({
        name: "DataTableSelectionMenu",
        props: {
          clsPrefix: {
            type: String,
            required: true
          }
        },
        setup(props) {
          const {
            props: dataTableProps2,
            localeRef,
            checkOptionsRef,
            rawPaginatedDataRef,
            doCheckAll,
            doUncheckAll
          } = vue.inject(dataTableInjectionKey);
          const handleSelectRef = vue.computed(() => createSelectHandler(checkOptionsRef.value, rawPaginatedDataRef, doCheckAll, doUncheckAll));
          const optionsRef = vue.computed(() => createDropdownOptions(checkOptionsRef.value, localeRef.value));
          return () => {
            var _a, _b, _c, _d;
            const {
              clsPrefix
            } = props;
            return vue.h(NDropdown, {
              theme: (_b = (_a = dataTableProps2.theme) === null || _a === void 0 ? void 0 : _a.peers) === null || _b === void 0 ? void 0 : _b.Dropdown,
              themeOverrides: (_d = (_c = dataTableProps2.themeOverrides) === null || _c === void 0 ? void 0 : _c.peers) === null || _d === void 0 ? void 0 : _d.Dropdown,
              options: optionsRef.value,
              onSelect: handleSelectRef.value
            }, {
              default: () => vue.h(NBaseIcon, {
                clsPrefix,
                class: `${clsPrefix}-data-table-check-extra`
              }, {
                default: () => vue.h(ChevronDownIcon, null)
              })
            });
          };
        }
      });
      function renderTitle(column) {
        return typeof column.title === "function" ? column.title(column) : column.title;
      }
      const VirtualListItemWrapper$1 = vue.defineComponent({
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          id: {
            type: String,
            required: true
          },
          cols: {
            type: Array,
            required: true
          },
          width: String
        },
        render() {
          const {
            clsPrefix,
            id,
            cols,
            width
          } = this;
          return vue.h("table", {
            style: {
              tableLayout: "fixed",
              width
            },
            class: `${clsPrefix}-data-table-table`
          }, vue.h("colgroup", null, cols.map((col) => vue.h("col", {
            key: col.key,
            style: col.style
          }))), vue.h("thead", {
            "data-n-id": id,
            class: `${clsPrefix}-data-table-thead`
          }, this.$slots));
        }
      });
      const TableHeader = vue.defineComponent({
        name: "DataTableHeader",
        props: {
          discrete: {
            type: Boolean,
            default: true
          }
        },
        setup() {
          const {
            mergedClsPrefixRef,
            scrollXRef,
            fixedColumnLeftMapRef,
            fixedColumnRightMapRef,
            mergedCurrentPageRef,
            allRowsCheckedRef,
            someRowsCheckedRef,
            rowsRef,
            colsRef,
            mergedThemeRef,
            checkOptionsRef,
            mergedSortStateRef,
            componentId,
            mergedTableLayoutRef,
            headerCheckboxDisabledRef,
            virtualScrollHeaderRef,
            headerHeightRef,
            onUnstableColumnResize,
            doUpdateResizableWidth,
            handleTableHeaderScroll,
            deriveNextSorter,
            doUncheckAll,
            doCheckAll
          } = vue.inject(dataTableInjectionKey);
          const virtualListRef = vue.ref();
          const cellElsRef = vue.ref({});
          function getCellActualWidth(key) {
            const element = cellElsRef.value[key];
            return element === null || element === void 0 ? void 0 : element.getBoundingClientRect().width;
          }
          function handleCheckboxUpdateChecked() {
            if (allRowsCheckedRef.value) {
              doUncheckAll();
            } else {
              doCheckAll();
            }
          }
          function handleColHeaderClick(e, column) {
            if (happensIn(e, "dataTableFilter") || happensIn(e, "dataTableResizable")) {
              return;
            }
            if (!isColumnSortable(column)) return;
            const activeSorter = mergedSortStateRef.value.find((state) => state.columnKey === column.key) || null;
            const nextSorter = createNextSorter(column, activeSorter);
            deriveNextSorter(nextSorter);
          }
          const resizeStartWidthMap = new Map();
          function handleColumnResizeStart(column) {
            resizeStartWidthMap.set(column.key, getCellActualWidth(column.key));
          }
          function handleColumnResize(column, displacementX) {
            const startWidth = resizeStartWidthMap.get(column.key);
            if (startWidth === void 0) {
              return;
            }
            const widthAfterResize = startWidth + displacementX;
            const limitWidth = clampValueFollowCSSRules(widthAfterResize, column.minWidth, column.maxWidth);
            onUnstableColumnResize(widthAfterResize, limitWidth, column, getCellActualWidth);
            doUpdateResizableWidth(column, limitWidth);
          }
          return {
            cellElsRef,
            componentId,
            mergedSortState: mergedSortStateRef,
            mergedClsPrefix: mergedClsPrefixRef,
            scrollX: scrollXRef,
            fixedColumnLeftMap: fixedColumnLeftMapRef,
            fixedColumnRightMap: fixedColumnRightMapRef,
            currentPage: mergedCurrentPageRef,
            allRowsChecked: allRowsCheckedRef,
            someRowsChecked: someRowsCheckedRef,
            rows: rowsRef,
            cols: colsRef,
            mergedTheme: mergedThemeRef,
            checkOptions: checkOptionsRef,
            mergedTableLayout: mergedTableLayoutRef,
            headerCheckboxDisabled: headerCheckboxDisabledRef,
            headerHeight: headerHeightRef,
            virtualScrollHeader: virtualScrollHeaderRef,
            virtualListRef,
            handleCheckboxUpdateChecked,
            handleColHeaderClick,
            handleTableHeaderScroll,
            handleColumnResizeStart,
            handleColumnResize
          };
        },
        render() {
          const {
            cellElsRef,
            mergedClsPrefix,
            fixedColumnLeftMap,
            fixedColumnRightMap,
            currentPage,
            allRowsChecked,
            someRowsChecked,
            rows,
            cols,
            mergedTheme,
            checkOptions,
            componentId,
            discrete,
            mergedTableLayout,
            headerCheckboxDisabled,
            mergedSortState,
            virtualScrollHeader,
            handleColHeaderClick,
            handleCheckboxUpdateChecked,
            handleColumnResizeStart,
            handleColumnResize
          } = this;
          const renderRow = (row, getLeft, headerHeightPx) => row.map(({
            column,
            colIndex,
            colSpan,
            rowSpan,
            isLast
          }) => {
            var _a, _b;
            const key = getColKey(column);
            const {
              ellipsis
            } = column;
            const createColumnVNode = () => {
              if (column.type === "selection") {
                return column.multiple !== false ? vue.h(vue.Fragment, null, vue.h(NCheckbox, {
                  key: currentPage,
                  privateInsideTable: true,
                  checked: allRowsChecked,
                  indeterminate: someRowsChecked,
                  disabled: headerCheckboxDisabled,
                  onUpdateChecked: handleCheckboxUpdateChecked
                }), checkOptions ? vue.h(SelectionMenu, {
                  clsPrefix: mergedClsPrefix
                }) : null) : null;
              }
              return vue.h(vue.Fragment, null, vue.h("div", {
                class: `${mergedClsPrefix}-data-table-th__title-wrapper`
              }, vue.h("div", {
                class: `${mergedClsPrefix}-data-table-th__title`
              }, ellipsis === true || ellipsis && !ellipsis.tooltip ? vue.h("div", {
                class: `${mergedClsPrefix}-data-table-th__ellipsis`
              }, renderTitle(column)) : ellipsis && typeof ellipsis === "object" ? vue.h(NEllipsis, Object.assign({}, ellipsis, {
                theme: mergedTheme.peers.Ellipsis,
                themeOverrides: mergedTheme.peerOverrides.Ellipsis
              }), {
                default: () => renderTitle(column)
              }) : renderTitle(column)), isColumnSortable(column) ? vue.h(SortButton, {
                column
              }) : null), isColumnFilterable(column) ? vue.h(FilterButton, {
                column,
                options: column.filterOptions
              }) : null, isColumnResizable(column) ? vue.h(ResizeButton, {
                onResizeStart: () => {
                  handleColumnResizeStart(column);
                },
                onResize: (displacementX) => {
                  handleColumnResize(column, displacementX);
                }
              }) : null);
            };
            const leftFixed = key in fixedColumnLeftMap;
            const rightFixed = key in fixedColumnRightMap;
            const CellComponent = getLeft && !column.fixed ? "div" : "th";
            return vue.h(CellComponent, {
              ref: (el) => cellElsRef[key] = el,
              key,
              style: [getLeft && !column.fixed ? {
                position: "absolute",
                left: pxfy(getLeft(colIndex)),
                top: 0,
                bottom: 0
              } : {
                left: pxfy((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start),
                right: pxfy((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.start)
              }, {
                width: pxfy(column.width),
                textAlign: column.titleAlign || column.align,
                height: headerHeightPx
              }],
              colspan: colSpan,
              rowspan: rowSpan,
              "data-col-key": key,
              class: [`${mergedClsPrefix}-data-table-th`, (leftFixed || rightFixed) && `${mergedClsPrefix}-data-table-th--fixed-${leftFixed ? "left" : "right"}`, {
                [`${mergedClsPrefix}-data-table-th--sorting`]: isColumnSorting(column, mergedSortState),
                [`${mergedClsPrefix}-data-table-th--filterable`]: isColumnFilterable(column),
                [`${mergedClsPrefix}-data-table-th--sortable`]: isColumnSortable(column),
                [`${mergedClsPrefix}-data-table-th--selection`]: column.type === "selection",
                [`${mergedClsPrefix}-data-table-th--last`]: isLast
              }, column.className],
              onClick: column.type !== "selection" && column.type !== "expand" && !("children" in column) ? (e) => {
                handleColHeaderClick(e, column);
              } : void 0
            }, createColumnVNode());
          });
          if (virtualScrollHeader) {
            const {
              headerHeight
            } = this;
            let leftFixedColsCount = 0;
            let rightFixedColsCount = 0;
            cols.forEach((col) => {
              if (col.column.fixed === "left") {
                leftFixedColsCount++;
              } else if (col.column.fixed === "right") {
                rightFixedColsCount++;
              }
            });
            return vue.h(VVirtualList, {
              ref: "virtualListRef",
              class: `${mergedClsPrefix}-data-table-base-table-header`,
              style: {
                height: pxfy(headerHeight)
              },
              onScroll: this.handleTableHeaderScroll,
              columns: cols,
              itemSize: headerHeight,
              showScrollbar: false,
              items: [{}],
              itemResizable: false,
              visibleItemsTag: VirtualListItemWrapper$1,
              visibleItemsProps: {
                clsPrefix: mergedClsPrefix,
                id: componentId,
                cols,
                width: formatLength(this.scrollX)
              },
              renderItemWithCols: ({
                startColIndex,
                endColIndex,
                getLeft
              }) => {
                const row = cols.map((col, index) => {
                  return {
                    column: col.column,
                    isLast: index === cols.length - 1,
                    colIndex: col.index,
                    colSpan: 1,
                    rowSpan: 1
                  };
                }).filter(({
                  column
                }, index) => {
                  if (startColIndex <= index && index <= endColIndex) {
                    return true;
                  }
                  if (column.fixed) {
                    return true;
                  }
                  return false;
                });
                const cells = renderRow(row, getLeft, pxfy(headerHeight));
                cells.splice(leftFixedColsCount, 0, vue.h("th", {
                  colspan: cols.length - leftFixedColsCount - rightFixedColsCount,
                  style: {
                    pointerEvents: "none",
                    visibility: "hidden",
                    height: 0
                  }
                }));
                return vue.h("tr", {
                  style: {
                    position: "relative"
                  }
                }, cells);
              }
            }, {
              default: ({
                renderedItemWithCols
              }) => renderedItemWithCols
            });
          }
          const theadVNode = vue.h("thead", {
            class: `${mergedClsPrefix}-data-table-thead`,
            "data-n-id": componentId
          }, rows.map((row) => {
            return vue.h("tr", {
              class: `${mergedClsPrefix}-data-table-tr`
            }, renderRow(row, null, void 0));
          }));
          if (!discrete) {
            return theadVNode;
          }
          const {
            handleTableHeaderScroll,
            scrollX
          } = this;
          return vue.h("div", {
            class: `${mergedClsPrefix}-data-table-base-table-header`,
            onScroll: handleTableHeaderScroll
          }, vue.h("table", {
            class: `${mergedClsPrefix}-data-table-table`,
            style: {
              minWidth: formatLength(scrollX),
              tableLayout: mergedTableLayout
            }
          }, vue.h("colgroup", null, cols.map((col) => vue.h("col", {
            key: col.key,
            style: col.style
          }))), theadVNode));
        }
      });
      function flatten(rowInfos, expandedRowKeys) {
        const fRows = [];
        function traverse(rs, rootIndex) {
          rs.forEach((r) => {
            if (r.children && expandedRowKeys.has(r.key)) {
              fRows.push({
                tmNode: r,
                striped: false,
                key: r.key,
                index: rootIndex
              });
              traverse(r.children, rootIndex);
            } else {
              fRows.push({
                key: r.key,
                tmNode: r,
                striped: false,
                index: rootIndex
              });
            }
          });
        }
        rowInfos.forEach((rowInfo) => {
          fRows.push(rowInfo);
          const {
            children
          } = rowInfo.tmNode;
          if (children && expandedRowKeys.has(rowInfo.key)) {
            traverse(children, rowInfo.index);
          }
        });
        return fRows;
      }
      const VirtualListItemWrapper = vue.defineComponent({
        props: {
          clsPrefix: {
            type: String,
            required: true
          },
          id: {
            type: String,
            required: true
          },
          cols: {
            type: Array,
            required: true
          },
          onMouseenter: Function,
          onMouseleave: Function
        },
        render() {
          const {
            clsPrefix,
            id,
            cols,
            onMouseenter,
            onMouseleave
          } = this;
          return vue.h("table", {
            style: {
              tableLayout: "fixed"
            },
            class: `${clsPrefix}-data-table-table`,
            onMouseenter,
            onMouseleave
          }, vue.h("colgroup", null, cols.map((col) => vue.h("col", {
            key: col.key,
            style: col.style
          }))), vue.h("tbody", {
            "data-n-id": id,
            class: `${clsPrefix}-data-table-tbody`
          }, this.$slots));
        }
      });
      const TableBody = vue.defineComponent({
        name: "DataTableBody",
        props: {
          onResize: Function,
          showHeader: Boolean,
          flexHeight: Boolean,
          bodyStyle: Object
        },
        setup(props) {
          const {
            slots: dataTableSlots,
            bodyWidthRef,
            mergedExpandedRowKeysRef,
            mergedClsPrefixRef,
            mergedThemeRef,
            scrollXRef,
            colsRef,
            paginatedDataRef,
            rawPaginatedDataRef,
            fixedColumnLeftMapRef,
            fixedColumnRightMapRef,
            mergedCurrentPageRef,
            rowClassNameRef,
            leftActiveFixedColKeyRef,
            leftActiveFixedChildrenColKeysRef,
            rightActiveFixedColKeyRef,
            rightActiveFixedChildrenColKeysRef,
            renderExpandRef,
            hoverKeyRef,
            summaryRef,
            mergedSortStateRef,
            virtualScrollRef,
            virtualScrollXRef,
            heightForRowRef,
            minRowHeightRef,
            componentId,
            mergedTableLayoutRef,
            childTriggerColIndexRef,
            indentRef,
            rowPropsRef,
            maxHeightRef,
            stripedRef,
            loadingRef,
            onLoadRef,
            loadingKeySetRef,
            expandableRef,
            stickyExpandedRowsRef,
            renderExpandIconRef,
            summaryPlacementRef,
            treeMateRef,
            scrollbarPropsRef,
            setHeaderScrollLeft,
            doUpdateExpandedRowKeys,
            handleTableBodyScroll,
            doCheck,
            doUncheck,
            renderCell
          } = vue.inject(dataTableInjectionKey);
          const NConfigProvider2 = vue.inject(configProviderInjectionKey);
          const scrollbarInstRef = vue.ref(null);
          const virtualListRef = vue.ref(null);
          const emptyElRef = vue.ref(null);
          const emptyRef = useMemo(() => paginatedDataRef.value.length === 0);
          const shouldDisplaySomeTablePartRef = useMemo(() => props.showHeader || !emptyRef.value);
          const bodyShowHeaderOnlyRef = useMemo(() => {
            return props.showHeader || emptyRef.value;
          });
          let lastSelectedKey = "";
          const mergedExpandedRowKeySetRef = vue.computed(() => {
            return new Set(mergedExpandedRowKeysRef.value);
          });
          function getRowInfo(key) {
            var _a;
            return (_a = treeMateRef.value.getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
          }
          function handleCheckboxUpdateChecked(tmNode, checked, shiftKey) {
            const rowInfo = getRowInfo(tmNode.key);
            if (!rowInfo) {
              warn("data-table", `fail to get row data with key ${tmNode.key}`);
              return;
            }
            if (shiftKey) {
              const lastIndex = paginatedDataRef.value.findIndex((item) => item.key === lastSelectedKey);
              if (lastIndex !== -1) {
                const currentIndex = paginatedDataRef.value.findIndex((item) => item.key === tmNode.key);
                const start = Math.min(lastIndex, currentIndex);
                const end = Math.max(lastIndex, currentIndex);
                const rowKeysToCheck = [];
                paginatedDataRef.value.slice(start, end + 1).forEach((r) => {
                  if (!r.disabled) {
                    rowKeysToCheck.push(r.key);
                  }
                });
                if (checked) {
                  doCheck(rowKeysToCheck, false, rowInfo);
                } else {
                  doUncheck(rowKeysToCheck, rowInfo);
                }
                lastSelectedKey = tmNode.key;
                return;
              }
            }
            if (checked) {
              doCheck(tmNode.key, false, rowInfo);
            } else {
              doUncheck(tmNode.key, rowInfo);
            }
            lastSelectedKey = tmNode.key;
          }
          function handleRadioUpdateChecked(tmNode) {
            const rowInfo = getRowInfo(tmNode.key);
            if (!rowInfo) {
              warn("data-table", `fail to get row data with key ${tmNode.key}`);
              return;
            }
            doCheck(tmNode.key, true, rowInfo);
          }
          function getScrollContainer() {
            if (!shouldDisplaySomeTablePartRef.value) {
              const {
                value: emptyEl
              } = emptyElRef;
              if (emptyEl) {
                return emptyEl;
              } else {
                return null;
              }
            }
            if (virtualScrollRef.value) {
              return virtualListContainer();
            }
            const {
              value
            } = scrollbarInstRef;
            if (value) return value.containerRef;
            return null;
          }
          function handleUpdateExpanded(key, tmNode) {
            var _a;
            if (loadingKeySetRef.value.has(key)) return;
            const {
              value: mergedExpandedRowKeys
            } = mergedExpandedRowKeysRef;
            const index = mergedExpandedRowKeys.indexOf(key);
            const nextExpandedKeys = Array.from(mergedExpandedRowKeys);
            if (~index) {
              nextExpandedKeys.splice(index, 1);
              doUpdateExpandedRowKeys(nextExpandedKeys);
            } else {
              if (tmNode && !tmNode.isLeaf && !tmNode.shallowLoaded) {
                loadingKeySetRef.value.add(key);
                void ((_a = onLoadRef.value) === null || _a === void 0 ? void 0 : _a.call(onLoadRef, tmNode.rawNode).then(() => {
                  const {
                    value: futureMergedExpandedRowKeys
                  } = mergedExpandedRowKeysRef;
                  const futureNextExpandedKeys = Array.from(futureMergedExpandedRowKeys);
                  const index2 = futureNextExpandedKeys.indexOf(key);
                  if (!~index2) {
                    futureNextExpandedKeys.push(key);
                  }
                  doUpdateExpandedRowKeys(futureNextExpandedKeys);
                }).finally(() => {
                  loadingKeySetRef.value.delete(key);
                }));
              } else {
                nextExpandedKeys.push(key);
                doUpdateExpandedRowKeys(nextExpandedKeys);
              }
            }
          }
          function handleMouseleaveTable() {
            hoverKeyRef.value = null;
          }
          function virtualListContainer() {
            const {
              value
            } = virtualListRef;
            return (value === null || value === void 0 ? void 0 : value.listElRef) || null;
          }
          function virtualListContent() {
            const {
              value
            } = virtualListRef;
            return (value === null || value === void 0 ? void 0 : value.itemsElRef) || null;
          }
          function handleVirtualListScroll(e) {
            var _a;
            handleTableBodyScroll(e);
            (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          function handleVirtualListResize(e) {
            var _a;
            const {
              onResize
            } = props;
            if (onResize) onResize(e);
            (_a = scrollbarInstRef.value) === null || _a === void 0 ? void 0 : _a.sync();
          }
          const exposedMethods = {
            getScrollContainer,
            scrollTo(arg0, arg1) {
              var _a, _b;
              if (virtualScrollRef.value) {
                (_a = virtualListRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
              } else {
                (_b = scrollbarInstRef.value) === null || _b === void 0 ? void 0 : _b.scrollTo(arg0, arg1);
              }
            }
          };
          const style2 = c$1([({
            props: cProps
          }) => {
            const createActiveLeftFixedStyle = (leftActiveFixedColKey) => {
              if (leftActiveFixedColKey === null) return null;
              return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${leftActiveFixedColKey}"]::after`, {
                boxShadow: "var(--n-box-shadow-after)"
              });
            };
            const createActiveRightFixedStyle = (rightActiveFixedColKey) => {
              if (rightActiveFixedColKey === null) return null;
              return c$1(`[data-n-id="${cProps.componentId}"] [data-col-key="${rightActiveFixedColKey}"]::before`, {
                boxShadow: "var(--n-box-shadow-before)"
              });
            };
            return c$1([createActiveLeftFixedStyle(cProps.leftActiveFixedColKey), createActiveRightFixedStyle(cProps.rightActiveFixedColKey), cProps.leftActiveFixedChildrenColKeys.map((leftActiveFixedColKey) => createActiveLeftFixedStyle(leftActiveFixedColKey)), cProps.rightActiveFixedChildrenColKeys.map((rightActiveFixedColKey) => createActiveRightFixedStyle(rightActiveFixedColKey))]);
          }]);
          let fixedStyleMounted = false;
          vue.watchEffect(() => {
            const {
              value: leftActiveFixedColKey
            } = leftActiveFixedColKeyRef;
            const {
              value: leftActiveFixedChildrenColKeys
            } = leftActiveFixedChildrenColKeysRef;
            const {
              value: rightActiveFixedColKey
            } = rightActiveFixedColKeyRef;
            const {
              value: rightActiveFixedChildrenColKeys
            } = rightActiveFixedChildrenColKeysRef;
            if (!fixedStyleMounted && leftActiveFixedColKey === null && rightActiveFixedColKey === null) {
              return;
            }
            const cProps = {
              leftActiveFixedColKey,
              leftActiveFixedChildrenColKeys,
              rightActiveFixedColKey,
              rightActiveFixedChildrenColKeys,
              componentId
            };
            style2.mount({
              id: `n-${componentId}`,
              force: true,
              props: cProps,
              anchorMetaName: cssrAnchorMetaName,
              parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
            });
            fixedStyleMounted = true;
          });
          vue.onUnmounted(() => {
            style2.unmount({
              id: `n-${componentId}`,
              parent: NConfigProvider2 === null || NConfigProvider2 === void 0 ? void 0 : NConfigProvider2.styleMountTarget
            });
          });
          return Object.assign({
            bodyWidth: bodyWidthRef,
            summaryPlacement: summaryPlacementRef,
            dataTableSlots,
            componentId,
            scrollbarInstRef,
            virtualListRef,
            emptyElRef,
            summary: summaryRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedTheme: mergedThemeRef,
            scrollX: scrollXRef,
            cols: colsRef,
            loading: loadingRef,
            bodyShowHeaderOnly: bodyShowHeaderOnlyRef,
            shouldDisplaySomeTablePart: shouldDisplaySomeTablePartRef,
            empty: emptyRef,
            paginatedDataAndInfo: vue.computed(() => {
              const {
                value: striped
              } = stripedRef;
              let hasChildren = false;
              const data = paginatedDataRef.value.map(striped ? (tmNode, index) => {
                if (!tmNode.isLeaf) hasChildren = true;
                return {
                  tmNode,
                  key: tmNode.key,
                  striped: index % 2 === 1,
                  index
                };
              } : (tmNode, index) => {
                if (!tmNode.isLeaf) hasChildren = true;
                return {
                  tmNode,
                  key: tmNode.key,
                  striped: false,
                  index
                };
              });
              return {
                data,
                hasChildren
              };
            }),
            rawPaginatedData: rawPaginatedDataRef,
            fixedColumnLeftMap: fixedColumnLeftMapRef,
            fixedColumnRightMap: fixedColumnRightMapRef,
            currentPage: mergedCurrentPageRef,
            rowClassName: rowClassNameRef,
            renderExpand: renderExpandRef,
            mergedExpandedRowKeySet: mergedExpandedRowKeySetRef,
            hoverKey: hoverKeyRef,
            mergedSortState: mergedSortStateRef,
            virtualScroll: virtualScrollRef,
            virtualScrollX: virtualScrollXRef,
            heightForRow: heightForRowRef,
            minRowHeight: minRowHeightRef,
            mergedTableLayout: mergedTableLayoutRef,
            childTriggerColIndex: childTriggerColIndexRef,
            indent: indentRef,
            rowProps: rowPropsRef,
            maxHeight: maxHeightRef,
            loadingKeySet: loadingKeySetRef,
            expandable: expandableRef,
            stickyExpandedRows: stickyExpandedRowsRef,
            renderExpandIcon: renderExpandIconRef,
            scrollbarProps: scrollbarPropsRef,
            setHeaderScrollLeft,
            handleVirtualListScroll,
            handleVirtualListResize,
            handleMouseleaveTable,
            virtualListContainer,
            virtualListContent,
            handleTableBodyScroll,
            handleCheckboxUpdateChecked,
            handleRadioUpdateChecked,
            handleUpdateExpanded,
            renderCell
          }, exposedMethods);
        },
        render() {
          const {
            mergedTheme,
            scrollX,
            mergedClsPrefix,
            virtualScroll,
            maxHeight,
            mergedTableLayout,
            flexHeight,
            loadingKeySet,
            onResize,
            setHeaderScrollLeft
          } = this;
          const scrollable = scrollX !== void 0 || maxHeight !== void 0 || flexHeight;
          const isBasicAutoLayout = !scrollable && mergedTableLayout === "auto";
          const xScrollable = scrollX !== void 0 || isBasicAutoLayout;
          const contentStyle = {
            minWidth: formatLength(scrollX) || "100%"
          };
          if (scrollX) contentStyle.width = "100%";
          const tableNode = vue.h(Scrollbar, Object.assign({}, this.scrollbarProps, {
            ref: "scrollbarInstRef",
            scrollable: scrollable || isBasicAutoLayout,
            class: `${mergedClsPrefix}-data-table-base-table-body`,
            style: !this.empty ? this.bodyStyle : void 0,
            theme: mergedTheme.peers.Scrollbar,
            themeOverrides: mergedTheme.peerOverrides.Scrollbar,
            contentStyle,
            container: virtualScroll ? this.virtualListContainer : void 0,
            content: virtualScroll ? this.virtualListContent : void 0,
            horizontalRailStyle: {
              zIndex: 3
            },
            verticalRailStyle: {
              zIndex: 3
            },
            xScrollable,
            onScroll: virtualScroll ? void 0 : this.handleTableBodyScroll,
            internalOnUpdateScrollLeft: setHeaderScrollLeft,
            onResize
          }), {
            default: () => {
              const cordToPass = {};
              const cordKey = {};
              const {
                cols,
                paginatedDataAndInfo,
                mergedTheme: mergedTheme2,
                fixedColumnLeftMap,
                fixedColumnRightMap,
                currentPage,
                rowClassName,
                mergedSortState,
                mergedExpandedRowKeySet,
                stickyExpandedRows,
                componentId,
                childTriggerColIndex,
                expandable,
                rowProps,
                handleMouseleaveTable,
                renderExpand,
                summary,
                handleCheckboxUpdateChecked,
                handleRadioUpdateChecked,
                handleUpdateExpanded,
                heightForRow,
                minRowHeight,
                virtualScrollX
              } = this;
              const {
                length: colCount
              } = cols;
              let mergedData;
              const {
                data: paginatedData,
                hasChildren
              } = paginatedDataAndInfo;
              const mergedPaginationData = hasChildren ? flatten(paginatedData, mergedExpandedRowKeySet) : paginatedData;
              if (summary) {
                const summaryRows = summary(this.rawPaginatedData);
                if (Array.isArray(summaryRows)) {
                  const summaryRowData = summaryRows.map((row, i) => ({
                    isSummaryRow: true,
                    key: `__n_summary__${i}`,
                    tmNode: {
                      rawNode: row,
                      disabled: true
                    },
                    index: -1
                  }));
                  mergedData = this.summaryPlacement === "top" ? [...summaryRowData, ...mergedPaginationData] : [...mergedPaginationData, ...summaryRowData];
                } else {
                  const summaryRowData = {
                    isSummaryRow: true,
                    key: "__n_summary__",
                    tmNode: {
                      rawNode: summaryRows,
                      disabled: true
                    },
                    index: -1
                  };
                  mergedData = this.summaryPlacement === "top" ? [summaryRowData, ...mergedPaginationData] : [...mergedPaginationData, summaryRowData];
                }
              } else {
                mergedData = mergedPaginationData;
              }
              const indentStyle = hasChildren ? {
                width: pxfy(this.indent)
              } : void 0;
              const displayedData = [];
              mergedData.forEach((rowInfo) => {
                if (renderExpand && mergedExpandedRowKeySet.has(rowInfo.key) && (!expandable || expandable(rowInfo.tmNode.rawNode))) {
                  displayedData.push(rowInfo, {
                    isExpandedRow: true,
                    key: `${rowInfo.key}-expand`,
tmNode: rowInfo.tmNode,
                    index: rowInfo.index
                  });
                } else {
                  displayedData.push(rowInfo);
                }
              });
              const {
                length: rowCount
              } = displayedData;
              const rowIndexToKey = {};
              paginatedData.forEach(({
                tmNode
              }, rowIndex) => {
                rowIndexToKey[rowIndex] = tmNode.key;
              });
              const bodyWidth = stickyExpandedRows ? this.bodyWidth : null;
              const bodyWidthPx = bodyWidth === null ? void 0 : `${bodyWidth}px`;
              const CellComponent = this.virtualScrollX ? "div" : "td";
              let leftFixedColsCount = 0;
              let rightFixedColsCount = 0;
              if (virtualScrollX) {
                cols.forEach((col) => {
                  if (col.column.fixed === "left") {
                    leftFixedColsCount++;
                  } else if (col.column.fixed === "right") {
                    rightFixedColsCount++;
                  }
                });
              }
              const renderRow = ({
rowInfo,
                displayedRowIndex,
                isVirtual,
isVirtualX,
                startColIndex,
                endColIndex,
                getLeft
              }) => {
                const {
                  index: actualRowIndex
                } = rowInfo;
                if ("isExpandedRow" in rowInfo) {
                  const {
                    tmNode: {
                      key,
                      rawNode
                    }
                  } = rowInfo;
                  return vue.h("tr", {
                    class: `${mergedClsPrefix}-data-table-tr ${mergedClsPrefix}-data-table-tr--expanded`,
                    key: `${key}__expand`
                  }, vue.h("td", {
                    class: [`${mergedClsPrefix}-data-table-td`, `${mergedClsPrefix}-data-table-td--last-col`, displayedRowIndex + 1 === rowCount && `${mergedClsPrefix}-data-table-td--last-row`],
                    colspan: colCount
                  }, stickyExpandedRows ? vue.h("div", {
                    class: `${mergedClsPrefix}-data-table-expand`,
                    style: {
                      width: bodyWidthPx
                    }
                  }, renderExpand(rawNode, actualRowIndex)) : renderExpand(rawNode, actualRowIndex)));
                }
                const isSummary = "isSummaryRow" in rowInfo;
                const striped = !isSummary && rowInfo.striped;
                const {
                  tmNode,
                  key: rowKey
                } = rowInfo;
                const {
                  rawNode: rowData
                } = tmNode;
                const expanded = mergedExpandedRowKeySet.has(rowKey);
                const props = rowProps ? rowProps(rowData, actualRowIndex) : void 0;
                const mergedRowClassName = typeof rowClassName === "string" ? rowClassName : createRowClassName(rowData, actualRowIndex, rowClassName);
                const iteratedCols = isVirtualX ? cols.filter((col, index) => {
                  if (startColIndex <= index && index <= endColIndex) return true;
                  if (col.column.fixed) {
                    return true;
                  }
                  return false;
                }) : cols;
                const virtualXRowHeight = isVirtualX ? pxfy((heightForRow === null || heightForRow === void 0 ? void 0 : heightForRow(rowData, actualRowIndex)) || minRowHeight) : void 0;
                const cells = iteratedCols.map((col) => {
                  var _a, _b, _c, _d, _e;
                  const colIndex = col.index;
                  if (displayedRowIndex in cordToPass) {
                    const cordOfRowToPass = cordToPass[displayedRowIndex];
                    const indexInCordOfRowToPass = cordOfRowToPass.indexOf(colIndex);
                    if (~indexInCordOfRowToPass) {
                      cordOfRowToPass.splice(indexInCordOfRowToPass, 1);
                      return null;
                    }
                  }
                  const {
                    column
                  } = col;
                  const colKey = getColKey(col);
                  const {
                    rowSpan,
                    colSpan
                  } = column;
                  const mergedColSpan = isSummary ? ((_a = rowInfo.tmNode.rawNode[colKey]) === null || _a === void 0 ? void 0 : _a.colSpan) || 1 : colSpan ? colSpan(rowData, actualRowIndex) : 1;
                  const mergedRowSpan = isSummary ? ((_b = rowInfo.tmNode.rawNode[colKey]) === null || _b === void 0 ? void 0 : _b.rowSpan) || 1 : rowSpan ? rowSpan(rowData, actualRowIndex) : 1;
                  const isLastCol = colIndex + mergedColSpan === colCount;
                  const isLastRow = displayedRowIndex + mergedRowSpan === rowCount;
                  const isCrossRowTd = mergedRowSpan > 1;
                  if (isCrossRowTd) {
                    cordKey[displayedRowIndex] = {
                      [colIndex]: []
                    };
                  }
                  if (mergedColSpan > 1 || isCrossRowTd) {
                    for (let i = displayedRowIndex; i < displayedRowIndex + mergedRowSpan; ++i) {
                      if (isCrossRowTd) {
                        cordKey[displayedRowIndex][colIndex].push(rowIndexToKey[i]);
                      }
                      for (let j = colIndex; j < colIndex + mergedColSpan; ++j) {
                        if (i === displayedRowIndex && j === colIndex) {
                          continue;
                        }
                        if (!(i in cordToPass)) {
                          cordToPass[i] = [j];
                        } else {
                          cordToPass[i].push(j);
                        }
                      }
                    }
                  }
                  const hoverKey = isCrossRowTd ? this.hoverKey : null;
                  const {
                    cellProps
                  } = column;
                  const resolvedCellProps = cellProps === null || cellProps === void 0 ? void 0 : cellProps(rowData, actualRowIndex);
                  const indentOffsetStyle = {
                    "--indent-offset": ""
                  };
                  const FinalCellComponent = column.fixed ? "td" : CellComponent;
                  return vue.h(FinalCellComponent, Object.assign({}, resolvedCellProps, {
                    key: colKey,
                    style: [{
                      textAlign: column.align || void 0,
                      width: pxfy(column.width)
                    }, isVirtualX && {
                      height: virtualXRowHeight
                    }, isVirtualX && !column.fixed ? {
                      position: "absolute",
                      left: pxfy(getLeft(colIndex)),
                      top: 0,
                      bottom: 0
                    } : {
                      left: pxfy((_c = fixedColumnLeftMap[colKey]) === null || _c === void 0 ? void 0 : _c.start),
                      right: pxfy((_d = fixedColumnRightMap[colKey]) === null || _d === void 0 ? void 0 : _d.start)
                    }, indentOffsetStyle, (resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.style) || ""],
                    colspan: mergedColSpan,
                    rowspan: isVirtual ? void 0 : mergedRowSpan,
                    "data-col-key": colKey,
                    class: [`${mergedClsPrefix}-data-table-td`, column.className, resolvedCellProps === null || resolvedCellProps === void 0 ? void 0 : resolvedCellProps.class, isSummary && `${mergedClsPrefix}-data-table-td--summary`, hoverKey !== null && cordKey[displayedRowIndex][colIndex].includes(hoverKey) && `${mergedClsPrefix}-data-table-td--hover`, isColumnSorting(column, mergedSortState) && `${mergedClsPrefix}-data-table-td--sorting`, column.fixed && `${mergedClsPrefix}-data-table-td--fixed-${column.fixed}`, column.align && `${mergedClsPrefix}-data-table-td--${column.align}-align`, column.type === "selection" && `${mergedClsPrefix}-data-table-td--selection`, column.type === "expand" && `${mergedClsPrefix}-data-table-td--expand`, isLastCol && `${mergedClsPrefix}-data-table-td--last-col`, isLastRow && `${mergedClsPrefix}-data-table-td--last-row`]
                  }), hasChildren && colIndex === childTriggerColIndex ? [repeat(indentOffsetStyle["--indent-offset"] = isSummary ? 0 : rowInfo.tmNode.level, vue.h("div", {
                    class: `${mergedClsPrefix}-data-table-indent`,
                    style: indentStyle
                  })), isSummary || rowInfo.tmNode.isLeaf ? vue.h("div", {
                    class: `${mergedClsPrefix}-data-table-expand-placeholder`
                  }) : vue.h(ExpandTrigger, {
                    class: `${mergedClsPrefix}-data-table-expand-trigger`,
                    clsPrefix: mergedClsPrefix,
                    expanded,
                    rowData,
                    renderExpandIcon: this.renderExpandIcon,
                    loading: loadingKeySet.has(rowInfo.key),
                    onClick: () => {
                      handleUpdateExpanded(rowKey, rowInfo.tmNode);
                    }
                  })] : null, column.type === "selection" ? !isSummary ? column.multiple === false ? vue.h(RenderSafeRadio, {
                    key: currentPage,
                    rowKey,
                    disabled: rowInfo.tmNode.disabled,
                    onUpdateChecked: () => {
                      handleRadioUpdateChecked(rowInfo.tmNode);
                    }
                  }) : vue.h(RenderSafeCheckbox, {
                    key: currentPage,
                    rowKey,
                    disabled: rowInfo.tmNode.disabled,
                    onUpdateChecked: (checked, e) => {
                      handleCheckboxUpdateChecked(rowInfo.tmNode, checked, e.shiftKey);
                    }
                  }) : null : column.type === "expand" ? !isSummary ? !column.expandable || ((_e = column.expandable) === null || _e === void 0 ? void 0 : _e.call(column, rowData)) ? vue.h(ExpandTrigger, {
                    clsPrefix: mergedClsPrefix,
                    rowData,
                    expanded,
                    renderExpandIcon: this.renderExpandIcon,
                    onClick: () => {
                      handleUpdateExpanded(rowKey, null);
                    }
                  }) : null : null : vue.h(Cell, {
                    clsPrefix: mergedClsPrefix,
                    index: actualRowIndex,
                    row: rowData,
                    column,
                    isSummary,
                    mergedTheme: mergedTheme2,
                    renderCell: this.renderCell
                  }));
                });
                if (isVirtualX) {
                  if (leftFixedColsCount && rightFixedColsCount) {
                    cells.splice(leftFixedColsCount, 0, vue.h("td", {
                      colspan: cols.length - leftFixedColsCount - rightFixedColsCount,
                      style: {
                        pointerEvents: "none",
                        visibility: "hidden",
                        height: 0
                      }
                    }));
                  }
                }
                const row = vue.h("tr", Object.assign({}, props, {
                  onMouseenter: (e) => {
                    var _a;
                    this.hoverKey = rowKey;
                    (_a = props === null || props === void 0 ? void 0 : props.onMouseenter) === null || _a === void 0 ? void 0 : _a.call(props, e);
                  },
                  key: rowKey,
                  class: [`${mergedClsPrefix}-data-table-tr`, isSummary && `${mergedClsPrefix}-data-table-tr--summary`, striped && `${mergedClsPrefix}-data-table-tr--striped`, expanded && `${mergedClsPrefix}-data-table-tr--expanded`, mergedRowClassName, props === null || props === void 0 ? void 0 : props.class],
                  style: [props === null || props === void 0 ? void 0 : props.style, isVirtualX && {
                    height: virtualXRowHeight
                  }]
                }), cells);
                return row;
              };
              if (!virtualScroll) {
                return vue.h("table", {
                  class: `${mergedClsPrefix}-data-table-table`,
                  onMouseleave: handleMouseleaveTable,
                  style: {
                    tableLayout: this.mergedTableLayout
                  }
                }, vue.h("colgroup", null, cols.map((col) => vue.h("col", {
                  key: col.key,
                  style: col.style
                }))), this.showHeader ? vue.h(TableHeader, {
                  discrete: false
                }) : null, !this.empty ? vue.h("tbody", {
                  "data-n-id": componentId,
                  class: `${mergedClsPrefix}-data-table-tbody`
                }, displayedData.map((rowInfo, displayedRowIndex) => {
                  return renderRow({
                    rowInfo,
                    displayedRowIndex,
                    isVirtual: false,
                    isVirtualX: false,
                    startColIndex: -1,
                    endColIndex: -1,
                    getLeft(_index) {
                      return -1;
                    }
                  });
                })) : null);
              } else {
                return vue.h(VVirtualList, {
                  ref: "virtualListRef",
                  items: displayedData,
                  itemSize: this.minRowHeight,
                  visibleItemsTag: VirtualListItemWrapper,
                  visibleItemsProps: {
                    clsPrefix: mergedClsPrefix,
                    id: componentId,
                    cols,
                    onMouseleave: handleMouseleaveTable
                  },
                  showScrollbar: false,
                  onResize: this.handleVirtualListResize,
                  onScroll: this.handleVirtualListScroll,
                  itemsStyle: contentStyle,
                  itemResizable: !virtualScrollX,
                  columns: cols,
                  renderItemWithCols: virtualScrollX ? ({
                    itemIndex,
                    item,
                    startColIndex,
                    endColIndex,
                    getLeft
                  }) => {
                    return renderRow({
                      displayedRowIndex: itemIndex,
                      isVirtual: true,
                      isVirtualX: true,
                      rowInfo: item,
                      startColIndex,
                      endColIndex,
                      getLeft
                    });
                  } : void 0
                }, {
                  default: ({
                    item,
                    index,
                    renderedItemWithCols
                  }) => {
                    if (renderedItemWithCols) return renderedItemWithCols;
                    return renderRow({
                      rowInfo: item,
                      displayedRowIndex: index,
                      isVirtual: true,
                      isVirtualX: false,
                      startColIndex: 0,
                      endColIndex: 0,
                      getLeft(_index) {
                        return 0;
                      }
                    });
                  }
                });
              }
            }
          });
          if (this.empty) {
            const createEmptyNode = () => vue.h("div", {
              class: [`${mergedClsPrefix}-data-table-empty`, this.loading && `${mergedClsPrefix}-data-table-empty--hide`],
              style: this.bodyStyle,
              ref: "emptyElRef"
            }, resolveSlot(this.dataTableSlots.empty, () => [vue.h(NEmpty, {
              theme: this.mergedTheme.peers.Empty,
              themeOverrides: this.mergedTheme.peerOverrides.Empty
            })]));
            if (this.shouldDisplaySomeTablePart) {
              return vue.h(vue.Fragment, null, tableNode, createEmptyNode());
            } else {
              return vue.h(VResizeObserver, {
                onResize: this.onResize
              }, {
                default: createEmptyNode
              });
            }
          }
          return tableNode;
        }
      });
      const MainTable = vue.defineComponent({
        name: "MainTable",
        setup() {
          const {
            mergedClsPrefixRef,
            rightFixedColumnsRef,
            leftFixedColumnsRef,
            bodyWidthRef,
            maxHeightRef,
            minHeightRef,
            flexHeightRef,
            virtualScrollHeaderRef,
            syncScrollState
          } = vue.inject(dataTableInjectionKey);
          const headerInstRef = vue.ref(null);
          const bodyInstRef = vue.ref(null);
          const selfElRef = vue.ref(null);
          const fixedStateInitializedRef = vue.ref(!(leftFixedColumnsRef.value.length || rightFixedColumnsRef.value.length));
          const bodyStyleRef = vue.computed(() => {
            return {
              maxHeight: formatLength(maxHeightRef.value),
              minHeight: formatLength(minHeightRef.value)
            };
          });
          function handleBodyResize(entry) {
            bodyWidthRef.value = entry.contentRect.width;
            syncScrollState();
            if (!fixedStateInitializedRef.value) {
              fixedStateInitializedRef.value = true;
            }
          }
          function getHeaderElement() {
            var _a;
            const {
              value
            } = headerInstRef;
            if (value) {
              if (virtualScrollHeaderRef.value) {
                return ((_a = value.virtualListRef) === null || _a === void 0 ? void 0 : _a.listElRef) || null;
              } else {
                return value.$el;
              }
            }
            return null;
          }
          function getBodyElement() {
            const {
              value
            } = bodyInstRef;
            if (value) {
              return value.getScrollContainer();
            }
            return null;
          }
          const exposedMethods = {
            getBodyElement,
            getHeaderElement,
            scrollTo(arg0, arg1) {
              var _a;
              (_a = bodyInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
            }
          };
          vue.watchEffect(() => {
            const {
              value: selfEl
            } = selfElRef;
            if (!selfEl) return;
            const transitionDisabledClass = `${mergedClsPrefixRef.value}-data-table-base-table--transition-disabled`;
            if (fixedStateInitializedRef.value) {
              setTimeout(() => {
                selfEl.classList.remove(transitionDisabledClass);
              }, 0);
            } else {
              selfEl.classList.add(transitionDisabledClass);
            }
          });
          return Object.assign({
            maxHeight: maxHeightRef,
            mergedClsPrefix: mergedClsPrefixRef,
            selfElRef,
            headerInstRef,
            bodyInstRef,
            bodyStyle: bodyStyleRef,
            flexHeight: flexHeightRef,
            handleBodyResize
          }, exposedMethods);
        },
        render() {
          const {
            mergedClsPrefix,
            maxHeight,
            flexHeight
          } = this;
          const headerInBody = maxHeight === void 0 && !flexHeight;
          return vue.h("div", {
            class: `${mergedClsPrefix}-data-table-base-table`,
            ref: "selfElRef"
          }, headerInBody ? null : vue.h(TableHeader, {
            ref: "headerInstRef"
          }), vue.h(TableBody, {
            ref: "bodyInstRef",
            bodyStyle: this.bodyStyle,
            showHeader: headerInBody,
            flexHeight,
            onResize: this.handleBodyResize
          }));
        }
      });
      const fixedColumnStyle = createFixedColumnStyle();
      const style$a = c$1([cB("data-table", `
 width: 100%;
 font-size: var(--n-font-size);
 display: flex;
 flex-direction: column;
 position: relative;
 --n-merged-th-color: var(--n-th-color);
 --n-merged-td-color: var(--n-td-color);
 --n-merged-border-color: var(--n-border-color);
 --n-merged-th-color-hover: var(--n-th-color-hover);
 --n-merged-th-color-sorting: var(--n-th-color-sorting);
 --n-merged-td-color-hover: var(--n-td-color-hover);
 --n-merged-td-color-sorting: var(--n-td-color-sorting);
 --n-merged-td-color-striped: var(--n-td-color-striped);
 `, [cB("data-table-wrapper", `
 flex-grow: 1;
 display: flex;
 flex-direction: column;
 `), cM("flex-height", [c$1(">", [cB("data-table-wrapper", [c$1(">", [cB("data-table-base-table", `
 display: flex;
 flex-direction: column;
 flex-grow: 1;
 `, [c$1(">", [cB("data-table-base-table-body", "flex-basis: 0;", [

c$1("&:last-child", "flex-grow: 1;")
      ])])])])])])]), c$1(">", [cB("data-table-loading-wrapper", `
 color: var(--n-loading-color);
 font-size: var(--n-loading-size);
 position: absolute;
 left: 50%;
 top: 50%;
 transform: translateX(-50%) translateY(-50%);
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 justify-content: center;
 `, [fadeInScaleUpTransition({
        originalTransform: "translateX(-50%) translateY(-50%)"
      })])]), cB("data-table-expand-placeholder", `
 margin-right: 8px;
 display: inline-block;
 width: 16px;
 height: 1px;
 `), cB("data-table-indent", `
 display: inline-block;
 height: 1px;
 `), cB("data-table-expand-trigger", `
 display: inline-flex;
 margin-right: 8px;
 cursor: pointer;
 font-size: 16px;
 vertical-align: -0.2em;
 position: relative;
 width: 16px;
 height: 16px;
 color: var(--n-td-text-color);
 transition: color .3s var(--n-bezier);
 `, [cM("expanded", [cB("icon", "transform: rotate(90deg);", [iconSwitchTransition({
        originalTransform: "rotate(90deg)"
      })]), cB("base-icon", "transform: rotate(90deg);", [iconSwitchTransition({
        originalTransform: "rotate(90deg)"
      })])]), cB("base-loading", `
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB("icon", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()]), cB("base-icon", `
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cB("data-table-thead", `
 transition: background-color .3s var(--n-bezier);
 background-color: var(--n-merged-th-color);
 `), cB("data-table-tr", `
 position: relative;
 box-sizing: border-box;
 background-clip: padding-box;
 transition: background-color .3s var(--n-bezier);
 `, [cB("data-table-expand", `
 position: sticky;
 left: 0;
 overflow: hidden;
 margin: calc(var(--n-th-padding) * -1);
 padding: var(--n-th-padding);
 box-sizing: border-box;
 `), cM("striped", "background-color: var(--n-merged-td-color-striped);", [cB("data-table-td", "background-color: var(--n-merged-td-color-striped);")]), cNotM("summary", [c$1("&:hover", "background-color: var(--n-merged-td-color-hover);", [c$1(">", [cB("data-table-td", "background-color: var(--n-merged-td-color-hover);")])])])]), cB("data-table-th", `
 padding: var(--n-th-padding);
 position: relative;
 text-align: start;
 box-sizing: border-box;
 background-color: var(--n-merged-th-color);
 border-color: var(--n-merged-border-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 color: var(--n-th-text-color);
 transition:
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 font-weight: var(--n-th-font-weight);
 `, [cM("filterable", `
 padding-right: 36px;
 `, [cM("sortable", `
 padding-right: calc(var(--n-th-padding) + 36px);
 `)]), fixedColumnStyle, cM("selection", `
 padding: 0;
 text-align: center;
 line-height: 0;
 z-index: 3;
 `), cE("title-wrapper", `
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 max-width: 100%;
 `, [cE("title", `
 flex: 1;
 min-width: 0;
 `)]), cE("ellipsis", `
 display: inline-block;
 vertical-align: bottom;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 `), cM("hover", `
 background-color: var(--n-merged-th-color-hover);
 `), cM("sorting", `
 background-color: var(--n-merged-th-color-sorting);
 `), cM("sortable", `
 cursor: pointer;
 `, [cE("ellipsis", `
 max-width: calc(100% - 18px);
 `), c$1("&:hover", `
 background-color: var(--n-merged-th-color-hover);
 `)]), cB("data-table-sorter", `
 height: var(--n-sorter-size);
 width: var(--n-sorter-size);
 margin-left: 4px;
 position: relative;
 display: inline-flex;
 align-items: center;
 justify-content: center;
 vertical-align: -0.2em;
 color: var(--n-th-icon-color);
 transition: color .3s var(--n-bezier);
 `, [cB("base-icon", "transition: transform .3s var(--n-bezier)"), cM("desc", [cB("base-icon", `
 transform: rotate(0deg);
 `)]), cM("asc", [cB("base-icon", `
 transform: rotate(-180deg);
 `)]), cM("asc, desc", `
 color: var(--n-th-icon-color-active);
 `)]), cB("data-table-resize-button", `
 width: var(--n-resizable-container-size);
 position: absolute;
 top: 0;
 right: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 cursor: col-resize;
 user-select: none;
 `, [c$1("&::after", `
 width: var(--n-resizable-size);
 height: 50%;
 position: absolute;
 top: 50%;
 left: calc(var(--n-resizable-container-size) / 2);
 bottom: 0;
 background-color: var(--n-merged-border-color);
 transform: translateY(-50%);
 transition: background-color .3s var(--n-bezier);
 z-index: 1;
 content: '';
 `), cM("active", [c$1("&::after", ` 
 background-color: var(--n-th-icon-color-active);
 `)]), c$1("&:hover::after", `
 background-color: var(--n-th-icon-color-active);
 `)]), cB("data-table-filter", `
 position: absolute;
 z-index: auto;
 right: 0;
 width: 36px;
 top: 0;
 bottom: 0;
 cursor: pointer;
 display: flex;
 justify-content: center;
 align-items: center;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 font-size: var(--n-filter-size);
 color: var(--n-th-icon-color);
 `, [c$1("&:hover", `
 background-color: var(--n-th-button-color-hover);
 `), cM("show", `
 background-color: var(--n-th-button-color-hover);
 `), cM("active", `
 background-color: var(--n-th-button-color-hover);
 color: var(--n-th-icon-color-active);
 `)])]), cB("data-table-td", `
 padding: var(--n-td-padding);
 text-align: start;
 box-sizing: border-box;
 border: none;
 background-color: var(--n-merged-td-color);
 color: var(--n-td-text-color);
 border-bottom: 1px solid var(--n-merged-border-color);
 transition:
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cM("expand", [cB("data-table-expand-trigger", `
 margin-right: 0;
 `)]), cM("last-row", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [

c$1("&::after", `
 bottom: 0 !important;
 `),
        c$1("&::before", `
 bottom: 0 !important;
 `)
      ]), cM("summary", `
 background-color: var(--n-merged-th-color);
 `), cM("hover", `
 background-color: var(--n-merged-td-color-hover);
 `), cM("sorting", `
 background-color: var(--n-merged-td-color-sorting);
 `), cE("ellipsis", `
 display: inline-block;
 text-overflow: ellipsis;
 overflow: hidden;
 white-space: nowrap;
 max-width: 100%;
 vertical-align: bottom;
 max-width: calc(100% - var(--indent-offset, -1.5) * 16px - 24px);
 `), cM("selection, expand", `
 text-align: center;
 padding: 0;
 line-height: 0;
 `), fixedColumnStyle]), cB("data-table-empty", `
 box-sizing: border-box;
 padding: var(--n-empty-padding);
 flex-grow: 1;
 flex-shrink: 0;
 opacity: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 transition: opacity .3s var(--n-bezier);
 `, [cM("hide", `
 opacity: 0;
 `)]), cE("pagination", `
 margin: var(--n-pagination-margin);
 display: flex;
 justify-content: flex-end;
 `), cB("data-table-wrapper", `
 position: relative;
 opacity: 1;
 transition: opacity .3s var(--n-bezier), border-color .3s var(--n-bezier);
 border-top-left-radius: var(--n-border-radius);
 border-top-right-radius: var(--n-border-radius);
 line-height: var(--n-line-height);
 `), cM("loading", [cB("data-table-wrapper", `
 opacity: var(--n-opacity-loading);
 pointer-events: none;
 `)]), cM("single-column", [cB("data-table-td", `
 border-bottom: 0 solid var(--n-merged-border-color);
 `, [c$1("&::after, &::before", `
 bottom: 0 !important;
 `)])]), cNotM("single-line", [cB("data-table-th", `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM("last", `
 border-right: 0 solid var(--n-merged-border-color);
 `)]), cB("data-table-td", `
 border-right: 1px solid var(--n-merged-border-color);
 `, [cM("last-col", `
 border-right: 0 solid var(--n-merged-border-color);
 `)])]), cM("bordered", [cB("data-table-wrapper", `
 border: 1px solid var(--n-merged-border-color);
 border-bottom-left-radius: var(--n-border-radius);
 border-bottom-right-radius: var(--n-border-radius);
 overflow: hidden;
 `)]), cB("data-table-base-table", [cM("transition-disabled", [cB("data-table-th", [c$1("&::after, &::before", "transition: none;")]), cB("data-table-td", [c$1("&::after, &::before", "transition: none;")])])]), cM("bottom-bordered", [cB("data-table-td", [cM("last-row", `
 border-bottom: 1px solid var(--n-merged-border-color);
 `)])]), cB("data-table-table", `
 font-variant-numeric: tabular-nums;
 width: 100%;
 word-break: break-word;
 transition: background-color .3s var(--n-bezier);
 border-collapse: separate;
 border-spacing: 0;
 background-color: var(--n-merged-td-color);
 `), cB("data-table-base-table-header", `
 border-top-left-radius: calc(var(--n-border-radius) - 1px);
 border-top-right-radius: calc(var(--n-border-radius) - 1px);
 z-index: 3;
 overflow: scroll;
 flex-shrink: 0;
 transition: border-color .3s var(--n-bezier);
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 display: none;
 width: 0;
 height: 0;
 `)]), cB("data-table-check-extra", `
 transition: color .3s var(--n-bezier);
 color: var(--n-th-icon-color);
 position: absolute;
 font-size: 14px;
 right: -4px;
 top: 50%;
 transform: translateY(-50%);
 z-index: 1;
 `)]), cB("data-table-filter-menu", [cB("scrollbar", `
 max-height: 240px;
 `), cE("group", `
 display: flex;
 flex-direction: column;
 padding: 12px 12px 0 12px;
 `, [cB("checkbox", `
 margin-bottom: 12px;
 margin-right: 0;
 `), cB("radio", `
 margin-bottom: 12px;
 margin-right: 0;
 `)]), cE("action", `
 padding: var(--n-action-padding);
 display: flex;
 flex-wrap: nowrap;
 justify-content: space-evenly;
 border-top: 1px solid var(--n-action-divider-color);
 `, [cB("button", [c$1("&:not(:last-child)", `
 margin: var(--n-action-button-margin);
 `), c$1("&:last-child", `
 margin-right: 0;
 `)])]), cB("divider", `
 margin: 0 !important;
 `)]), insideModal(cB("data-table", `
 --n-merged-th-color: var(--n-th-color-modal);
 --n-merged-td-color: var(--n-td-color-modal);
 --n-merged-border-color: var(--n-border-color-modal);
 --n-merged-th-color-hover: var(--n-th-color-hover-modal);
 --n-merged-td-color-hover: var(--n-td-color-hover-modal);
 --n-merged-th-color-sorting: var(--n-th-color-hover-modal);
 --n-merged-td-color-sorting: var(--n-td-color-hover-modal);
 --n-merged-td-color-striped: var(--n-td-color-striped-modal);
 `)), insidePopover(cB("data-table", `
 --n-merged-th-color: var(--n-th-color-popover);
 --n-merged-td-color: var(--n-td-color-popover);
 --n-merged-border-color: var(--n-border-color-popover);
 --n-merged-th-color-hover: var(--n-th-color-hover-popover);
 --n-merged-td-color-hover: var(--n-td-color-hover-popover);
 --n-merged-th-color-sorting: var(--n-th-color-hover-popover);
 --n-merged-td-color-sorting: var(--n-td-color-hover-popover);
 --n-merged-td-color-striped: var(--n-td-color-striped-popover);
 `))]);
      function createFixedColumnStyle() {
        return [cM("fixed-left", `
 left: 0;
 position: sticky;
 z-index: 2;
 `, [c$1("&::after", `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 right: -36px;
 `)]), cM("fixed-right", `
 right: 0;
 position: sticky;
 z-index: 1;
 `, [c$1("&::before", `
 pointer-events: none;
 content: "";
 width: 36px;
 display: inline-block;
 position: absolute;
 top: 0;
 bottom: -1px;
 transition: box-shadow .2s var(--n-bezier);
 left: -36px;
 `)])];
      }
      function useCheck(props, data) {
        const {
          paginatedDataRef,
          treeMateRef,
          selectionColumnRef
        } = data;
        const uncontrolledCheckedRowKeysRef = vue.ref(props.defaultCheckedRowKeys);
        const mergedCheckState = vue.computed(() => {
          var _a;
          const {
            checkedRowKeys
          } = props;
          const sourceKeys = checkedRowKeys === void 0 ? uncontrolledCheckedRowKeysRef.value : checkedRowKeys;
          if (((_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.multiple) === false) {
            return {
              checkedKeys: sourceKeys.slice(0, 1),
              indeterminateKeys: []
            };
          }
          return treeMateRef.value.getCheckedKeys(sourceKeys, {
            cascade: props.cascade,
            allowNotLoaded: props.allowCheckingNotLoaded
          });
        });
        const mergedCheckedRowKeysRef = vue.computed(() => mergedCheckState.value.checkedKeys);
        const mergedInderminateRowKeysRef = vue.computed(() => mergedCheckState.value.indeterminateKeys);
        const mergedCheckedRowKeySetRef = vue.computed(() => {
          return new Set(mergedCheckedRowKeysRef.value);
        });
        const mergedInderminateRowKeySetRef = vue.computed(() => {
          return new Set(mergedInderminateRowKeysRef.value);
        });
        const countOfCurrentPageCheckedRowsRef = vue.computed(() => {
          const {
            value: mergedCheckedRowKeySet
          } = mergedCheckedRowKeySetRef;
          return paginatedDataRef.value.reduce((total, tmNode) => {
            const {
              key,
              disabled
            } = tmNode;
            return total + (!disabled && mergedCheckedRowKeySet.has(key) ? 1 : 0);
          }, 0);
        });
        const countOfCurrentPageDisabledRowsRef = vue.computed(() => {
          return paginatedDataRef.value.filter((item) => item.disabled).length;
        });
        const someRowsCheckedRef = vue.computed(() => {
          const {
            length
          } = paginatedDataRef.value;
          const {
            value: mergedInderminateRowKeySet
          } = mergedInderminateRowKeySetRef;
          return countOfCurrentPageCheckedRowsRef.value > 0 && countOfCurrentPageCheckedRowsRef.value < length - countOfCurrentPageDisabledRowsRef.value || paginatedDataRef.value.some((rowData) => mergedInderminateRowKeySet.has(rowData.key));
        });
        const allRowsCheckedRef = vue.computed(() => {
          const {
            length
          } = paginatedDataRef.value;
          return countOfCurrentPageCheckedRowsRef.value !== 0 && countOfCurrentPageCheckedRowsRef.value === length - countOfCurrentPageDisabledRowsRef.value;
        });
        const headerCheckboxDisabledRef = vue.computed(() => {
          return paginatedDataRef.value.length === 0;
        });
        function doUpdateCheckedRowKeys(keys2, row, action) {
          const {
            "onUpdate:checkedRowKeys": _onUpdateCheckedRowKeys,
            onUpdateCheckedRowKeys,
            onCheckedRowKeysChange
          } = props;
          const rows = [];
          const {
            value: {
              getNode
            }
          } = treeMateRef;
          keys2.forEach((key) => {
            var _a;
            const row2 = (_a = getNode(key)) === null || _a === void 0 ? void 0 : _a.rawNode;
            rows.push(row2);
          });
          if (_onUpdateCheckedRowKeys) {
            call(_onUpdateCheckedRowKeys, keys2, rows, {
              row,
              action
            });
          }
          if (onUpdateCheckedRowKeys) {
            call(onUpdateCheckedRowKeys, keys2, rows, {
              row,
              action
            });
          }
          if (onCheckedRowKeysChange) {
            call(onCheckedRowKeysChange, keys2, rows, {
              row,
              action
            });
          }
          uncontrolledCheckedRowKeysRef.value = keys2;
        }
        function doCheck(rowKey, single = false, rowInfo) {
          if (props.loading) return;
          if (single) {
            doUpdateCheckedRowKeys(Array.isArray(rowKey) ? rowKey.slice(0, 1) : [rowKey], rowInfo, "check");
            return;
          }
          doUpdateCheckedRowKeys(treeMateRef.value.check(rowKey, mergedCheckedRowKeysRef.value, {
            cascade: props.cascade,
            allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, rowInfo, "check");
        }
        function doUncheck(rowKey, rowInfo) {
          if (props.loading) return;
          doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKey, mergedCheckedRowKeysRef.value, {
            cascade: props.cascade,
            allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, rowInfo, "uncheck");
        }
        function doCheckAll(checkWholeTable = false) {
          const {
            value: column
          } = selectionColumnRef;
          if (!column || props.loading) return;
          const rowKeysToCheck = [];
          (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach((tmNode) => {
            if (!tmNode.disabled) {
              rowKeysToCheck.push(tmNode.key);
            }
          });
          doUpdateCheckedRowKeys(treeMateRef.value.check(rowKeysToCheck, mergedCheckedRowKeysRef.value, {
            cascade: true,
            allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, void 0, "checkAll");
        }
        function doUncheckAll(checkWholeTable = false) {
          const {
            value: column
          } = selectionColumnRef;
          if (!column || props.loading) return;
          const rowKeysToUncheck = [];
          (checkWholeTable ? treeMateRef.value.treeNodes : paginatedDataRef.value).forEach((tmNode) => {
            if (!tmNode.disabled) {
              rowKeysToUncheck.push(tmNode.key);
            }
          });
          doUpdateCheckedRowKeys(treeMateRef.value.uncheck(rowKeysToUncheck, mergedCheckedRowKeysRef.value, {
            cascade: true,
            allowNotLoaded: props.allowCheckingNotLoaded
          }).checkedKeys, void 0, "uncheckAll");
        }
        return {
          mergedCheckedRowKeySetRef,
          mergedCheckedRowKeysRef,
          mergedInderminateRowKeySetRef,
          someRowsCheckedRef,
          allRowsCheckedRef,
          headerCheckboxDisabledRef,
          doUpdateCheckedRowKeys,
          doCheckAll,
          doUncheckAll,
          doCheck,
          doUncheck
        };
      }
      function useExpand(props, treeMateRef) {
        const renderExpandRef = useMemo(() => {
          for (const col of props.columns) {
            if (col.type === "expand") {
              return col.renderExpand;
            }
          }
        });
        const expandableRef = useMemo(() => {
          let expandable;
          for (const col of props.columns) {
            if (col.type === "expand") {
              expandable = col.expandable;
              break;
            }
          }
          return expandable;
        });
        const uncontrolledExpandedRowKeysRef = vue.ref(props.defaultExpandAll ? (renderExpandRef === null || renderExpandRef === void 0 ? void 0 : renderExpandRef.value) ? (() => {
          const expandedKeys = [];
          treeMateRef.value.treeNodes.forEach((tmNode) => {
            var _a;
            if ((_a = expandableRef.value) === null || _a === void 0 ? void 0 : _a.call(expandableRef, tmNode.rawNode)) {
              expandedKeys.push(tmNode.key);
            }
          });
          return expandedKeys;
        })() : treeMateRef.value.getNonLeafKeys() : props.defaultExpandedRowKeys);
        const controlledExpandedRowKeysRef = vue.toRef(props, "expandedRowKeys");
        const stickyExpandedRowsRef = vue.toRef(props, "stickyExpandedRows");
        const mergedExpandedRowKeysRef = useMergedState(controlledExpandedRowKeysRef, uncontrolledExpandedRowKeysRef);
        function doUpdateExpandedRowKeys(expandedKeys) {
          const {
            onUpdateExpandedRowKeys,
            "onUpdate:expandedRowKeys": _onUpdateExpandedRowKeys
          } = props;
          if (onUpdateExpandedRowKeys) {
            call(onUpdateExpandedRowKeys, expandedKeys);
          }
          if (_onUpdateExpandedRowKeys) {
            call(_onUpdateExpandedRowKeys, expandedKeys);
          }
          uncontrolledExpandedRowKeysRef.value = expandedKeys;
        }
        return {
          stickyExpandedRowsRef,
          mergedExpandedRowKeysRef,
          renderExpandRef,
          expandableRef,
          doUpdateExpandedRowKeys
        };
      }
      function getRowsAndCols(columns, getResizableWidth) {
        const rows = [];
        const cols = [];
        const dataRelatedCols = [];
        const rowItemMap = new WeakMap();
        let maxDepth = -1;
        let totalRowSpan = 0;
        let hasEllipsis = false;
        let currentLeafIndex = 0;
        function ensureMaxDepth(columns2, currentDepth) {
          if (currentDepth > maxDepth) {
            rows[currentDepth] = [];
            maxDepth = currentDepth;
          }
          columns2.forEach((column) => {
            if ("children" in column) {
              ensureMaxDepth(column.children, currentDepth + 1);
            } else {
              const key = "key" in column ? column.key : void 0;
              cols.push({
                key: getColKey(column),
                style: createCustomWidthStyle(column, key !== void 0 ? formatLength(getResizableWidth(key)) : void 0),
                column,
                index: currentLeafIndex++,
width: column.width === void 0 ? 128 : Number(column.width)
              });
              totalRowSpan += 1;
              if (!hasEllipsis) {
                hasEllipsis = !!column.ellipsis;
              }
              dataRelatedCols.push(column);
            }
          });
        }
        ensureMaxDepth(columns, 0);
        currentLeafIndex = 0;
        function ensureColLayout(columns2, currentDepth) {
          let hideUntilIndex = 0;
          columns2.forEach((column) => {
            var _a;
            if ("children" in column) {
              const cachedCurrentLeafIndex = currentLeafIndex;
              const rowItem = {
                column,
                colIndex: currentLeafIndex,
                colSpan: 0,
                rowSpan: 1,
                isLast: false
              };
              ensureColLayout(column.children, currentDepth + 1);
              column.children.forEach((childColumn) => {
                var _a2, _b;
                rowItem.colSpan += (_b = (_a2 = rowItemMap.get(childColumn)) === null || _a2 === void 0 ? void 0 : _a2.colSpan) !== null && _b !== void 0 ? _b : 0;
              });
              if (cachedCurrentLeafIndex + rowItem.colSpan === totalRowSpan) {
                rowItem.isLast = true;
              }
              rowItemMap.set(column, rowItem);
              rows[currentDepth].push(rowItem);
            } else {
              if (currentLeafIndex < hideUntilIndex) {
                currentLeafIndex += 1;
                return;
              }
              let colSpan = 1;
              if ("titleColSpan" in column) {
                colSpan = (_a = column.titleColSpan) !== null && _a !== void 0 ? _a : 1;
              }
              if (colSpan > 1) {
                hideUntilIndex = currentLeafIndex + colSpan;
              }
              const isLast = currentLeafIndex + colSpan === totalRowSpan;
              const rowItem = {
                column,
                colSpan,
                colIndex: currentLeafIndex,
                rowSpan: maxDepth - currentDepth + 1,
                isLast
              };
              rowItemMap.set(column, rowItem);
              rows[currentDepth].push(rowItem);
              currentLeafIndex += 1;
            }
          });
        }
        ensureColLayout(columns, 0);
        return {
          hasEllipsis,
          rows,
          cols,
          dataRelatedCols
        };
      }
      function useGroupHeader(props, getResizableWidth) {
        const rowsAndCols = vue.computed(() => getRowsAndCols(props.columns, getResizableWidth));
        return {
          rowsRef: vue.computed(() => rowsAndCols.value.rows),
          colsRef: vue.computed(() => rowsAndCols.value.cols),
          hasEllipsisRef: vue.computed(() => rowsAndCols.value.hasEllipsis),
          dataRelatedColsRef: vue.computed(() => rowsAndCols.value.dataRelatedCols)
        };
      }
      function useResizable() {
        const resizableWidthsRef = vue.ref({});
        function getResizableWidth(key) {
          return resizableWidthsRef.value[key];
        }
        function doUpdateResizableWidth(column, width) {
          if (isColumnResizable(column) && "key" in column) {
            resizableWidthsRef.value[column.key] = width;
          }
        }
        function clearResizableWidth() {
          resizableWidthsRef.value = {};
        }
        return {
          getResizableWidth,
          doUpdateResizableWidth,
          clearResizableWidth
        };
      }
      function useScroll(props, {
        mainTableInstRef,
        mergedCurrentPageRef,
        bodyWidthRef
      }) {
        let lastScrollLeft = 0;
        const scrollPartRef = vue.ref();
        const leftActiveFixedColKeyRef = vue.ref(null);
        const leftActiveFixedChildrenColKeysRef = vue.ref([]);
        const rightActiveFixedColKeyRef = vue.ref(null);
        const rightActiveFixedChildrenColKeysRef = vue.ref([]);
        const styleScrollXRef = vue.computed(() => {
          return formatLength(props.scrollX);
        });
        const leftFixedColumnsRef = vue.computed(() => {
          return props.columns.filter((column) => column.fixed === "left");
        });
        const rightFixedColumnsRef = vue.computed(() => {
          return props.columns.filter((column) => column.fixed === "right");
        });
        const fixedColumnLeftMapRef = vue.computed(() => {
          const columns = {};
          let left = 0;
          function traverse(cols) {
            cols.forEach((col) => {
              const positionInfo = {
                start: left,
                end: 0
              };
              columns[getColKey(col)] = positionInfo;
              if ("children" in col) {
                traverse(col.children);
                positionInfo.end = left;
              } else {
                left += getNumberColWidth(col) || 0;
                positionInfo.end = left;
              }
            });
          }
          traverse(leftFixedColumnsRef.value);
          return columns;
        });
        const fixedColumnRightMapRef = vue.computed(() => {
          const columns = {};
          let right = 0;
          function traverse(cols) {
            for (let i = cols.length - 1; i >= 0; --i) {
              const col = cols[i];
              const positionInfo = {
                start: right,
                end: 0
              };
              columns[getColKey(col)] = positionInfo;
              if ("children" in col) {
                traverse(col.children);
                positionInfo.end = right;
              } else {
                right += getNumberColWidth(col) || 0;
                positionInfo.end = right;
              }
            }
          }
          traverse(rightFixedColumnsRef.value);
          return columns;
        });
        function deriveActiveLeftFixedColumn() {
          var _a, _b;
          const {
            value: leftFixedColumns
          } = leftFixedColumnsRef;
          let leftWidth = 0;
          const {
            value: fixedColumnLeftMap
          } = fixedColumnLeftMapRef;
          let leftActiveFixedColKey = null;
          for (let i = 0; i < leftFixedColumns.length; ++i) {
            const key = getColKey(leftFixedColumns[i]);
            if (lastScrollLeft > (((_a = fixedColumnLeftMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) - leftWidth) {
              leftActiveFixedColKey = key;
              leftWidth = ((_b = fixedColumnLeftMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
            } else {
              break;
            }
          }
          leftActiveFixedColKeyRef.value = leftActiveFixedColKey;
        }
        function deriveActiveLeftFixedChildrenColumns() {
          leftActiveFixedChildrenColKeysRef.value = [];
          let activeLeftFixedColumn = props.columns.find((col) => getColKey(col) === leftActiveFixedColKeyRef.value);
          while (activeLeftFixedColumn && "children" in activeLeftFixedColumn) {
            const length = activeLeftFixedColumn.children.length;
            if (length === 0) break;
            const nextActiveLeftFixedColumn = activeLeftFixedColumn.children[length - 1];
            leftActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveLeftFixedColumn));
            activeLeftFixedColumn = nextActiveLeftFixedColumn;
          }
        }
        function deriveActiveRightFixedColumn() {
          var _a, _b;
          const {
            value: rightFixedColumns
          } = rightFixedColumnsRef;
          const scrollWidth = Number(props.scrollX);
          const {
            value: tableWidth
          } = bodyWidthRef;
          if (tableWidth === null) return;
          let rightWidth = 0;
          let rightActiveFixedColKey = null;
          const {
            value: fixedColumnRightMap
          } = fixedColumnRightMapRef;
          for (let i = rightFixedColumns.length - 1; i >= 0; --i) {
            const key = getColKey(rightFixedColumns[i]);
            if (Math.round(lastScrollLeft + (((_a = fixedColumnRightMap[key]) === null || _a === void 0 ? void 0 : _a.start) || 0) + tableWidth - rightWidth) < scrollWidth) {
              rightActiveFixedColKey = key;
              rightWidth = ((_b = fixedColumnRightMap[key]) === null || _b === void 0 ? void 0 : _b.end) || 0;
            } else {
              break;
            }
          }
          rightActiveFixedColKeyRef.value = rightActiveFixedColKey;
        }
        function deriveActiveRightFixedChildrenColumns() {
          rightActiveFixedChildrenColKeysRef.value = [];
          let activeRightFixedColumn = props.columns.find((col) => getColKey(col) === rightActiveFixedColKeyRef.value);
          while (activeRightFixedColumn && "children" in activeRightFixedColumn && activeRightFixedColumn.children.length) {
            const nextActiveRightFixedColumn = activeRightFixedColumn.children[0];
            rightActiveFixedChildrenColKeysRef.value.push(getColKey(nextActiveRightFixedColumn));
            activeRightFixedColumn = nextActiveRightFixedColumn;
          }
        }
        function getScrollElements() {
          const header = mainTableInstRef.value ? mainTableInstRef.value.getHeaderElement() : null;
          const body = mainTableInstRef.value ? mainTableInstRef.value.getBodyElement() : null;
          return {
            header,
            body
          };
        }
        function scrollMainTableBodyToTop() {
          const {
            body
          } = getScrollElements();
          if (body) {
            body.scrollTop = 0;
          }
        }
        function handleTableHeaderScroll() {
          if (scrollPartRef.value !== "body") {
            beforeNextFrameOnce(syncScrollState);
          } else {
            scrollPartRef.value = void 0;
          }
        }
        function handleTableBodyScroll(e) {
          var _a;
          (_a = props.onScroll) === null || _a === void 0 ? void 0 : _a.call(props, e);
          if (scrollPartRef.value !== "head") {
            beforeNextFrameOnce(syncScrollState);
          } else {
            scrollPartRef.value = void 0;
          }
        }
        function syncScrollState() {
          const {
            header,
            body
          } = getScrollElements();
          if (!body) return;
          const {
            value: tableWidth
          } = bodyWidthRef;
          if (tableWidth === null) return;
          if (props.maxHeight || props.flexHeight) {
            if (!header) return;
            const directionHead = lastScrollLeft - header.scrollLeft;
            scrollPartRef.value = directionHead !== 0 ? "head" : "body";
            if (scrollPartRef.value === "head") {
              lastScrollLeft = header.scrollLeft;
              body.scrollLeft = lastScrollLeft;
            } else {
              lastScrollLeft = body.scrollLeft;
              header.scrollLeft = lastScrollLeft;
            }
          } else {
            lastScrollLeft = body.scrollLeft;
          }
          deriveActiveLeftFixedColumn();
          deriveActiveLeftFixedChildrenColumns();
          deriveActiveRightFixedColumn();
          deriveActiveRightFixedChildrenColumns();
        }
        function setHeaderScrollLeft(left) {
          const {
            header
          } = getScrollElements();
          if (!header) return;
          header.scrollLeft = left;
          syncScrollState();
        }
        vue.watch(mergedCurrentPageRef, () => {
          scrollMainTableBodyToTop();
        });
        return {
          styleScrollXRef,
          fixedColumnLeftMapRef,
          fixedColumnRightMapRef,
          leftFixedColumnsRef,
          rightFixedColumnsRef,
          leftActiveFixedColKeyRef,
          leftActiveFixedChildrenColKeysRef,
          rightActiveFixedColKeyRef,
          rightActiveFixedChildrenColKeysRef,
          syncScrollState,
          handleTableBodyScroll,
          handleTableHeaderScroll,
          setHeaderScrollLeft
        };
      }
      function getMultiplePriority(sorter) {
        if (typeof sorter === "object" && typeof sorter.multiple === "number") {
          return sorter.multiple;
        }
        return false;
      }
      function getSortFunction(sorter, columnKey) {
        if (columnKey && (sorter === void 0 || sorter === "default" || typeof sorter === "object" && sorter.compare === "default")) {
          return getDefaultSorterFn(columnKey);
        }
        if (typeof sorter === "function") {
          return sorter;
        }
        if (sorter && typeof sorter === "object" && sorter.compare && sorter.compare !== "default") {
          return sorter.compare;
        }
        return false;
      }
      function getDefaultSorterFn(columnKey) {
        return (row1, row2) => {
          const value1 = row1[columnKey];
          const value2 = row2[columnKey];
          if (value1 === null || value1 === void 0) {
            if (value2 === null || value2 === void 0) return 0;
            return -1;
          } else if (value2 === null || value2 === void 0) {
            return 1;
          } else if (typeof value1 === "number" && typeof value2 === "number") {
            return value1 - value2;
          } else if (typeof value1 === "string" && typeof value2 === "string") {
            return value1.localeCompare(value2);
          }
          return 0;
        };
      }
      function useSorter(props, {
        dataRelatedColsRef,
        filteredDataRef
      }) {
        const defaultSortState = [];
        dataRelatedColsRef.value.forEach((column) => {
          var _a;
          if (column.sorter !== void 0) {
            updateSortStatesByNewSortState(defaultSortState, {
              columnKey: column.key,
              sorter: column.sorter,
              order: (_a = column.defaultSortOrder) !== null && _a !== void 0 ? _a : false
            });
          }
        });
        const uncontrolledSortStateRef = vue.ref(defaultSortState);
        const mergedSortStateRef = vue.computed(() => {
          const columnsWithControlledSortOrder = dataRelatedColsRef.value.filter((column) => column.type !== "selection" && column.sorter !== void 0 && (column.sortOrder === "ascend" || column.sortOrder === "descend" || column.sortOrder === false));
          const columnToSort = columnsWithControlledSortOrder.filter((col) => col.sortOrder !== false);
          if (columnToSort.length) {
            return columnToSort.map((column) => {
              return {
                columnKey: column.key,

order: column.sortOrder,
                sorter: column.sorter
              };
            });
          }
          if (columnsWithControlledSortOrder.length) return [];
          const {
            value: uncontrolledSortState
          } = uncontrolledSortStateRef;
          if (Array.isArray(uncontrolledSortState)) {
            return uncontrolledSortState;
          } else if (uncontrolledSortState) {
            return [uncontrolledSortState];
          } else {
            return [];
          }
        });
        const sortedDataRef = vue.computed(() => {
          const activeSorters = mergedSortStateRef.value.slice().sort((a, b) => {
            const item1Priority = getMultiplePriority(a.sorter) || 0;
            const item2Priority = getMultiplePriority(b.sorter) || 0;
            return item2Priority - item1Priority;
          });
          if (activeSorters.length) {
            const filteredData = filteredDataRef.value.slice();
            return filteredData.sort((tmNode1, tmNode2) => {
              let compareResult = 0;
              activeSorters.some((sorterState) => {
                const {
                  columnKey,
                  sorter,
                  order
                } = sorterState;
                const compareFn = getSortFunction(sorter, columnKey);
                if (compareFn && order) {
                  compareResult = compareFn(tmNode1.rawNode, tmNode2.rawNode);
                  if (compareResult !== 0) {
                    compareResult = compareResult * getFlagOfOrder(order);
                    return true;
                  }
                }
                return false;
              });
              return compareResult;
            });
          }
          return filteredDataRef.value;
        });
        function getUpdatedSorterState(sortState) {
          let currentSortState = mergedSortStateRef.value.slice();
          if (sortState && getMultiplePriority(sortState.sorter) !== false) {
            currentSortState = currentSortState.filter((sortState2) => getMultiplePriority(sortState2.sorter) !== false);
            updateSortStatesByNewSortState(currentSortState, sortState);
            return currentSortState;
          } else if (sortState) {
            return sortState;
          }
          return null;
        }
        function deriveNextSorter(sortState) {
          const nextSorterState = getUpdatedSorterState(sortState);
          doUpdateSorter(nextSorterState);
        }
        function doUpdateSorter(sortState) {
          const {
            "onUpdate:sorter": _onUpdateSorter,
            onUpdateSorter,
            onSorterChange
          } = props;
          if (_onUpdateSorter) {
            call(_onUpdateSorter, sortState);
          }
          if (onUpdateSorter) {
            call(onUpdateSorter, sortState);
          }
          if (onSorterChange) {
            call(onSorterChange, sortState);
          }
          uncontrolledSortStateRef.value = sortState;
        }
        function sort(columnKey, order = "ascend") {
          if (!columnKey) {
            clearSorter();
          } else {
            const columnToSort = dataRelatedColsRef.value.find((column) => column.type !== "selection" && column.type !== "expand" && column.key === columnKey);
            if (!(columnToSort === null || columnToSort === void 0 ? void 0 : columnToSort.sorter)) return;
            const sorter = columnToSort.sorter;
            deriveNextSorter({
              columnKey,
              sorter,
              order
            });
          }
        }
        function clearSorter() {
          doUpdateSorter(null);
        }
        function updateSortStatesByNewSortState(sortStates, sortState) {
          const index = sortStates.findIndex((state) => (sortState === null || sortState === void 0 ? void 0 : sortState.columnKey) && state.columnKey === sortState.columnKey);
          if (index !== void 0 && index >= 0) {
            sortStates[index] = sortState;
          } else {
            sortStates.push(sortState);
          }
        }
        return {
          clearSorter,
          sort,
          sortedDataRef,
          mergedSortStateRef,
          deriveNextSorter
        };
      }
      function useTableData(props, {
        dataRelatedColsRef
      }) {
        const selectionColumnRef = vue.computed(() => {
          const getSelectionColumn = (cols) => {
            for (let i = 0; i < cols.length; ++i) {
              const col = cols[i];
              if ("children" in col) {
                return getSelectionColumn(col.children);
              } else if (col.type === "selection") {
                return col;
              }
            }
            return null;
          };
          return getSelectionColumn(props.columns);
        });
        const treeMateRef = vue.computed(() => {
          const {
            childrenKey
          } = props;
          return createTreeMate(props.data, {
            ignoreEmptyChildren: true,
            getKey: props.rowKey,
            getChildren: (rowData) => rowData[childrenKey],
            getDisabled: (rowData) => {
              var _a, _b;
              if ((_b = (_a = selectionColumnRef.value) === null || _a === void 0 ? void 0 : _a.disabled) === null || _b === void 0 ? void 0 : _b.call(_a, rowData)) {
                return true;
              }
              return false;
            }
          });
        });
        const childTriggerColIndexRef = useMemo(() => {
          const {
            columns
          } = props;
          const {
            length
          } = columns;
          let firstContentfulColIndex = null;
          for (let i = 0; i < length; ++i) {
            const col = columns[i];
            if (!col.type && firstContentfulColIndex === null) {
              firstContentfulColIndex = i;
            }
            if ("tree" in col && col.tree) {
              return i;
            }
          }
          return firstContentfulColIndex || 0;
        });
        const uncontrolledFilterStateRef = vue.ref({});
        const {
          pagination
        } = props;
        const uncontrolledCurrentPageRef = vue.ref(pagination ? pagination.defaultPage || 1 : 1);
        const uncontrolledPageSizeRef = vue.ref(getDefaultPageSize(pagination));
        const mergedFilterStateRef = vue.computed(() => {
          const columnsWithControlledFilter = dataRelatedColsRef.value.filter((column) => {
            return column.filterOptionValues !== void 0 || column.filterOptionValue !== void 0;
          });
          const controlledFilterState = {};
          columnsWithControlledFilter.forEach((column) => {
            var _a;
            if (column.type === "selection" || column.type === "expand") return;
            if (column.filterOptionValues === void 0) {
              controlledFilterState[column.key] = (_a = column.filterOptionValue) !== null && _a !== void 0 ? _a : null;
            } else {
              controlledFilterState[column.key] = column.filterOptionValues;
            }
          });
          const activeFilters = Object.assign(createShallowClonedObject(uncontrolledFilterStateRef.value), controlledFilterState);
          return activeFilters;
        });
        const filteredDataRef = vue.computed(() => {
          const mergedFilterState = mergedFilterStateRef.value;
          const {
            columns
          } = props;
          function createDefaultFilter(columnKey) {
            return (filterOptionValue, row) => !!~String(row[columnKey]).indexOf(String(filterOptionValue));
          }
          const {
            value: {
              treeNodes: data
            }
          } = treeMateRef;
          const columnEntries = [];
          columns.forEach((column) => {
            if (column.type === "selection" || column.type === "expand" || "children" in column) {
              return;
            }
            columnEntries.push([column.key, column]);
          });
          return data ? data.filter((tmNode) => {
            const {
              rawNode: row
            } = tmNode;
            for (const [columnKey, column] of columnEntries) {
              let activeFilterOptionValues = mergedFilterState[columnKey];
              if (activeFilterOptionValues == null) continue;
              if (!Array.isArray(activeFilterOptionValues)) {
                activeFilterOptionValues = [activeFilterOptionValues];
              }
              if (!activeFilterOptionValues.length) continue;
              const filter2 = column.filter === "default" ? createDefaultFilter(columnKey) : column.filter;
              if (column && typeof filter2 === "function") {
                if (column.filterMode === "and") {
                  if (activeFilterOptionValues.some((filterOptionValue) => !filter2(filterOptionValue, row))) {
                    return false;
                  }
                } else {
                  if (activeFilterOptionValues.some((filterOptionValue) => filter2(filterOptionValue, row))) {
                    continue;
                  } else {
                    return false;
                  }
                }
              }
            }
            return true;
          }) : [];
        });
        const {
          sortedDataRef,
          deriveNextSorter,
          mergedSortStateRef,
          sort,
          clearSorter
        } = useSorter(props, {
          dataRelatedColsRef,
          filteredDataRef
        });
        dataRelatedColsRef.value.forEach((column) => {
          var _a;
          if (column.filter) {
            const defaultFilterOptionValues = column.defaultFilterOptionValues;
            if (column.filterMultiple) {
              uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues || [];
            } else if (defaultFilterOptionValues !== void 0) {
              uncontrolledFilterStateRef.value[column.key] = defaultFilterOptionValues === null ? [] : defaultFilterOptionValues;
            } else {
              uncontrolledFilterStateRef.value[column.key] = (_a = column.defaultFilterOptionValue) !== null && _a !== void 0 ? _a : null;
            }
          }
        });
        const controlledCurrentPageRef = vue.computed(() => {
          const {
            pagination: pagination2
          } = props;
          if (pagination2 === false) return void 0;
          return pagination2.page;
        });
        const controlledPageSizeRef = vue.computed(() => {
          const {
            pagination: pagination2
          } = props;
          if (pagination2 === false) return void 0;
          return pagination2.pageSize;
        });
        const _mergedCurrentPageRef = useMergedState(controlledCurrentPageRef, uncontrolledCurrentPageRef);
        const mergedPageSizeRef = useMergedState(controlledPageSizeRef, uncontrolledPageSizeRef);
        const boundedMergedCurrentPageRef = useMemo(() => {
          const page2 = _mergedCurrentPageRef.value;
          return props.remote ? page2 : Math.max(1, Math.min(Math.ceil(filteredDataRef.value.length / mergedPageSizeRef.value), page2));
        });
        const mergedPageCountRef = vue.computed(() => {
          const {
            pagination: pagination2
          } = props;
          if (pagination2) {
            const {
              pageCount
            } = pagination2;
            if (pageCount !== void 0) return pageCount;
          }
          return void 0;
        });
        const paginatedDataRef = vue.computed(() => {
          if (props.remote) return treeMateRef.value.treeNodes;
          if (!props.pagination) return sortedDataRef.value;
          const pageSize = mergedPageSizeRef.value;
          const startIndex = (boundedMergedCurrentPageRef.value - 1) * pageSize;
          return sortedDataRef.value.slice(startIndex, startIndex + pageSize);
        });
        const rawPaginatedDataRef = vue.computed(() => {
          return paginatedDataRef.value.map((tmNode) => tmNode.rawNode);
        });
        function mergedOnUpdatePage(page2) {
          const {
            pagination: pagination2
          } = props;
          if (pagination2) {
            const {
              onChange,
              "onUpdate:page": _onUpdatePage,
              onUpdatePage
            } = pagination2;
            if (onChange) call(onChange, page2);
            if (onUpdatePage) call(onUpdatePage, page2);
            if (_onUpdatePage) call(_onUpdatePage, page2);
            doUpdatePage(page2);
          }
        }
        function mergedOnUpdatePageSize(pageSize) {
          const {
            pagination: pagination2
          } = props;
          if (pagination2) {
            const {
              onPageSizeChange,
              "onUpdate:pageSize": _onUpdatePageSize,
              onUpdatePageSize
            } = pagination2;
            if (onPageSizeChange) call(onPageSizeChange, pageSize);
            if (onUpdatePageSize) call(onUpdatePageSize, pageSize);
            if (_onUpdatePageSize) call(_onUpdatePageSize, pageSize);
            doUpdatePageSize(pageSize);
          }
        }
        const mergedItemCountRef = vue.computed(() => {
          if (props.remote) {
            const {
              pagination: pagination2
            } = props;
            if (pagination2) {
              const {
                itemCount
              } = pagination2;
              if (itemCount !== void 0) return itemCount;
            }
            return void 0;
          }
          return filteredDataRef.value.length;
        });
        const mergedPaginationRef = vue.computed(() => {
          return Object.assign(Object.assign({}, props.pagination), {
onChange: void 0,
            onUpdatePage: void 0,
            onUpdatePageSize: void 0,
            onPageSizeChange: void 0,
            "onUpdate:page": mergedOnUpdatePage,
            "onUpdate:pageSize": mergedOnUpdatePageSize,


page: boundedMergedCurrentPageRef.value,
            pageSize: mergedPageSizeRef.value,
            pageCount: mergedItemCountRef.value === void 0 ? mergedPageCountRef.value : void 0,
            itemCount: mergedItemCountRef.value
          });
        });
        function doUpdatePage(page2) {
          const {
            "onUpdate:page": _onUpdatePage,
            onPageChange,
            onUpdatePage
          } = props;
          if (onUpdatePage) call(onUpdatePage, page2);
          if (_onUpdatePage) call(_onUpdatePage, page2);
          if (onPageChange) call(onPageChange, page2);
          uncontrolledCurrentPageRef.value = page2;
        }
        function doUpdatePageSize(pageSize) {
          const {
            "onUpdate:pageSize": _onUpdatePageSize,
            onPageSizeChange,
            onUpdatePageSize
          } = props;
          if (onPageSizeChange) call(onPageSizeChange, pageSize);
          if (onUpdatePageSize) call(onUpdatePageSize, pageSize);
          if (_onUpdatePageSize) call(_onUpdatePageSize, pageSize);
          uncontrolledPageSizeRef.value = pageSize;
        }
        function doUpdateFilters(filters2, sourceColumn) {
          const {
            onUpdateFilters,
            "onUpdate:filters": _onUpdateFilters,
            onFiltersChange
          } = props;
          if (onUpdateFilters) call(onUpdateFilters, filters2, sourceColumn);
          if (_onUpdateFilters) call(_onUpdateFilters, filters2, sourceColumn);
          if (onFiltersChange) call(onFiltersChange, filters2, sourceColumn);
          uncontrolledFilterStateRef.value = filters2;
        }
        function onUnstableColumnResize(resizedWidth, limitedWidth, column, getColumnWidth) {
          var _a;
          (_a = props.onUnstableColumnResize) === null || _a === void 0 ? void 0 : _a.call(props, resizedWidth, limitedWidth, column, getColumnWidth);
        }
        function page(page2) {
          doUpdatePage(page2);
        }
        function clearFilter() {
          clearFilters();
        }
        function clearFilters() {
          filters({});
        }
        function filters(filters2) {
          filter(filters2);
        }
        function filter(filters2) {
          if (!filters2) {
            uncontrolledFilterStateRef.value = {};
          } else if (filters2) {
            uncontrolledFilterStateRef.value = createShallowClonedObject(filters2);
          } else ;
        }
        return {
          treeMateRef,
          mergedCurrentPageRef: boundedMergedCurrentPageRef,
          mergedPaginationRef,
          paginatedDataRef,
          rawPaginatedDataRef,
          mergedFilterStateRef,
          mergedSortStateRef,
          hoverKeyRef: vue.ref(null),
          selectionColumnRef,
          childTriggerColIndexRef,
          doUpdateFilters,
          deriveNextSorter,
          doUpdatePageSize,
          doUpdatePage,
          onUnstableColumnResize,
filter,
          filters,
          clearFilter,
          clearFilters,
          clearSorter,
          page,
          sort
        };
      }
      const NDataTable = vue.defineComponent({
        name: "DataTable",
        alias: ["AdvancedTable"],
        props: dataTableProps,
        slots: Object,
        setup(props, {
          slots
        }) {
          const {
            mergedBorderedRef,
            mergedClsPrefixRef,
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const rtlEnabledRef = useRtl("DataTable", mergedRtlRef, mergedClsPrefixRef);
          const mergedBottomBorderedRef = vue.computed(() => {
            const {
              bottomBordered
            } = props;
            if (mergedBorderedRef.value) return false;
            if (bottomBordered !== void 0) return bottomBordered;
            return true;
          });
          const themeRef = useTheme("DataTable", "-data-table", style$a, dataTableLight, props, mergedClsPrefixRef);
          const bodyWidthRef = vue.ref(null);
          const mainTableInstRef = vue.ref(null);
          const {
            getResizableWidth,
            clearResizableWidth,
            doUpdateResizableWidth
          } = useResizable();
          const {
            rowsRef,
            colsRef,
            dataRelatedColsRef,
            hasEllipsisRef
          } = useGroupHeader(props, getResizableWidth);
          const {
            treeMateRef,
            mergedCurrentPageRef,
            paginatedDataRef,
            rawPaginatedDataRef,
            selectionColumnRef,
            hoverKeyRef,
            mergedPaginationRef,
            mergedFilterStateRef,
            mergedSortStateRef,
            childTriggerColIndexRef,
            doUpdatePage,
            doUpdateFilters,
            onUnstableColumnResize,
            deriveNextSorter,
            filter,
            filters,
            clearFilter,
            clearFilters,
            clearSorter,
            page,
            sort
          } = useTableData(props, {
            dataRelatedColsRef
          });
          const downloadCsv = (options) => {
            const {
              fileName = "data.csv",
              keepOriginalData = false
            } = options || {};
            const data = keepOriginalData ? props.data : rawPaginatedDataRef.value;
            const csvData = generateCsv(props.columns, data, props.getCsvCell, props.getCsvHeader);
            const blob = new Blob([csvData], {
              type: "text/csv;charset=utf-8"
            });
            const downloadUrl = URL.createObjectURL(blob);
            download(downloadUrl, fileName.endsWith(".csv") ? fileName : `${fileName}.csv`);
            URL.revokeObjectURL(downloadUrl);
          };
          const {
            doCheckAll,
            doUncheckAll,
            doCheck,
            doUncheck,
            headerCheckboxDisabledRef,
            someRowsCheckedRef,
            allRowsCheckedRef,
            mergedCheckedRowKeySetRef,
            mergedInderminateRowKeySetRef
          } = useCheck(props, {
            selectionColumnRef,
            treeMateRef,
            paginatedDataRef
          });
          const {
            stickyExpandedRowsRef,
            mergedExpandedRowKeysRef,
            renderExpandRef,
            expandableRef,
            doUpdateExpandedRowKeys
          } = useExpand(props, treeMateRef);
          const {
            handleTableBodyScroll,
            handleTableHeaderScroll,
            syncScrollState,
            setHeaderScrollLeft,
            leftActiveFixedColKeyRef,
            leftActiveFixedChildrenColKeysRef,
            rightActiveFixedColKeyRef,
            rightActiveFixedChildrenColKeysRef,
            leftFixedColumnsRef,
            rightFixedColumnsRef,
            fixedColumnLeftMapRef,
            fixedColumnRightMapRef
          } = useScroll(props, {
            bodyWidthRef,
            mainTableInstRef,
            mergedCurrentPageRef
          });
          const {
            localeRef
          } = useLocale("DataTable");
          const mergedTableLayoutRef = vue.computed(() => {
            if (props.virtualScroll || props.flexHeight || props.maxHeight !== void 0 || hasEllipsisRef.value) {
              return "fixed";
            }
            return props.tableLayout;
          });
          vue.provide(dataTableInjectionKey, {
            props,
            treeMateRef,
            renderExpandIconRef: vue.toRef(props, "renderExpandIcon"),
            loadingKeySetRef: vue.ref( new Set()),
            slots,
            indentRef: vue.toRef(props, "indent"),
            childTriggerColIndexRef,
            bodyWidthRef,
            componentId: createId(),
            hoverKeyRef,
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            scrollXRef: vue.computed(() => props.scrollX),
            rowsRef,
            colsRef,
            paginatedDataRef,
            leftActiveFixedColKeyRef,
            leftActiveFixedChildrenColKeysRef,
            rightActiveFixedColKeyRef,
            rightActiveFixedChildrenColKeysRef,
            leftFixedColumnsRef,
            rightFixedColumnsRef,
            fixedColumnLeftMapRef,
            fixedColumnRightMapRef,
            mergedCurrentPageRef,
            someRowsCheckedRef,
            allRowsCheckedRef,
            mergedSortStateRef,
            mergedFilterStateRef,
            loadingRef: vue.toRef(props, "loading"),
            rowClassNameRef: vue.toRef(props, "rowClassName"),
            mergedCheckedRowKeySetRef,
            mergedExpandedRowKeysRef,
            mergedInderminateRowKeySetRef,
            localeRef,
            expandableRef,
            stickyExpandedRowsRef,
            rowKeyRef: vue.toRef(props, "rowKey"),
            renderExpandRef,
            summaryRef: vue.toRef(props, "summary"),
            virtualScrollRef: vue.toRef(props, "virtualScroll"),
            virtualScrollXRef: vue.toRef(props, "virtualScrollX"),
            heightForRowRef: vue.toRef(props, "heightForRow"),
            minRowHeightRef: vue.toRef(props, "minRowHeight"),
            virtualScrollHeaderRef: vue.toRef(props, "virtualScrollHeader"),
            headerHeightRef: vue.toRef(props, "headerHeight"),
            rowPropsRef: vue.toRef(props, "rowProps"),
            stripedRef: vue.toRef(props, "striped"),
            checkOptionsRef: vue.computed(() => {
              const {
                value: selectionColumn
              } = selectionColumnRef;
              return selectionColumn === null || selectionColumn === void 0 ? void 0 : selectionColumn.options;
            }),
            rawPaginatedDataRef,
            filterMenuCssVarsRef: vue.computed(() => {
              const {
                self: {
                  actionDividerColor,
                  actionPadding,
                  actionButtonMargin
                }
              } = themeRef.value;
              return {
                "--n-action-padding": actionPadding,
                "--n-action-button-margin": actionButtonMargin,
                "--n-action-divider-color": actionDividerColor
              };
            }),
            onLoadRef: vue.toRef(props, "onLoad"),
            mergedTableLayoutRef,
            maxHeightRef: vue.toRef(props, "maxHeight"),
            minHeightRef: vue.toRef(props, "minHeight"),
            flexHeightRef: vue.toRef(props, "flexHeight"),
            headerCheckboxDisabledRef,
            paginationBehaviorOnFilterRef: vue.toRef(props, "paginationBehaviorOnFilter"),
            summaryPlacementRef: vue.toRef(props, "summaryPlacement"),
            filterIconPopoverPropsRef: vue.toRef(props, "filterIconPopoverProps"),
            scrollbarPropsRef: vue.toRef(props, "scrollbarProps"),
            syncScrollState,
            doUpdatePage,
            doUpdateFilters,
            getResizableWidth,
            onUnstableColumnResize,
            clearResizableWidth,
            doUpdateResizableWidth,
            deriveNextSorter,
            doCheck,
            doUncheck,
            doCheckAll,
            doUncheckAll,
            doUpdateExpandedRowKeys,
            handleTableHeaderScroll,
            handleTableBodyScroll,
            setHeaderScrollLeft,
            renderCell: vue.toRef(props, "renderCell")
          });
          const exposedMethods = {
            filter,
            filters,
            clearFilters,
            clearSorter,
            page,
            sort,
            clearFilter,
            downloadCsv,
            scrollTo: (arg0, arg1) => {
              var _a;
              (_a = mainTableInstRef.value) === null || _a === void 0 ? void 0 : _a.scrollTo(arg0, arg1);
            }
          };
          const cssVarsRef = vue.computed(() => {
            const {
              size: size2
            } = props;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                borderColor,
                tdColorHover,
                tdColorSorting,
                tdColorSortingModal,
                tdColorSortingPopover,
                thColorSorting,
                thColorSortingModal,
                thColorSortingPopover,
                thColor,
                thColorHover,
                tdColor,
                tdTextColor,
                thTextColor,
                thFontWeight,
                thButtonColorHover,
                thIconColor,
                thIconColorActive,
                filterSize,
                borderRadius,
                lineHeight: lineHeight2,
                tdColorModal,
                thColorModal,
                borderColorModal,
                thColorHoverModal,
                tdColorHoverModal,
                borderColorPopover,
                thColorPopover,
                tdColorPopover,
                tdColorHoverPopover,
                thColorHoverPopover,
                paginationMargin,
                emptyPadding,
                boxShadowAfter,
                boxShadowBefore,
                sorterSize,
                resizableContainerSize,
                resizableSize,
                loadingColor,
                loadingSize,
                opacityLoading,
                tdColorStriped,
                tdColorStripedModal,
                tdColorStripedPopover,
                [createKey("fontSize", size2)]: fontSize2,
                [createKey("thPadding", size2)]: thPadding,
                [createKey("tdPadding", size2)]: tdPadding
              }
            } = themeRef.value;
            return {
              "--n-font-size": fontSize2,
              "--n-th-padding": thPadding,
              "--n-td-padding": tdPadding,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-border-radius": borderRadius,
              "--n-line-height": lineHeight2,
              "--n-border-color": borderColor,
              "--n-border-color-modal": borderColorModal,
              "--n-border-color-popover": borderColorPopover,
              "--n-th-color": thColor,
              "--n-th-color-hover": thColorHover,
              "--n-th-color-modal": thColorModal,
              "--n-th-color-hover-modal": thColorHoverModal,
              "--n-th-color-popover": thColorPopover,
              "--n-th-color-hover-popover": thColorHoverPopover,
              "--n-td-color": tdColor,
              "--n-td-color-hover": tdColorHover,
              "--n-td-color-modal": tdColorModal,
              "--n-td-color-hover-modal": tdColorHoverModal,
              "--n-td-color-popover": tdColorPopover,
              "--n-td-color-hover-popover": tdColorHoverPopover,
              "--n-th-text-color": thTextColor,
              "--n-td-text-color": tdTextColor,
              "--n-th-font-weight": thFontWeight,
              "--n-th-button-color-hover": thButtonColorHover,
              "--n-th-icon-color": thIconColor,
              "--n-th-icon-color-active": thIconColorActive,
              "--n-filter-size": filterSize,
              "--n-pagination-margin": paginationMargin,
              "--n-empty-padding": emptyPadding,
              "--n-box-shadow-before": boxShadowBefore,
              "--n-box-shadow-after": boxShadowAfter,
              "--n-sorter-size": sorterSize,
              "--n-resizable-container-size": resizableContainerSize,
              "--n-resizable-size": resizableSize,
              "--n-loading-size": loadingSize,
              "--n-loading-color": loadingColor,
              "--n-opacity-loading": opacityLoading,
              "--n-td-color-striped": tdColorStriped,
              "--n-td-color-striped-modal": tdColorStripedModal,
              "--n-td-color-striped-popover": tdColorStripedPopover,
              "--n-td-color-sorting": tdColorSorting,
              "--n-td-color-sorting-modal": tdColorSortingModal,
              "--n-td-color-sorting-popover": tdColorSortingPopover,
              "--n-th-color-sorting": thColorSorting,
              "--n-th-color-sorting-modal": thColorSortingModal,
              "--n-th-color-sorting-popover": thColorSortingPopover
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("data-table", vue.computed(() => props.size[0]), cssVarsRef, props) : void 0;
          const mergedShowPaginationRef = vue.computed(() => {
            if (!props.pagination) return false;
            if (props.paginateSinglePage) return true;
            const mergedPagination = mergedPaginationRef.value;
            const {
              pageCount
            } = mergedPagination;
            if (pageCount !== void 0) return pageCount > 1;
            return mergedPagination.itemCount && mergedPagination.pageSize && mergedPagination.itemCount > mergedPagination.pageSize;
          });
          return Object.assign({
            mainTableInstRef,
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            mergedTheme: themeRef,
            paginatedData: paginatedDataRef,
            mergedBordered: mergedBorderedRef,
            mergedBottomBordered: mergedBottomBorderedRef,
            mergedPagination: mergedPaginationRef,
            mergedShowPagination: mergedShowPaginationRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          }, exposedMethods);
        },
        render() {
          const {
            mergedClsPrefix,
            themeClass,
            onRender,
            $slots,
            spinProps
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          return vue.h("div", {
            class: [`${mergedClsPrefix}-data-table`, this.rtlEnabled && `${mergedClsPrefix}-data-table--rtl`, themeClass, {
              [`${mergedClsPrefix}-data-table--bordered`]: this.mergedBordered,
              [`${mergedClsPrefix}-data-table--bottom-bordered`]: this.mergedBottomBordered,
              [`${mergedClsPrefix}-data-table--single-line`]: this.singleLine,
              [`${mergedClsPrefix}-data-table--single-column`]: this.singleColumn,
              [`${mergedClsPrefix}-data-table--loading`]: this.loading,
              [`${mergedClsPrefix}-data-table--flex-height`]: this.flexHeight
            }],
            style: this.cssVars
          }, vue.h("div", {
            class: `${mergedClsPrefix}-data-table-wrapper`
          }, vue.h(MainTable, {
            ref: "mainTableInstRef"
          })), this.mergedShowPagination ? vue.h("div", {
            class: `${mergedClsPrefix}-data-table__pagination`
          }, vue.h(NPagination, Object.assign({
            theme: this.mergedTheme.peers.Pagination,
            themeOverrides: this.mergedTheme.peerOverrides.Pagination,
            disabled: this.loading
          }, this.mergedPagination))) : null, vue.h(vue.Transition, {
            name: "fade-in-scale-up-transition"
          }, {
            default: () => {
              return this.loading ? vue.h("div", {
                class: `${mergedClsPrefix}-data-table-loading-wrapper`
              }, resolveSlot($slots.loading, () => [vue.h(NBaseLoading, Object.assign({
                clsPrefix: mergedClsPrefix,
                strokeWidth: 20
              }, spinProps))])) : null;
            }
          }));
        }
      });
      const dialogProviderInjectionKey = createInjectionKey("n-dialog-provider");
      const dialogApiInjectionKey = createInjectionKey("n-dialog-api");
      const dialogReactiveListInjectionKey = createInjectionKey("n-dialog-reactive-list");
      function useDialog() {
        const dialog = vue.inject(dialogApiInjectionKey, null);
        if (dialog === null) {
          throwError("use-dialog", "No outer <n-dialog-provider /> founded.");
        }
        return dialog;
      }
      const commonVars$5 = {
        titleFontSize: "18px",
        padding: "16px 28px 20px 28px",
        iconSize: "28px",
        actionSpace: "12px",
        contentMargin: "8px 0 16px 0",
        iconMargin: "0 4px 0 0",
        iconMarginIconTop: "4px 0 8px 0",
        closeSize: "22px",
        closeIconSize: "18px",
        closeMargin: "20px 26px 0 0",
        closeMarginIconTop: "10px 16px 0 0"
      };
      function self$b(vars) {
        const {
          textColor1,
          textColor2,
          modalColor,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          infoColor,
          successColor,
          warningColor,
          errorColor,
          primaryColor,
          dividerColor,
          borderRadius,
          fontWeightStrong,
          lineHeight: lineHeight2,
          fontSize: fontSize2
        } = vars;
        return Object.assign(Object.assign({}, commonVars$5), {
          fontSize: fontSize2,
          lineHeight: lineHeight2,
          border: `1px solid ${dividerColor}`,
          titleTextColor: textColor1,
          textColor: textColor2,
          color: modalColor,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeBorderRadius: borderRadius,
          iconColor: primaryColor,
          iconColorInfo: infoColor,
          iconColorSuccess: successColor,
          iconColorWarning: warningColor,
          iconColorError: errorColor,
          borderRadius,
          titleFontWeight: fontWeightStrong
        });
      }
      const dialogLight = createTheme({
        name: "Dialog",
        common: derived,
        peers: {
          Button: buttonLight
        },
        self: self$b
      });
      const dialogProps = {
        icon: Function,
        type: {
          type: String,
          default: "default"
        },
        title: [String, Function],
        closable: {
          type: Boolean,
          default: true
        },
        negativeText: String,
        positiveText: String,
        positiveButtonProps: Object,
        negativeButtonProps: Object,
        content: [String, Function],
        action: Function,
        showIcon: {
          type: Boolean,
          default: true
        },
        loading: Boolean,
        bordered: Boolean,
        iconPlacement: String,
        titleClass: [String, Array],
        titleStyle: [String, Object],
        contentClass: [String, Array],
        contentStyle: [String, Object],
        actionClass: [String, Array],
        actionStyle: [String, Object],
        onPositiveClick: Function,
        onNegativeClick: Function,
        onClose: Function,
        closeFocusable: Boolean
      };
      const dialogPropKeys = keysOf(dialogProps);
      const style$9 = c$1([cB("dialog", `
 --n-icon-margin: var(--n-icon-margin-top) var(--n-icon-margin-right) var(--n-icon-margin-bottom) var(--n-icon-margin-left);
 word-break: break-word;
 line-height: var(--n-line-height);
 position: relative;
 background: var(--n-color);
 color: var(--n-text-color);
 box-sizing: border-box;
 margin: auto;
 border-radius: var(--n-border-radius);
 padding: var(--n-padding);
 transition: 
 border-color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `, [cE("icon", {
        color: "var(--n-icon-color)"
      }), cM("bordered", {
        border: "var(--n-border)"
      }), cM("icon-top", [cE("close", {
        margin: "var(--n-close-margin)"
      }), cE("icon", {
        margin: "var(--n-icon-margin)"
      }), cE("content", {
        textAlign: "center"
      }), cE("title", {
        justifyContent: "center"
      }), cE("action", {
        justifyContent: "center"
      })]), cM("icon-left", [cE("icon", {
        margin: "var(--n-icon-margin)"
      }), cM("closable", [cE("title", `
 padding-right: calc(var(--n-close-size) + 6px);
 `)])]), cE("close", `
 position: absolute;
 right: 0;
 top: 0;
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 z-index: 1;
 `), cE("content", `
 font-size: var(--n-font-size);
 margin: var(--n-content-margin);
 position: relative;
 word-break: break-word;
 `, [cM("last", "margin-bottom: 0;")]), cE("action", `
 display: flex;
 justify-content: flex-end;
 `, [c$1("> *:not(:last-child)", `
 margin-right: var(--n-action-space);
 `)]), cE("icon", `
 font-size: var(--n-icon-size);
 transition: color .3s var(--n-bezier);
 `), cE("title", `
 transition: color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 font-size: var(--n-title-font-size);
 font-weight: var(--n-title-font-weight);
 color: var(--n-title-text-color);
 `), cB("dialog-icon-container", `
 display: flex;
 justify-content: center;
 `)]), insideModal(cB("dialog", `
 width: 446px;
 max-width: calc(100vw - 32px);
 `)), cB("dialog", [asModal(`
 width: 446px;
 max-width: calc(100vw - 32px);
 `)])]);
      const iconRenderMap$2 = {
        default: () => vue.h(InfoIcon, null),
        info: () => vue.h(InfoIcon, null),
        success: () => vue.h(SuccessIcon, null),
        warning: () => vue.h(WarningIcon, null),
        error: () => vue.h(ErrorIcon, null)
      };
      const NDialog = vue.defineComponent({
        name: "Dialog",
        alias: [
          "NimbusConfirmCard",
"Confirm"
],
        props: Object.assign(Object.assign({}, useTheme.props), dialogProps),
        slots: Object,
        setup(props) {
          const {
            mergedComponentPropsRef,
            mergedClsPrefixRef,
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const rtlEnabledRef = useRtl("Dialog", mergedRtlRef, mergedClsPrefixRef);
          const mergedIconPlacementRef = vue.computed(() => {
            var _a, _b;
            const {
              iconPlacement
            } = props;
            return iconPlacement || ((_b = (_a = mergedComponentPropsRef === null || mergedComponentPropsRef === void 0 ? void 0 : mergedComponentPropsRef.value) === null || _a === void 0 ? void 0 : _a.Dialog) === null || _b === void 0 ? void 0 : _b.iconPlacement) || "left";
          });
          function handlePositiveClick(e) {
            const {
              onPositiveClick
            } = props;
            if (onPositiveClick) onPositiveClick(e);
          }
          function handleNegativeClick(e) {
            const {
              onNegativeClick
            } = props;
            if (onNegativeClick) onNegativeClick(e);
          }
          function handleCloseClick() {
            const {
              onClose
            } = props;
            if (onClose) onClose();
          }
          const themeRef = useTheme("Dialog", "-dialog", style$9, dialogLight, props, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              type
            } = props;
            const iconPlacement = mergedIconPlacementRef.value;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                fontSize: fontSize2,
                lineHeight: lineHeight2,
                border,
                titleTextColor,
                textColor,
                color,
                closeBorderRadius,
                closeColorHover,
                closeColorPressed,
                closeIconColor,
                closeIconColorHover,
                closeIconColorPressed,
                closeIconSize,
                borderRadius,
                titleFontWeight,
                titleFontSize,
                padding,
                iconSize,
                actionSpace,
                contentMargin,
                closeSize,
                [iconPlacement === "top" ? "iconMarginIconTop" : "iconMargin"]: iconMargin,
                [iconPlacement === "top" ? "closeMarginIconTop" : "closeMargin"]: closeMargin,
                [createKey("iconColor", type)]: iconColor
              }
            } = themeRef.value;
            const iconMarginDiscrete = getMargin(iconMargin);
            return {
              "--n-font-size": fontSize2,
              "--n-icon-color": iconColor,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-close-margin": closeMargin,
              "--n-icon-margin-top": iconMarginDiscrete.top,
              "--n-icon-margin-right": iconMarginDiscrete.right,
              "--n-icon-margin-bottom": iconMarginDiscrete.bottom,
              "--n-icon-margin-left": iconMarginDiscrete.left,
              "--n-icon-size": iconSize,
              "--n-close-size": closeSize,
              "--n-close-icon-size": closeIconSize,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-color": color,
              "--n-text-color": textColor,
              "--n-border-radius": borderRadius,
              "--n-padding": padding,
              "--n-line-height": lineHeight2,
              "--n-border": border,
              "--n-content-margin": contentMargin,
              "--n-title-font-size": titleFontSize,
              "--n-title-font-weight": titleFontWeight,
              "--n-title-text-color": titleTextColor,
              "--n-action-space": actionSpace
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("dialog", vue.computed(() => `${props.type[0]}${mergedIconPlacementRef.value[0]}`), cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            mergedIconPlacement: mergedIconPlacementRef,
            mergedTheme: themeRef,
            handlePositiveClick,
            handleNegativeClick,
            handleCloseClick,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const {
            bordered,
            mergedIconPlacement,
            cssVars,
            closable,
            showIcon,
            title,
            content,
            action,
            negativeText,
            positiveText,
            positiveButtonProps,
            negativeButtonProps,
            handlePositiveClick,
            handleNegativeClick,
            mergedTheme,
            loading,
            type,
            mergedClsPrefix
          } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          const icon = showIcon ? vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-dialog__icon`
          }, {
            default: () => resolveWrappedSlot(this.$slots.icon, (children) => children || (this.icon ? render(this.icon) : iconRenderMap$2[this.type]()))
          }) : null;
          const actionNode = resolveWrappedSlot(this.$slots.action, (children) => children || positiveText || negativeText || action ? vue.h("div", {
            class: [`${mergedClsPrefix}-dialog__action`, this.actionClass],
            style: this.actionStyle
          }, children || (action ? [render(action)] : [this.negativeText && vue.h(Button, Object.assign({
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button,
            ghost: true,
            size: "small",
            onClick: handleNegativeClick
          }, negativeButtonProps), {
            default: () => render(this.negativeText)
          }), this.positiveText && vue.h(Button, Object.assign({
            theme: mergedTheme.peers.Button,
            themeOverrides: mergedTheme.peerOverrides.Button,
            size: "small",
            type: type === "default" ? "primary" : type,
            disabled: loading,
            loading,
            onClick: handlePositiveClick
          }, positiveButtonProps), {
            default: () => render(this.positiveText)
          })])) : null);
          return vue.h("div", {
            class: [`${mergedClsPrefix}-dialog`, this.themeClass, this.closable && `${mergedClsPrefix}-dialog--closable`, `${mergedClsPrefix}-dialog--icon-${mergedIconPlacement}`, bordered && `${mergedClsPrefix}-dialog--bordered`, this.rtlEnabled && `${mergedClsPrefix}-dialog--rtl`],
            style: cssVars,
            role: "dialog"
          }, closable ? resolveWrappedSlot(this.$slots.close, (node) => {
            const classNames = [`${mergedClsPrefix}-dialog__close`, this.rtlEnabled && `${mergedClsPrefix}-dialog--rtl`];
            return node ? vue.h("div", {
              class: classNames
            }, node) : vue.h(NBaseClose, {
              focusable: this.closeFocusable,
              clsPrefix: mergedClsPrefix,
              class: classNames,
              onClick: this.handleCloseClick
            });
          }) : null, showIcon && mergedIconPlacement === "top" ? vue.h("div", {
            class: `${mergedClsPrefix}-dialog-icon-container`
          }, icon) : null, vue.h("div", {
            class: [`${mergedClsPrefix}-dialog__title`, this.titleClass],
            style: this.titleStyle
          }, showIcon && mergedIconPlacement === "left" ? icon : null, resolveSlot(this.$slots.header, () => [render(title)])), vue.h("div", {
            class: [`${mergedClsPrefix}-dialog__content`, actionNode ? "" : `${mergedClsPrefix}-dialog__content--last`, this.contentClass],
            style: this.contentStyle
          }, resolveSlot(this.$slots.default, () => [render(content)])), actionNode);
        }
      });
      function self$a(vars) {
        const {
          modalColor,
          textColor2,
          boxShadow3
        } = vars;
        return {
          color: modalColor,
          textColor: textColor2,
          boxShadow: boxShadow3
        };
      }
      const modalLight = createTheme({
        name: "Modal",
        common: derived,
        peers: {
          Scrollbar: scrollbarLight,
          Dialog: dialogLight,
          Card: cardLight
        },
        self: self$a
      });
      const modalProviderInjectionKey = createInjectionKey("n-modal-provider");
      const modalApiInjectionKey = createInjectionKey("n-modal-api");
      const modalReactiveListInjectionKey = createInjectionKey("n-modal-reactive-list");
      function useModal() {
        const modal = vue.inject(modalApiInjectionKey, null);
        if (modal === null) {
          throwError("use-modal", "No outer <n-modal-provider /> founded.");
        }
        return modal;
      }
      const DRAGGABLE_CLASS = "n-draggable";
      function useDragModal(draggablePropsRef, options) {
        let cleanup;
        const draggableRef = vue.computed(() => {
          return draggablePropsRef.value !== false;
        });
        const draggableClassRef = vue.computed(() => {
          return draggableRef.value ? DRAGGABLE_CLASS : "";
        });
        const boundsToWindowRef = vue.computed(() => {
          const draggableProps = draggablePropsRef.value;
          if (draggableProps === true || draggableProps === false) {
            return true;
          } else if (draggableProps) {
            return draggableProps.bounds !== "none";
          } else {
            return true;
          }
        });
        function startDrag(modal) {
          const header = modal.querySelector(`.${DRAGGABLE_CLASS}`);
          if (!header || !draggableClassRef.value) {
            return;
          }
          let maxMoveX = 0;
          let minMoveX = 0;
          let maxMoveY = 0;
          let minMoveY = 0;
          let prevMoveY = 0;
          let prevMoveX = 0;
          let mousedownEvent;
          function handleMouseDown(event) {
            event.preventDefault();
            mousedownEvent = event;
            const {
              x,
              y,
              right,
              bottom
            } = modal.getBoundingClientRect();
            minMoveX = x;
            minMoveY = y;
            maxMoveX = window.innerWidth - right;
            maxMoveY = window.innerHeight - bottom;
            const {
              left,
              top
            } = modal.style;
            prevMoveY = +top.slice(0, -2);
            prevMoveX = +left.slice(0, -2);
          }
          function handleMouseMove(event) {
            if (!mousedownEvent) return;
            const {
              clientX: downX,
              clientY: downY
            } = mousedownEvent;
            let moveX = event.clientX - downX;
            let moveY = event.clientY - downY;
            if (boundsToWindowRef.value) {
              if (moveX > maxMoveX) {
                moveX = maxMoveX;
              } else if (-moveX > minMoveX) {
                moveX = -minMoveX;
              }
              if (moveY > maxMoveY) {
                moveY = maxMoveY;
              } else if (-moveY > minMoveY) {
                moveY = -minMoveY;
              }
            }
            const x = moveX + prevMoveX;
            const y = moveY + prevMoveY;
            modal.style.top = `${y}px`;
            modal.style.left = `${x}px`;
          }
          function handleMouseUp() {
            mousedownEvent = void 0;
            options.onEnd(modal);
          }
          on("mousedown", header, handleMouseDown);
          on("mousemove", window, handleMouseMove);
          on("mouseup", window, handleMouseUp);
          cleanup = () => {
            off("mousedown", header, handleMouseDown);
            on("mousemove", window, handleMouseMove);
            on("mouseup", window, handleMouseUp);
          };
        }
        function stopDrag() {
          if (cleanup) {
            cleanup();
            cleanup = void 0;
          }
        }
        vue.onUnmounted(stopDrag);
        return {
          stopDrag,
          startDrag,
          draggableRef,
          draggableClassRef
        };
      }
      const presetProps = Object.assign(Object.assign({}, cardBaseProps), dialogProps);
      const presetPropsKeys = keysOf(presetProps);
      const NModalBodyWrapper = vue.defineComponent({
        name: "ModalBody",
        inheritAttrs: false,
        slots: Object,
        props: Object.assign(Object.assign({
          show: {
            type: Boolean,
            required: true
          },
          preset: String,
          displayDirective: {
            type: String,
            required: true
          },
          trapFocus: {
            type: Boolean,
            default: true
          },
          autoFocus: {
            type: Boolean,
            default: true
          },
          blockScroll: Boolean,
          draggable: {
            type: [Boolean, Object],
            default: false
          },
          maskHidden: Boolean
        }, presetProps), {
          renderMask: Function,
onClickoutside: Function,
          onBeforeLeave: {
            type: Function,
            required: true
          },
          onAfterLeave: {
            type: Function,
            required: true
          },
          onPositiveClick: {
            type: Function,
            required: true
          },
          onNegativeClick: {
            type: Function,
            required: true
          },
          onClose: {
            type: Function,
            required: true
          },
          onAfterEnter: Function,
          onEsc: Function
        }),
        setup(props) {
          const bodyRef = vue.ref(null);
          const scrollbarRef = vue.ref(null);
          const displayedRef = vue.ref(props.show);
          const transformOriginXRef = vue.ref(null);
          const transformOriginYRef = vue.ref(null);
          const NModal2 = vue.inject(modalInjectionKey);
          let mousePosition = null;
          vue.watch(vue.toRef(props, "show"), (value) => {
            if (value) {
              mousePosition = NModal2.getMousePosition();
            }
          }, {
            immediate: true
          });
          const {
            stopDrag,
            startDrag,
            draggableRef,
            draggableClassRef
          } = useDragModal(vue.toRef(props, "draggable"), {
            onEnd: (el) => {
              syncTransformOrigin(el);
            }
          });
          const dialogTitleClassRef = vue.computed(() => {
            return vue.normalizeClass([props.titleClass, draggableClassRef.value]);
          });
          const cardHeaderClassRef = vue.computed(() => {
            return vue.normalizeClass([props.headerClass, draggableClassRef.value]);
          });
          vue.watch(vue.toRef(props, "show"), (value) => {
            if (value) displayedRef.value = true;
          });
          useLockHtmlScroll(vue.computed(() => props.blockScroll && displayedRef.value));
          function styleTransformOrigin() {
            if (NModal2.transformOriginRef.value === "center") {
              return "";
            }
            const {
              value: transformOriginX
            } = transformOriginXRef;
            const {
              value: transformOriginY
            } = transformOriginYRef;
            if (transformOriginX === null || transformOriginY === null) {
              return "";
            } else if (scrollbarRef.value) {
              const scrollTop = scrollbarRef.value.containerScrollTop;
              return `${transformOriginX}px ${transformOriginY + scrollTop}px`;
            }
            return "";
          }
          function syncTransformOrigin(el) {
            if (NModal2.transformOriginRef.value === "center") {
              return;
            }
            if (!mousePosition) {
              return;
            }
            if (!scrollbarRef.value) return;
            const scrollTop = scrollbarRef.value.containerScrollTop;
            const {
              offsetLeft,
              offsetTop
            } = el;
            const top = mousePosition.y;
            const left = mousePosition.x;
            transformOriginXRef.value = -(offsetLeft - left);
            transformOriginYRef.value = -(offsetTop - top - scrollTop);
            el.style.transformOrigin = styleTransformOrigin();
          }
          function handleEnter(el) {
            void vue.nextTick(() => {
              syncTransformOrigin(el);
            });
          }
          function handleBeforeLeave(el) {
            el.style.transformOrigin = styleTransformOrigin();
            props.onBeforeLeave();
          }
          function handleAfterEnter(el) {
            const element = el;
            draggableRef.value && startDrag(element);
            props.onAfterEnter && props.onAfterEnter(element);
          }
          function handleAfterLeave() {
            displayedRef.value = false;
            transformOriginXRef.value = null;
            transformOriginYRef.value = null;
            stopDrag();
            props.onAfterLeave();
          }
          function handleCloseClick() {
            const {
              onClose
            } = props;
            if (onClose) {
              onClose();
            }
          }
          function handleNegativeClick() {
            props.onNegativeClick();
          }
          function handlePositiveClick() {
            props.onPositiveClick();
          }
          const childNodeRef = vue.ref(null);
          vue.watch(childNodeRef, (node) => {
            if (node) {
              void vue.nextTick(() => {
                const el = node.el;
                if (el && bodyRef.value !== el) {
                  bodyRef.value = el;
                }
              });
            }
          });
          vue.provide(modalBodyInjectionKey, bodyRef);
          vue.provide(drawerBodyInjectionKey, null);
          vue.provide(popoverBodyInjectionKey, null);
          return {
            mergedTheme: NModal2.mergedThemeRef,
            appear: NModal2.appearRef,
            isMounted: NModal2.isMountedRef,
            mergedClsPrefix: NModal2.mergedClsPrefixRef,
            bodyRef,
            scrollbarRef,
            draggableClass: draggableClassRef,
            displayed: displayedRef,
            childNodeRef,
            cardHeaderClass: cardHeaderClassRef,
            dialogTitleClass: dialogTitleClassRef,
            handlePositiveClick,
            handleNegativeClick,
            handleCloseClick,
            handleAfterEnter,
            handleAfterLeave,
            handleBeforeLeave,
            handleEnter
          };
        },
        render() {
          const {
            $slots,
            $attrs,
            handleEnter,
            handleAfterEnter,
            handleAfterLeave,
            handleBeforeLeave,
            preset,
            mergedClsPrefix
          } = this;
          let childNode = null;
          if (!preset) {
            childNode = getFirstSlotVNodeWithTypedProps("default", $slots.default, {
              draggableClass: this.draggableClass
            });
            if (!childNode) {
              warn("modal", "default slot is empty");
              return;
            }
            childNode = vue.cloneVNode(childNode);
            childNode.props = vue.mergeProps({
              class: `${mergedClsPrefix}-modal`
            }, $attrs, childNode.props || {});
          }
          return this.displayDirective === "show" || this.displayed || this.show ? vue.withDirectives(vue.h("div", {
            role: "none",
            class: [`${mergedClsPrefix}-modal-body-wrapper`, this.maskHidden && `${mergedClsPrefix}-modal-body-wrapper--mask-hidden`]
          }, vue.h(Scrollbar, {
            ref: "scrollbarRef",
            theme: this.mergedTheme.peers.Scrollbar,
            themeOverrides: this.mergedTheme.peerOverrides.Scrollbar,
            contentClass: `${mergedClsPrefix}-modal-scroll-content`
          }, {
            default: () => {
              var _a;
              return [(_a = this.renderMask) === null || _a === void 0 ? void 0 : _a.call(this), vue.h(FocusTrap, {
                disabled: !this.trapFocus || this.maskHidden,
                active: this.show,
                onEsc: this.onEsc,
                autoFocus: this.autoFocus
              }, {
                default: () => {
                  var _a2;
                  return vue.h(vue.Transition, {
                    name: "fade-in-scale-up-transition",
                    appear: (_a2 = this.appear) !== null && _a2 !== void 0 ? _a2 : this.isMounted,
                    onEnter: handleEnter,
                    onAfterEnter: handleAfterEnter,
                    onAfterLeave: handleAfterLeave,
                    onBeforeLeave: handleBeforeLeave
                  }, {
                    default: () => {
                      const dirs = [[vue.vShow, this.show]];
                      const {
                        onClickoutside
                      } = this;
                      if (onClickoutside) {
                        dirs.push([clickoutside, this.onClickoutside, void 0, {
                          capture: true
                        }]);
                      }
                      return vue.withDirectives(this.preset === "confirm" || this.preset === "dialog" ? vue.h(NDialog, Object.assign({}, this.$attrs, {
                        class: [`${mergedClsPrefix}-modal`, this.$attrs.class],
                        ref: "bodyRef",
                        theme: this.mergedTheme.peers.Dialog,
                        themeOverrides: this.mergedTheme.peerOverrides.Dialog
                      }, keep(this.$props, dialogPropKeys), {
                        titleClass: this.dialogTitleClass,
                        "aria-modal": "true"
                      }), $slots) : this.preset === "card" ? vue.h(NCard, Object.assign({}, this.$attrs, {
                        ref: "bodyRef",
                        class: [`${mergedClsPrefix}-modal`, this.$attrs.class],
                        theme: this.mergedTheme.peers.Card,
                        themeOverrides: this.mergedTheme.peerOverrides.Card
                      }, keep(this.$props, cardBasePropKeys), {
                        headerClass: this.cardHeaderClass,
                        "aria-modal": "true",
                        role: "dialog"
                      }), $slots) : this.childNodeRef = childNode, dirs);
                    }
                  });
                }
              })];
            }
          })), [[vue.vShow, this.displayDirective === "if" || this.displayed || this.show]]) : null;
        }
      });
      const style$8 = c$1([cB("modal-container", `
 position: fixed;
 left: 0;
 top: 0;
 height: 0;
 width: 0;
 display: flex;
 `), cB("modal-mask", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 background-color: rgba(0, 0, 0, .4);
 `, [fadeInTransition({
        enterDuration: ".25s",
        leaveDuration: ".25s",
        enterCubicBezier: "var(--n-bezier-ease-out)",
        leaveCubicBezier: "var(--n-bezier-ease-out)"
      })]), cB("modal-body-wrapper", `
 position: fixed;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 overflow: visible;
 `, [cB("modal-scroll-content", `
 min-height: 100%;
 display: flex;
 position: relative;
 `), cM("mask-hidden", `pointer-events: none;`, [c$1("> *", `
 pointer-events: all;
 `)])]), cB("modal", `
 position: relative;
 align-self: center;
 color: var(--n-text-color);
 margin: auto;
 box-shadow: var(--n-box-shadow);
 `, [fadeInScaleUpTransition({
        duration: ".25s",
        enterScale: ".5"
      }), c$1(`.${DRAGGABLE_CLASS}`, `
 cursor: move;
 user-select: none;
 `)])]);
      const modalProps = Object.assign(Object.assign(Object.assign(Object.assign({}, useTheme.props), {
        show: Boolean,
        showMask: {
          type: Boolean,
          default: true
        },
        maskClosable: {
          type: Boolean,
          default: true
        },
        preset: String,
        to: [String, Object],
        displayDirective: {
          type: String,
          default: "if"
        },
        transformOrigin: {
          type: String,
          default: "mouse"
        },
        zIndex: Number,
        autoFocus: {
          type: Boolean,
          default: true
        },
        trapFocus: {
          type: Boolean,
          default: true
        },
        closeOnEsc: {
          type: Boolean,
          default: true
        },
        blockScroll: {
          type: Boolean,
          default: true
        }
      }), presetProps), {
        draggable: [Boolean, Object],
onEsc: Function,
        "onUpdate:show": [Function, Array],
        onUpdateShow: [Function, Array],
        onAfterEnter: Function,
        onBeforeLeave: Function,
        onAfterLeave: Function,
        onClose: Function,
        onPositiveClick: Function,
        onNegativeClick: Function,
        onMaskClick: Function,
internalDialog: Boolean,
        internalModal: Boolean,
        internalAppear: {
          type: Boolean,
          default: void 0
        },
overlayStyle: [String, Object],
        onBeforeHide: Function,
        onAfterHide: Function,
        onHide: Function,
        unstableShowMask: {
          type: Boolean,
          default: void 0
        }
      });
      const NModal = vue.defineComponent({
        name: "Modal",
        inheritAttrs: false,
        props: modalProps,
        slots: Object,
        setup(props) {
          const containerRef = vue.ref(null);
          const {
            mergedClsPrefixRef,
            namespaceRef,
            inlineThemeDisabled
          } = useConfig(props);
          const themeRef = useTheme("Modal", "-modal", style$8, modalLight, props, mergedClsPrefixRef);
          const clickedRef = useClicked(64);
          const clickedPositionRef = useClickPosition();
          const isMountedRef = isMounted();
          const NDialogProvider2 = props.internalDialog ? vue.inject(dialogProviderInjectionKey, null) : null;
          const NModalProvider2 = props.internalModal ? vue.inject(modalProviderInjectionKey$1, null) : null;
          const isComposingRef2 = useIsComposing();
          function doUpdateShow(show) {
            const {
              onUpdateShow,
              "onUpdate:show": _onUpdateShow,
              onHide
            } = props;
            if (onUpdateShow) call(onUpdateShow, show);
            if (_onUpdateShow) call(_onUpdateShow, show);
            if (onHide && !show) onHide(show);
          }
          function handleCloseClick() {
            const {
              onClose
            } = props;
            if (onClose) {
              void Promise.resolve(onClose()).then((value) => {
                if (value === false) return;
                doUpdateShow(false);
              });
            } else {
              doUpdateShow(false);
            }
          }
          function handlePositiveClick() {
            const {
              onPositiveClick
            } = props;
            if (onPositiveClick) {
              void Promise.resolve(onPositiveClick()).then((value) => {
                if (value === false) return;
                doUpdateShow(false);
              });
            } else {
              doUpdateShow(false);
            }
          }
          function handleNegativeClick() {
            const {
              onNegativeClick
            } = props;
            if (onNegativeClick) {
              void Promise.resolve(onNegativeClick()).then((value) => {
                if (value === false) return;
                doUpdateShow(false);
              });
            } else {
              doUpdateShow(false);
            }
          }
          function handleBeforeLeave() {
            const {
              onBeforeLeave,
              onBeforeHide
            } = props;
            if (onBeforeLeave) call(onBeforeLeave);
            if (onBeforeHide) onBeforeHide();
          }
          function handleAfterLeave() {
            const {
              onAfterLeave,
              onAfterHide
            } = props;
            if (onAfterLeave) call(onAfterLeave);
            if (onAfterHide) onAfterHide();
          }
          function handleClickoutside(e) {
            var _a;
            const {
              onMaskClick
            } = props;
            if (onMaskClick) {
              onMaskClick(e);
            }
            if (props.maskClosable) {
              if ((_a = containerRef.value) === null || _a === void 0 ? void 0 : _a.contains(getPreciseEventTarget(e))) {
                doUpdateShow(false);
              }
            }
          }
          function handleEsc(e) {
            var _a;
            (_a = props.onEsc) === null || _a === void 0 ? void 0 : _a.call(props);
            if (props.show && props.closeOnEsc && eventEffectNotPerformed(e)) {
              if (!isComposingRef2.value) {
                doUpdateShow(false);
              }
            }
          }
          vue.provide(modalInjectionKey, {
            getMousePosition: () => {
              const mergedProvider = NDialogProvider2 || NModalProvider2;
              if (mergedProvider) {
                const {
                  clickedRef: clickedRef2,
                  clickedPositionRef: clickedPositionRef2
                } = mergedProvider;
                if (clickedRef2.value && clickedPositionRef2.value) {
                  return clickedPositionRef2.value;
                }
              }
              if (clickedRef.value) {
                return clickedPositionRef.value;
              }
              return null;
            },
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            isMountedRef,
            appearRef: vue.toRef(props, "internalAppear"),
            transformOriginRef: vue.toRef(props, "transformOrigin")
          });
          const cssVarsRef = vue.computed(() => {
            const {
              common: {
                cubicBezierEaseOut: cubicBezierEaseOut2
              },
              self: {
                boxShadow,
                color,
                textColor
              }
            } = themeRef.value;
            return {
              "--n-bezier-ease-out": cubicBezierEaseOut2,
              "--n-box-shadow": boxShadow,
              "--n-color": color,
              "--n-text-color": textColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("theme-class", void 0, cssVarsRef, props) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            namespace: namespaceRef,
            isMounted: isMountedRef,
            containerRef,
            presetProps: vue.computed(() => {
              const pickedProps = keep(props, presetPropsKeys);
              return pickedProps;
            }),
            handleEsc,
            handleAfterLeave,
            handleClickoutside,
            handleBeforeLeave,
            doUpdateShow,
            handleNegativeClick,
            handlePositiveClick,
            handleCloseClick,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const {
            mergedClsPrefix
          } = this;
          return vue.h(LazyTeleport, {
            to: this.to,
            show: this.show
          }, {
            default: () => {
              var _a;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              const {
                showMask
              } = this;
              return vue.withDirectives(vue.h("div", {
                role: "none",
                ref: "containerRef",
                class: [`${mergedClsPrefix}-modal-container`, this.themeClass, this.namespace],
                style: this.cssVars
              }, vue.h(NModalBodyWrapper, Object.assign({
                style: this.overlayStyle
              }, this.$attrs, {
                ref: "bodyWrapper",
                displayDirective: this.displayDirective,
                show: this.show,
                preset: this.preset,
                autoFocus: this.autoFocus,
                trapFocus: this.trapFocus,
                draggable: this.draggable,
                blockScroll: this.blockScroll,
                maskHidden: !showMask
              }, this.presetProps, {
                onEsc: this.handleEsc,
                onClose: this.handleCloseClick,
                onNegativeClick: this.handleNegativeClick,
                onPositiveClick: this.handlePositiveClick,
                onBeforeLeave: this.handleBeforeLeave,
                onAfterEnter: this.onAfterEnter,
                onAfterLeave: this.handleAfterLeave,
                onClickoutside: showMask ? void 0 : this.handleClickoutside,
                renderMask: showMask ? () => {
                  var _a2;
                  return vue.h(vue.Transition, {
                    name: "fade-in-transition",
                    key: "mask",
                    appear: (_a2 = this.internalAppear) !== null && _a2 !== void 0 ? _a2 : this.isMounted
                  }, {
                    default: () => {
                      return this.show ? vue.h("div", {
                        "aria-hidden": true,
                        ref: "containerRef",
                        class: `${mergedClsPrefix}-modal-mask`,
                        onClick: this.handleClickoutside
                      }) : null;
                    }
                  });
                } : void 0
              }), this.$slots)), [[zindexable, {
                zIndex: this.zIndex,
                enabled: this.show
              }]]);
            }
          });
        }
      });
      const exposedDialogEnvProps = Object.assign(Object.assign({}, dialogProps), {
        onAfterEnter: Function,
        onAfterLeave: Function,
        transformOrigin: String,
        blockScroll: {
          type: Boolean,
          default: true
        },
        closeOnEsc: {
          type: Boolean,
          default: true
        },
        onEsc: Function,
        autoFocus: {
          type: Boolean,
          default: true
        },
        internalStyle: [String, Object],
        maskClosable: {
          type: Boolean,
          default: true
        },
        zIndex: Number,
        onPositiveClick: Function,
        onNegativeClick: Function,
        onClose: Function,
        onMaskClick: Function,
        draggable: [Boolean, Object]
      });
      const NDialogEnvironment = vue.defineComponent({
        name: "DialogEnvironment",
        props: Object.assign(Object.assign({}, exposedDialogEnvProps), {
          internalKey: {
            type: String,
            required: true
          },
          to: [String, Object],
onInternalAfterLeave: {
            type: Function,
            required: true
          }
        }),
        setup(props) {
          const showRef = vue.ref(true);
          function handleAfterLeave() {
            const {
              onInternalAfterLeave,
              internalKey,
              onAfterLeave
            } = props;
            if (onInternalAfterLeave) onInternalAfterLeave(internalKey);
            if (onAfterLeave) onAfterLeave();
          }
          function handlePositiveClick(e) {
            const {
              onPositiveClick
            } = props;
            if (onPositiveClick) {
              void Promise.resolve(onPositiveClick(e)).then((result) => {
                if (result === false) return;
                hide();
              });
            } else {
              hide();
            }
          }
          function handleNegativeClick(e) {
            const {
              onNegativeClick
            } = props;
            if (onNegativeClick) {
              void Promise.resolve(onNegativeClick(e)).then((result) => {
                if (result === false) return;
                hide();
              });
            } else {
              hide();
            }
          }
          function handleCloseClick() {
            const {
              onClose
            } = props;
            if (onClose) {
              void Promise.resolve(onClose()).then((result) => {
                if (result === false) return;
                hide();
              });
            } else {
              hide();
            }
          }
          function handleMaskClick(e) {
            const {
              onMaskClick,
              maskClosable
            } = props;
            if (onMaskClick) {
              onMaskClick(e);
              if (maskClosable) {
                hide();
              }
            }
          }
          function handleEsc() {
            const {
              onEsc
            } = props;
            if (onEsc) {
              onEsc();
            }
          }
          function hide() {
            showRef.value = false;
          }
          function handleUpdateShow(value) {
            showRef.value = value;
          }
          return {
            show: showRef,
            hide,
            handleUpdateShow,
            handleAfterLeave,
            handleCloseClick,
            handleNegativeClick,
            handlePositiveClick,
            handleMaskClick,
            handleEsc
          };
        },
        render() {
          const {
            handlePositiveClick,
            handleUpdateShow,
            handleNegativeClick,
            handleCloseClick,
            handleAfterLeave,
            handleMaskClick,
            handleEsc,
            to,
            zIndex,
            maskClosable,
            show
          } = this;
          return vue.h(NModal, {
            show,
            onUpdateShow: handleUpdateShow,
            onMaskClick: handleMaskClick,
            onEsc: handleEsc,
            to,
            zIndex,
            maskClosable,
            onAfterEnter: this.onAfterEnter,
            onAfterLeave: handleAfterLeave,
            closeOnEsc: this.closeOnEsc,
            blockScroll: this.blockScroll,
            autoFocus: this.autoFocus,
            transformOrigin: this.transformOrigin,
            draggable: this.draggable,
            internalAppear: true,
            internalDialog: true
          }, {
            default: ({
              draggableClass
            }) => vue.h(NDialog, Object.assign({}, keep(this.$props, dialogPropKeys), {
              titleClass: vue.normalizeClass([this.titleClass, draggableClass]),
              style: this.internalStyle,
              onClose: handleCloseClick,
              onNegativeClick: handleNegativeClick,
              onPositiveClick: handlePositiveClick
            }))
          });
        }
      });
      const dialogProviderProps = {
        injectionKey: String,
        to: [String, Object]
      };
      const NDialogProvider = vue.defineComponent({
        name: "DialogProvider",
        props: dialogProviderProps,
        setup() {
          const dialogListRef = vue.ref([]);
          const dialogInstRefs = {};
          function create(options = {}) {
            const key = createId();
            const dialogReactive = vue.reactive(Object.assign(Object.assign({}, options), {
              key,
              destroy: () => {
                var _a;
                (_a = dialogInstRefs[`n-dialog-${key}`]) === null || _a === void 0 ? void 0 : _a.hide();
              }
            }));
            dialogListRef.value.push(dialogReactive);
            return dialogReactive;
          }
          const typedApi = ["info", "success", "warning", "error"].map((type) => (options) => {
            return create(Object.assign(Object.assign({}, options), {
              type
            }));
          });
          function handleAfterLeave(key) {
            const {
              value: dialogList
            } = dialogListRef;
            dialogList.splice(dialogList.findIndex((dialog) => dialog.key === key), 1);
          }
          function destroyAll() {
            Object.values(dialogInstRefs).forEach((dialogInstRef) => {
              dialogInstRef === null || dialogInstRef === void 0 ? void 0 : dialogInstRef.hide();
            });
          }
          const api = {
            create,
            destroyAll,
            info: typedApi[0],
            success: typedApi[1],
            warning: typedApi[2],
            error: typedApi[3]
          };
          vue.provide(dialogApiInjectionKey, api);
          vue.provide(dialogProviderInjectionKey, {
            clickedRef: useClicked(64),
            clickedPositionRef: useClickPosition()
          });
          vue.provide(dialogReactiveListInjectionKey, dialogListRef);
          return Object.assign(Object.assign({}, api), {
            dialogList: dialogListRef,
            dialogInstRefs,
            handleAfterLeave
          });
        },
        render() {
          var _a, _b;
          return vue.h(vue.Fragment, null, [this.dialogList.map((dialog) => vue.h(NDialogEnvironment, omit(dialog, ["destroy", "style"], {
            internalStyle: dialog.style,
            to: this.to,
            ref: (inst) => {
              if (inst === null) {
                delete this.dialogInstRefs[`n-dialog-${dialog.key}`];
              } else {
                this.dialogInstRefs[`n-dialog-${dialog.key}`] = inst;
              }
            },
            internalKey: dialog.key,
            onInternalAfterLeave: this.handleAfterLeave
          }))), (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)]);
        }
      });
      const loadingBarProviderInjectionKey = createInjectionKey("n-loading-bar");
      const loadingBarApiInjectionKey = createInjectionKey("n-loading-bar-api");
      function self$9(vars) {
        const {
          primaryColor,
          errorColor
        } = vars;
        return {
          colorError: errorColor,
          colorLoading: primaryColor,
          height: "2px"
        };
      }
      const loadingBarLight = {
        common: derived,
        self: self$9
      };
      const style$7 = cB("loading-bar-container", `
 z-index: 5999;
 position: fixed;
 top: 0;
 left: 0;
 right: 0;
 height: 2px;
`, [fadeInTransition({
        enterDuration: "0.3s",
        leaveDuration: "0.8s"
      }), cB("loading-bar", `
 width: 100%;
 transition:
 max-width 4s linear,
 background .2s linear;
 height: var(--n-height);
 `, [cM("starting", `
 background: var(--n-color-loading);
 `), cM("finishing", `
 background: var(--n-color-loading);
 transition:
 max-width .2s linear,
 background .2s linear;
 `), cM("error", `
 background: var(--n-color-error);
 transition:
 max-width .2s linear,
 background .2s linear;
 `)])]);
      var __awaiter$2 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      function createClassName(status, clsPrefix) {
        return `${clsPrefix}-loading-bar ${clsPrefix}-loading-bar--${status}`;
      }
      const NLoadingBar = vue.defineComponent({
        name: "LoadingBar",
        props: {
          containerClass: String,
          containerStyle: [String, Object]
        },
        setup() {
          const {
            inlineThemeDisabled
          } = useConfig();
          const {
            props: providerProps,
            mergedClsPrefixRef
          } = vue.inject(loadingBarProviderInjectionKey);
          const loadingBarRef = vue.ref(null);
          const enteringRef = vue.ref(false);
          const startedRef = vue.ref(false);
          const loadingRef = vue.ref(false);
          const transitionDisabledRef = vue.ref(false);
          let finishing = false;
          const erroringRef = vue.ref(false);
          const mergedLoadingBarStyle = vue.computed(() => {
            const {
              loadingBarStyle
            } = providerProps;
            if (!loadingBarStyle) return "";
            return loadingBarStyle[erroringRef.value ? "error" : "loading"];
          });
          function init2() {
            return __awaiter$2(this, void 0, void 0, function* () {
              enteringRef.value = false;
              loadingRef.value = false;
              finishing = false;
              erroringRef.value = false;
              transitionDisabledRef.value = true;
              yield vue.nextTick();
              transitionDisabledRef.value = false;
            });
          }
          function start() {
            return __awaiter$2(this, arguments, void 0, function* (fromProgress = 0, toProgress = 80, status = "starting") {
              startedRef.value = true;
              yield init2();
              if (finishing) return;
              loadingRef.value = true;
              yield vue.nextTick();
              const el = loadingBarRef.value;
              if (!el) return;
              el.style.maxWidth = `${fromProgress}%`;
              el.style.transition = "none";
              void el.offsetWidth;
              el.className = createClassName(status, mergedClsPrefixRef.value);
              el.style.transition = "";
              el.style.maxWidth = `${toProgress}%`;
            });
          }
          function finish() {
            return __awaiter$2(this, void 0, void 0, function* () {
              if (finishing || erroringRef.value) return;
              if (startedRef.value) {
                yield vue.nextTick();
              }
              finishing = true;
              const el = loadingBarRef.value;
              if (!el) return;
              el.className = createClassName("finishing", mergedClsPrefixRef.value);
              el.style.maxWidth = "100%";
              void el.offsetWidth;
              loadingRef.value = false;
            });
          }
          function error() {
            if (finishing || erroringRef.value) return;
            if (!loadingRef.value) {
              void start(100, 100, "error").then(() => {
                erroringRef.value = true;
                const el = loadingBarRef.value;
                if (!el) return;
                el.className = createClassName("error", mergedClsPrefixRef.value);
                void el.offsetWidth;
                loadingRef.value = false;
              });
            } else {
              erroringRef.value = true;
              const el = loadingBarRef.value;
              if (!el) return;
              el.className = createClassName("error", mergedClsPrefixRef.value);
              el.style.maxWidth = "100%";
              void el.offsetWidth;
              loadingRef.value = false;
            }
          }
          function handleEnter() {
            enteringRef.value = true;
          }
          function handleAfterEnter() {
            enteringRef.value = false;
          }
          function handleAfterLeave() {
            return __awaiter$2(this, void 0, void 0, function* () {
              yield init2();
            });
          }
          const themeRef = useTheme("LoadingBar", "-loading-bar", style$7, loadingBarLight, providerProps, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              self: {
                height,
                colorError,
                colorLoading
              }
            } = themeRef.value;
            return {
              "--n-height": height,
              "--n-color-loading": colorLoading,
              "--n-color-error": colorError
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("loading-bar", void 0, cssVarsRef, providerProps) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            loadingBarRef,
            started: startedRef,
            loading: loadingRef,
            entering: enteringRef,
            transitionDisabled: transitionDisabledRef,
            start,
            error,
            finish,
            handleEnter,
            handleAfterEnter,
            handleAfterLeave,
            mergedLoadingBarStyle,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          if (!this.started) return null;
          const {
            mergedClsPrefix
          } = this;
          return vue.h(vue.Transition, {
            name: "fade-in-transition",
            appear: true,
            onEnter: this.handleEnter,
            onAfterEnter: this.handleAfterEnter,
            onAfterLeave: this.handleAfterLeave,
            css: !this.transitionDisabled
          }, {
            default: () => {
              var _a;
              (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
              return vue.withDirectives(vue.h("div", {
                class: [`${mergedClsPrefix}-loading-bar-container`, this.themeClass, this.containerClass],
                style: this.containerStyle
              }, vue.h("div", {
                ref: "loadingBarRef",
                class: [`${mergedClsPrefix}-loading-bar`],
                style: [this.cssVars, this.mergedLoadingBarStyle]
              })), [[vue.vShow, this.loading || !this.loading && this.entering]]);
            }
          });
        }
      });
      const loadingBarProviderProps = Object.assign(Object.assign({}, useTheme.props), {
        to: {
          type: [String, Object, Boolean],
          default: void 0
        },
        containerClass: String,
        containerStyle: [String, Object],
        loadingBarStyle: {
          type: Object
        }
      });
      const NLoadingBarProvider = vue.defineComponent({
        name: "LoadingBarProvider",
        props: loadingBarProviderProps,
        setup(props) {
          const isMountedRef = isMounted();
          const loadingBarRef = vue.ref(null);
          const methods = {
            start() {
              var _a;
              if (isMountedRef.value) {
                (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.start();
              } else {
                void vue.nextTick(() => {
                  var _a2;
                  (_a2 = loadingBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.start();
                });
              }
            },
            error() {
              var _a;
              if (isMountedRef.value) {
                (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.error();
              } else {
                void vue.nextTick(() => {
                  var _a2;
                  (_a2 = loadingBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.error();
                });
              }
            },
            finish() {
              var _a;
              if (isMountedRef.value) {
                (_a = loadingBarRef.value) === null || _a === void 0 ? void 0 : _a.finish();
              } else {
                void vue.nextTick(() => {
                  var _a2;
                  (_a2 = loadingBarRef.value) === null || _a2 === void 0 ? void 0 : _a2.finish();
                });
              }
            }
          };
          const {
            mergedClsPrefixRef
          } = useConfig(props);
          vue.provide(loadingBarApiInjectionKey, methods);
          vue.provide(loadingBarProviderInjectionKey, {
            props,
            mergedClsPrefixRef
          });
          return Object.assign(methods, {
            loadingBarRef
          });
        },
        render() {
          var _a, _b;
          return vue.h(vue.Fragment, null, vue.h(vue.Teleport, {
            disabled: this.to === false,
            to: this.to || "body"
          }, vue.h(NLoadingBar, {
            ref: "loadingBarRef",
            containerStyle: this.containerStyle,
            containerClass: this.containerClass
          })), (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a));
        }
      });
      function useLoadingBar() {
        const loadingBar = vue.inject(loadingBarApiInjectionKey, null);
        if (loadingBar === null) {
          throwError("use-loading-bar", "No outer <n-loading-bar-provider /> founded.");
        }
        return loadingBar;
      }
      const messageApiInjectionKey = createInjectionKey("n-message-api");
      const messageProviderInjectionKey = createInjectionKey("n-message-provider");
      const commonVariables$1 = {
        margin: "0 0 8px 0",
        padding: "10px 20px",
        maxWidth: "720px",
        minWidth: "420px",
        iconMargin: "0 10px 0 0",
        closeMargin: "0 0 0 10px",
        closeSize: "20px",
        closeIconSize: "16px",
        iconSize: "20px",
        fontSize: "14px"
      };
      function self$8(vars) {
        const {
          textColor2,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          infoColor,
          successColor,
          errorColor,
          warningColor,
          popoverColor,
          boxShadow2,
          primaryColor,
          lineHeight: lineHeight2,
          borderRadius,
          closeColorHover,
          closeColorPressed
        } = vars;
        return Object.assign(Object.assign({}, commonVariables$1), {
          closeBorderRadius: borderRadius,
          textColor: textColor2,
          textColorInfo: textColor2,
          textColorSuccess: textColor2,
          textColorError: textColor2,
          textColorWarning: textColor2,
          textColorLoading: textColor2,
          color: popoverColor,
          colorInfo: popoverColor,
          colorSuccess: popoverColor,
          colorError: popoverColor,
          colorWarning: popoverColor,
          colorLoading: popoverColor,
          boxShadow: boxShadow2,
          boxShadowInfo: boxShadow2,
          boxShadowSuccess: boxShadow2,
          boxShadowError: boxShadow2,
          boxShadowWarning: boxShadow2,
          boxShadowLoading: boxShadow2,
          iconColor: textColor2,
          iconColorInfo: infoColor,
          iconColorSuccess: successColor,
          iconColorWarning: warningColor,
          iconColorError: errorColor,
          iconColorLoading: primaryColor,
          closeColorHover,
          closeColorPressed,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHoverInfo: closeColorHover,
          closeColorPressedInfo: closeColorPressed,
          closeIconColorInfo: closeIconColor,
          closeIconColorHoverInfo: closeIconColorHover,
          closeIconColorPressedInfo: closeIconColorPressed,
          closeColorHoverSuccess: closeColorHover,
          closeColorPressedSuccess: closeColorPressed,
          closeIconColorSuccess: closeIconColor,
          closeIconColorHoverSuccess: closeIconColorHover,
          closeIconColorPressedSuccess: closeIconColorPressed,
          closeColorHoverError: closeColorHover,
          closeColorPressedError: closeColorPressed,
          closeIconColorError: closeIconColor,
          closeIconColorHoverError: closeIconColorHover,
          closeIconColorPressedError: closeIconColorPressed,
          closeColorHoverWarning: closeColorHover,
          closeColorPressedWarning: closeColorPressed,
          closeIconColorWarning: closeIconColor,
          closeIconColorHoverWarning: closeIconColorHover,
          closeIconColorPressedWarning: closeIconColorPressed,
          closeColorHoverLoading: closeColorHover,
          closeColorPressedLoading: closeColorPressed,
          closeIconColorLoading: closeIconColor,
          closeIconColorHoverLoading: closeIconColorHover,
          closeIconColorPressedLoading: closeIconColorPressed,
          loadingColor: primaryColor,
          lineHeight: lineHeight2,
          borderRadius,
          border: "0"
        });
      }
      const messageLight = {
        common: derived,
        self: self$8
      };
      const messageProps = {
        icon: Function,
        type: {
          type: String,
          default: "info"
        },
        content: [String, Number, Function],
        showIcon: {
          type: Boolean,
          default: true
        },
        closable: Boolean,
        keepAliveOnHover: Boolean,
        onClose: Function,
        onMouseenter: Function,
        onMouseleave: Function
      };
      const style$6 = c$1([cB("message-wrapper", `
 margin: var(--n-margin);
 z-index: 0;
 transform-origin: top center;
 display: flex;
 `, [fadeInHeightExpandTransition({
        overflow: "visible",
        originalTransition: "transform .3s var(--n-bezier)",
        enterToProps: {
          transform: "scale(1)"
        },
        leaveToProps: {
          transform: "scale(0.85)"
        }
      })]), cB("message", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 transition:
 color .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier),
 margin-bottom .3s var(--n-bezier);
 padding: var(--n-padding);
 border-radius: var(--n-border-radius);
 border: var(--n-border);
 flex-wrap: nowrap;
 overflow: hidden;
 max-width: var(--n-max-width);
 color: var(--n-text-color);
 background-color: var(--n-color);
 box-shadow: var(--n-box-shadow);
 `, [cE("content", `
 display: inline-block;
 line-height: var(--n-line-height);
 font-size: var(--n-font-size);
 `), cE("icon", `
 position: relative;
 margin: var(--n-icon-margin);
 height: var(--n-icon-size);
 width: var(--n-icon-size);
 font-size: var(--n-icon-size);
 flex-shrink: 0;
 `, [["default", "info", "success", "warning", "error", "loading"].map((type) => cM(`${type}-type`, [c$1("> *", `
 color: var(--n-icon-color-${type});
 transition: color .3s var(--n-bezier);
 `)])), c$1("> *", `
 position: absolute;
 left: 0;
 top: 0;
 right: 0;
 bottom: 0;
 `, [iconSwitchTransition()])]), cE("close", `
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 flex-shrink: 0;
 `, [c$1("&:hover", `
 color: var(--n-close-icon-color-hover);
 `), c$1("&:active", `
 color: var(--n-close-icon-color-pressed);
 `)])]), cB("message-container", `
 z-index: 6000;
 position: fixed;
 height: 0;
 overflow: visible;
 display: flex;
 flex-direction: column;
 align-items: center;
 `, [cM("top", `
 top: 12px;
 left: 0;
 right: 0;
 `), cM("top-left", `
 top: 12px;
 left: 12px;
 right: 0;
 align-items: flex-start;
 `), cM("top-right", `
 top: 12px;
 left: 0;
 right: 12px;
 align-items: flex-end;
 `), cM("bottom", `
 bottom: 4px;
 left: 0;
 right: 0;
 justify-content: flex-end;
 `), cM("bottom-left", `
 bottom: 4px;
 left: 12px;
 right: 0;
 justify-content: flex-end;
 align-items: flex-start;
 `), cM("bottom-right", `
 bottom: 4px;
 left: 0;
 right: 12px;
 justify-content: flex-end;
 align-items: flex-end;
 `)])]);
      const iconRenderMap$1 = {
        info: () => vue.h(InfoIcon, null),
        success: () => vue.h(SuccessIcon, null),
        warning: () => vue.h(WarningIcon, null),
        error: () => vue.h(ErrorIcon, null),
        default: () => null
      };
      const NMessage = vue.defineComponent({
        name: "Message",
        props: Object.assign(Object.assign({}, messageProps), {
          render: Function
        }),
        setup(props) {
          const {
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig(props);
          const {
            props: messageProviderProps2,
            mergedClsPrefixRef
          } = vue.inject(messageProviderInjectionKey);
          const rtlEnabledRef = useRtl("Message", mergedRtlRef, mergedClsPrefixRef);
          const themeRef = useTheme("Message", "-message", style$6, messageLight, messageProviderProps2, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              type
            } = props;
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                padding,
                margin,
                maxWidth,
                iconMargin,
                closeMargin,
                closeSize,
                iconSize,
                fontSize: fontSize2,
                lineHeight: lineHeight2,
                borderRadius,
                border,
                iconColorInfo,
                iconColorSuccess,
                iconColorWarning,
                iconColorError,
                iconColorLoading,
                closeIconSize,
                closeBorderRadius,
                [createKey("textColor", type)]: textColor,
                [createKey("boxShadow", type)]: boxShadow,
                [createKey("color", type)]: color,
                [createKey("closeColorHover", type)]: closeColorHover,
                [createKey("closeColorPressed", type)]: closeColorPressed,
                [createKey("closeIconColor", type)]: closeIconColor,
                [createKey("closeIconColorPressed", type)]: closeIconColorPressed,
                [createKey("closeIconColorHover", type)]: closeIconColorHover
              }
            } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-margin": margin,
              "--n-padding": padding,
              "--n-max-width": maxWidth,
              "--n-font-size": fontSize2,
              "--n-icon-margin": iconMargin,
              "--n-icon-size": iconSize,
              "--n-close-icon-size": closeIconSize,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-size": closeSize,
              "--n-close-margin": closeMargin,
              "--n-text-color": textColor,
              "--n-color": color,
              "--n-box-shadow": boxShadow,
              "--n-icon-color-info": iconColorInfo,
              "--n-icon-color-success": iconColorSuccess,
              "--n-icon-color-warning": iconColorWarning,
              "--n-icon-color-error": iconColorError,
              "--n-icon-color-loading": iconColorLoading,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-line-height": lineHeight2,
              "--n-border-radius": borderRadius,
              "--n-border": border
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("message", vue.computed(() => props.type[0]), cssVarsRef, {}) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            rtlEnabled: rtlEnabledRef,
            messageProviderProps: messageProviderProps2,
            handleClose() {
              var _a;
              (_a = props.onClose) === null || _a === void 0 ? void 0 : _a.call(props);
            },
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender,
            placement: messageProviderProps2.placement
          };
        },
        render() {
          const {
            render: renderMessage,
            type,
            closable,
            content,
            mergedClsPrefix,
            cssVars,
            themeClass,
            onRender,
            icon,
            handleClose,
            showIcon
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          let iconNode;
          return vue.h("div", {
            class: [`${mergedClsPrefix}-message-wrapper`, themeClass],
            onMouseenter: this.onMouseenter,
            onMouseleave: this.onMouseleave,
            style: [{
              alignItems: this.placement.startsWith("top") ? "flex-start" : "flex-end"
            }, cssVars]
          }, renderMessage ? renderMessage(this.$props) : vue.h("div", {
            class: [`${mergedClsPrefix}-message ${mergedClsPrefix}-message--${type}-type`, this.rtlEnabled && `${mergedClsPrefix}-message--rtl`]
          }, (iconNode = createIconVNode(icon, type, mergedClsPrefix)) && showIcon ? vue.h("div", {
            class: `${mergedClsPrefix}-message__icon ${mergedClsPrefix}-message__icon--${type}-type`
          }, vue.h(NIconSwitchTransition, null, {
            default: () => iconNode
          })) : null, vue.h("div", {
            class: `${mergedClsPrefix}-message__content`
          }, render(content)), closable ? vue.h(NBaseClose, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-message__close`,
            onClick: handleClose,
            absolute: true
          }) : null));
        }
      });
      function createIconVNode(icon, type, clsPrefix) {
        if (typeof icon === "function") {
          return icon();
        } else {
          const innerIcon = type === "loading" ? vue.h(NBaseLoading, {
            clsPrefix,
            strokeWidth: 24,
            scale: 0.85
          }) : iconRenderMap$1[type]();
          if (!innerIcon) return null;
          return vue.h(NBaseIcon, {
            clsPrefix,
            key: type
          }, {
            default: () => innerIcon
          });
        }
      }
      const MessageEnvironment = vue.defineComponent({
        name: "MessageEnvironment",
        props: Object.assign(Object.assign({}, messageProps), {
          duration: {
            type: Number,
            default: 3e3
          },
          onAfterLeave: Function,
          onLeave: Function,
          internalKey: {
            type: String,
            required: true
          },
onInternalAfterLeave: Function,
onHide: Function,
          onAfterHide: Function
        }),
        setup(props) {
          let timerId = null;
          const showRef = vue.ref(true);
          vue.onMounted(() => {
            setHideTimeout();
          });
          function setHideTimeout() {
            const {
              duration: duration2
            } = props;
            if (duration2) {
              timerId = window.setTimeout(hide, duration2);
            }
          }
          function handleMouseenter(e) {
            if (e.currentTarget !== e.target) return;
            if (timerId !== null) {
              window.clearTimeout(timerId);
              timerId = null;
            }
          }
          function handleMouseleave(e) {
            if (e.currentTarget !== e.target) return;
            setHideTimeout();
          }
          function hide() {
            const {
              onHide
            } = props;
            showRef.value = false;
            if (timerId) {
              window.clearTimeout(timerId);
              timerId = null;
            }
            if (onHide) onHide();
          }
          function handleClose() {
            const {
              onClose
            } = props;
            if (onClose) onClose();
            hide();
          }
          function handleAfterLeave() {
            const {
              onAfterLeave,
              onInternalAfterLeave,
              onAfterHide,
              internalKey
            } = props;
            if (onAfterLeave) onAfterLeave();
            if (onInternalAfterLeave) onInternalAfterLeave(internalKey);
            if (onAfterHide) onAfterHide();
          }
          function deactivate() {
            hide();
          }
          return {
            show: showRef,
            hide,
            handleClose,
            handleAfterLeave,
            handleMouseleave,
            handleMouseenter,
            deactivate
          };
        },
        render() {
          return vue.h(NFadeInExpandTransition, {
            appear: true,
            onAfterLeave: this.handleAfterLeave,
            onLeave: this.onLeave
          }, {
            default: () => [this.show ? vue.h(NMessage, {
              content: this.content,
              type: this.type,
              icon: this.icon,
              showIcon: this.showIcon,
              closable: this.closable,
              onClose: this.handleClose,
              onMouseenter: this.keepAliveOnHover ? this.handleMouseenter : void 0,
              onMouseleave: this.keepAliveOnHover ? this.handleMouseleave : void 0
            }) : null]
          });
        }
      });
      const messageProviderProps = Object.assign(Object.assign({}, useTheme.props), {
        to: [String, Object],
        duration: {
          type: Number,
          default: 3e3
        },
        keepAliveOnHover: Boolean,
        max: Number,
        placement: {
          type: String,
          default: "top"
        },
        closable: Boolean,
        containerClass: String,
        containerStyle: [String, Object]
      });
      const NMessageProvider = vue.defineComponent({
        name: "MessageProvider",
        props: messageProviderProps,
        setup(props) {
          const {
            mergedClsPrefixRef
          } = useConfig(props);
          const messageListRef = vue.ref([]);
          const messageRefs = vue.ref({});
          const api = {
            create(content, options) {
              return create(content, Object.assign({
                type: "default"
              }, options));
            },
            info(content, options) {
              return create(content, Object.assign(Object.assign({}, options), {
                type: "info"
              }));
            },
            success(content, options) {
              return create(content, Object.assign(Object.assign({}, options), {
                type: "success"
              }));
            },
            warning(content, options) {
              return create(content, Object.assign(Object.assign({}, options), {
                type: "warning"
              }));
            },
            error(content, options) {
              return create(content, Object.assign(Object.assign({}, options), {
                type: "error"
              }));
            },
            loading(content, options) {
              return create(content, Object.assign(Object.assign({}, options), {
                type: "loading"
              }));
            },
            destroyAll
          };
          vue.provide(messageProviderInjectionKey, {
            props,
            mergedClsPrefixRef
          });
          vue.provide(messageApiInjectionKey, api);
          function create(content, options) {
            const key = createId();
            const messageReactive = vue.reactive(Object.assign(Object.assign({}, options), {
              content,
              key,
              destroy: () => {
                var _a;
                (_a = messageRefs.value[key]) === null || _a === void 0 ? void 0 : _a.hide();
              }
            }));
            const {
              max
            } = props;
            if (max && messageListRef.value.length >= max) {
              messageListRef.value.shift();
            }
            messageListRef.value.push(messageReactive);
            return messageReactive;
          }
          function handleAfterLeave(key) {
            messageListRef.value.splice(messageListRef.value.findIndex((message2) => message2.key === key), 1);
            delete messageRefs.value[key];
          }
          function destroyAll() {
            Object.values(messageRefs.value).forEach((messageInstRef) => {
              messageInstRef.hide();
            });
          }
          return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            messageRefs,
            messageList: messageListRef,
            handleAfterLeave
          }, api);
        },
        render() {
          var _a, _b, _c;
          return vue.h(vue.Fragment, null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a), this.messageList.length ? vue.h(vue.Teleport, {
            to: (_c = this.to) !== null && _c !== void 0 ? _c : "body"
          }, vue.h("div", {
            class: [`${this.mergedClsPrefix}-message-container`, `${this.mergedClsPrefix}-message-container--${this.placement}`, this.containerClass],
            key: "message-container",
            style: this.containerStyle
          }, this.messageList.map((message2) => {
            return vue.h(MessageEnvironment, Object.assign({
              ref: (inst) => {
                if (inst) {
                  this.messageRefs[message2.key] = inst;
                }
              },
              internalKey: message2.key,
              onInternalAfterLeave: this.handleAfterLeave
            }, omit(message2, ["destroy"], void 0), {
              duration: message2.duration === void 0 ? this.duration : message2.duration,
              keepAliveOnHover: message2.keepAliveOnHover === void 0 ? this.keepAliveOnHover : message2.keepAliveOnHover,
              closable: message2.closable === void 0 ? this.closable : message2.closable
            }));
          }))) : null);
        }
      });
      function useMessage() {
        const api = vue.inject(messageApiInjectionKey, null);
        if (api === null) {
          throwError("use-message", "No outer <n-message-provider /> founded. See prerequisite in https://www.naiveui.com/en-US/os-theme/components/message for more details. If you want to use `useMessage` outside setup, please check https://www.naiveui.com/zh-CN/os-theme/components/message#Q-&-A.");
        }
        return api;
      }
      const NModalEnvironment = vue.defineComponent({
        name: "ModalEnvironment",
        props: Object.assign(Object.assign({}, modalProps), {
          internalKey: {
            type: String,
            required: true
          },
onInternalAfterLeave: {
            type: Function,
            required: true
          }
        }),
        setup(props) {
          const showRef = vue.ref(true);
          function handleAfterLeave() {
            const {
              onInternalAfterLeave,
              internalKey,
              onAfterLeave
            } = props;
            if (onInternalAfterLeave) onInternalAfterLeave(internalKey);
            if (onAfterLeave) onAfterLeave();
          }
          function handlePositiveClick() {
            const {
              onPositiveClick
            } = props;
            if (onPositiveClick) {
              void Promise.resolve(onPositiveClick()).then((result) => {
                if (result === false) return;
                hide();
              });
            } else {
              hide();
            }
          }
          function handleNegativeClick() {
            const {
              onNegativeClick
            } = props;
            if (onNegativeClick) {
              void Promise.resolve(onNegativeClick()).then((result) => {
                if (result === false) return;
                hide();
              });
            } else {
              hide();
            }
          }
          function handleCloseClick() {
            const {
              onClose
            } = props;
            if (onClose) {
              void Promise.resolve(onClose()).then((result) => {
                if (result === false) return;
                hide();
              });
            } else {
              hide();
            }
          }
          function handleMaskClick(e) {
            const {
              onMaskClick,
              maskClosable
            } = props;
            if (onMaskClick) {
              onMaskClick(e);
              if (maskClosable) {
                hide();
              }
            }
          }
          function handleEsc() {
            const {
              onEsc
            } = props;
            if (onEsc) {
              onEsc();
            }
          }
          function hide() {
            showRef.value = false;
          }
          function handleUpdateShow(value) {
            showRef.value = value;
          }
          return {
            show: showRef,
            hide,
            handleUpdateShow,
            handleAfterLeave,
            handleCloseClick,
            handleNegativeClick,
            handlePositiveClick,
            handleMaskClick,
            handleEsc
          };
        },
        render() {
          const {
            handleUpdateShow,
            handleAfterLeave,
            handleMaskClick,
            handleEsc,
            show
          } = this;
          return vue.h(NModal, Object.assign({}, this.$props, {
            show,
            onUpdateShow: handleUpdateShow,
            onMaskClick: handleMaskClick,
            onEsc: handleEsc,
            onAfterLeave: handleAfterLeave,
            internalAppear: true,
            internalModal: true
          }), this.$slots);
        }
      });
      const modalProviderProps = {
        to: [String, Object]
      };
      const NModalProvider = vue.defineComponent({
        name: "ModalProvider",
        props: modalProviderProps,
        setup() {
          const modalListRef = vue.ref([]);
          const modalInstRefs = {};
          function create(options = {}) {
            const key = createId();
            const modalReactive = vue.reactive(Object.assign(Object.assign({}, options), {
              key,
              destroy: () => {
                var _a;
                (_a = modalInstRefs[`n-modal-${key}`]) === null || _a === void 0 ? void 0 : _a.hide();
              }
            }));
            modalListRef.value.push(modalReactive);
            return modalReactive;
          }
          function handleAfterLeave(key) {
            const {
              value: modalList
            } = modalListRef;
            modalList.splice(modalList.findIndex((modal) => modal.key === key), 1);
          }
          function destroyAll() {
            Object.values(modalInstRefs).forEach((modalInstRef) => {
              modalInstRef === null || modalInstRef === void 0 ? void 0 : modalInstRef.hide();
            });
          }
          const api = {
            create,
            destroyAll
          };
          vue.provide(modalApiInjectionKey, api);
          vue.provide(modalProviderInjectionKey, {
            clickedRef: useClicked(64),
            clickedPositionRef: useClickPosition()
          });
          vue.provide(modalReactiveListInjectionKey, modalListRef);
          return Object.assign(Object.assign({}, api), {
            modalList: modalListRef,
            modalInstRefs,
            handleAfterLeave
          });
        },
        render() {
          var _a, _b;
          return vue.h(vue.Fragment, null, [this.modalList.map((modal) => {
            var _a2;
            return vue.h(NModalEnvironment, omit(modal, ["destroy", "render"], {
              to: (_a2 = modal.to) !== null && _a2 !== void 0 ? _a2 : this.to,
              ref: (inst) => {
                if (inst === null) {
                  delete this.modalInstRefs[`n-modal-${modal.key}`];
                } else {
                  this.modalInstRefs[`n-modal-${modal.key}`] = inst;
                }
              },
              internalKey: modal.key,
              onInternalAfterLeave: this.handleAfterLeave
            }), {
              default: modal.render
            });
          }), (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a)]);
        }
      });
      const commonVars$4 = {
        closeMargin: "16px 12px",
        closeSize: "20px",
        closeIconSize: "16px",
        width: "365px",
        padding: "16px",
        titleFontSize: "16px",
        metaFontSize: "12px",
        descriptionFontSize: "12px"
      };
      function self$7(vars) {
        const {
          textColor2,
          successColor,
          infoColor,
          warningColor,
          errorColor,
          popoverColor,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          textColor1,
          textColor3,
          borderRadius,
          fontWeightStrong,
          boxShadow2,
          lineHeight: lineHeight2,
          fontSize: fontSize2
        } = vars;
        return Object.assign(Object.assign({}, commonVars$4), {
          borderRadius,
          lineHeight: lineHeight2,
          fontSize: fontSize2,
          headerFontWeight: fontWeightStrong,
          iconColor: textColor2,
          iconColorSuccess: successColor,
          iconColorInfo: infoColor,
          iconColorWarning: warningColor,
          iconColorError: errorColor,
          color: popoverColor,
          textColor: textColor2,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeBorderRadius: borderRadius,
          closeColorHover,
          closeColorPressed,
          headerTextColor: textColor1,
          descriptionTextColor: textColor3,
          actionTextColor: textColor2,
          boxShadow: boxShadow2
        });
      }
      const notificationLight = createTheme({
        name: "Notification",
        common: derived,
        peers: {
          Scrollbar: scrollbarLight
        },
        self: self$7
      });
      const notificationProviderInjectionKey = createInjectionKey("n-notification-provider");
      const NotificationContainer = vue.defineComponent({
        name: "NotificationContainer",
        props: {
          scrollable: {
            type: Boolean,
            required: true
          },
          placement: {
            type: String,
            required: true
          }
        },
        setup() {
          const {
            mergedThemeRef,
            mergedClsPrefixRef,
            wipTransitionCountRef
          } = vue.inject(notificationProviderInjectionKey);
          const selfRef = vue.ref(null);
          vue.watchEffect(() => {
            var _a, _b;
            if (wipTransitionCountRef.value > 0) {
              (_a = selfRef === null || selfRef === void 0 ? void 0 : selfRef.value) === null || _a === void 0 ? void 0 : _a.classList.add("transitioning");
            } else {
              (_b = selfRef === null || selfRef === void 0 ? void 0 : selfRef.value) === null || _b === void 0 ? void 0 : _b.classList.remove("transitioning");
            }
          });
          return {
            selfRef,
            mergedTheme: mergedThemeRef,
            mergedClsPrefix: mergedClsPrefixRef,
            transitioning: wipTransitionCountRef
          };
        },
        render() {
          const {
            $slots,
            scrollable,
            mergedClsPrefix,
            mergedTheme,
            placement
          } = this;
          return vue.h("div", {
            ref: "selfRef",
            class: [`${mergedClsPrefix}-notification-container`, scrollable && `${mergedClsPrefix}-notification-container--scrollable`, `${mergedClsPrefix}-notification-container--${placement}`]
          }, scrollable ? vue.h(Scrollbar, {
            theme: mergedTheme.peers.Scrollbar,
            themeOverrides: mergedTheme.peerOverrides.Scrollbar,
            contentStyle: {
              overflow: "hidden"
            }
          }, $slots) : $slots);
        }
      });
      const iconRenderMap = {
        info: () => vue.h(InfoIcon, null),
        success: () => vue.h(SuccessIcon, null),
        warning: () => vue.h(WarningIcon, null),
        error: () => vue.h(ErrorIcon, null),
        default: () => null
      };
      const notificationProps = {
        closable: {
          type: Boolean,
          default: true
        },
        type: {
          type: String,
          default: "default"
        },
        avatar: Function,
        title: [String, Function],
        description: [String, Function],
        content: [String, Function],
        meta: [String, Function],
        action: [String, Function],
        onClose: {
          type: Function,
          required: true
        },
        keepAliveOnHover: Boolean,
        onMouseenter: Function,
        onMouseleave: Function
      };
      const notificationPropKeys = keysOf(notificationProps);
      const Notification = vue.defineComponent({
        name: "Notification",
        props: notificationProps,
        setup(props) {
          const {
            mergedClsPrefixRef,
            mergedThemeRef,
            props: providerProps
          } = vue.inject(notificationProviderInjectionKey);
          const {
            inlineThemeDisabled,
            mergedRtlRef
          } = useConfig();
          const rtlEnabledRef = useRtl("Notification", mergedRtlRef, mergedClsPrefixRef);
          const cssVarsRef = vue.computed(() => {
            const {
              type
            } = props;
            const {
              self: {
                color,
                textColor,
                closeIconColor,
                closeIconColorHover,
                closeIconColorPressed,
                headerTextColor,
                descriptionTextColor,
                actionTextColor,
                borderRadius,
                headerFontWeight,
                boxShadow,
                lineHeight: lineHeight2,
                fontSize: fontSize2,
                closeMargin,
                closeSize,
                width,
                padding,
                closeIconSize,
                closeBorderRadius,
                closeColorHover,
                closeColorPressed,
                titleFontSize,
                metaFontSize,
                descriptionFontSize,
                [createKey("iconColor", type)]: iconColor
              },
              common: {
                cubicBezierEaseOut: cubicBezierEaseOut2,
                cubicBezierEaseIn: cubicBezierEaseIn2,
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              }
            } = mergedThemeRef.value;
            const {
              left,
              right,
              top,
              bottom
            } = getMargin(padding);
            return {
              "--n-color": color,
              "--n-font-size": fontSize2,
              "--n-text-color": textColor,
              "--n-description-text-color": descriptionTextColor,
              "--n-action-text-color": actionTextColor,
              "--n-title-text-color": headerTextColor,
              "--n-title-font-weight": headerFontWeight,
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-bezier-ease-out": cubicBezierEaseOut2,
              "--n-bezier-ease-in": cubicBezierEaseIn2,
              "--n-border-radius": borderRadius,
              "--n-box-shadow": boxShadow,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-line-height": lineHeight2,
              "--n-icon-color": iconColor,
              "--n-close-margin": closeMargin,
              "--n-close-size": closeSize,
              "--n-close-icon-size": closeIconSize,
              "--n-width": width,
              "--n-padding-left": left,
              "--n-padding-right": right,
              "--n-padding-top": top,
              "--n-padding-bottom": bottom,
              "--n-title-font-size": titleFontSize,
              "--n-meta-font-size": metaFontSize,
              "--n-description-font-size": descriptionFontSize
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("notification", vue.computed(() => props.type[0]), cssVarsRef, providerProps) : void 0;
          return {
            mergedClsPrefix: mergedClsPrefixRef,
            showAvatar: vue.computed(() => {
              return props.avatar || props.type !== "default";
            }),
            handleCloseClick() {
              props.onClose();
            },
            rtlEnabled: rtlEnabledRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          var _a;
          const {
            mergedClsPrefix
          } = this;
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("div", {
            class: [`${mergedClsPrefix}-notification-wrapper`, this.themeClass],
            onMouseenter: this.onMouseenter,
            onMouseleave: this.onMouseleave,
            style: this.cssVars
          }, vue.h("div", {
            class: [`${mergedClsPrefix}-notification`, this.rtlEnabled && `${mergedClsPrefix}-notification--rtl`, this.themeClass, {
              [`${mergedClsPrefix}-notification--closable`]: this.closable,
              [`${mergedClsPrefix}-notification--show-avatar`]: this.showAvatar
            }],
            style: this.cssVars
          }, this.showAvatar ? vue.h("div", {
            class: `${mergedClsPrefix}-notification__avatar`
          }, this.avatar ? render(this.avatar) : this.type !== "default" ? vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => iconRenderMap[this.type]()
          }) : null) : null, this.closable ? vue.h(NBaseClose, {
            clsPrefix: mergedClsPrefix,
            class: `${mergedClsPrefix}-notification__close`,
            onClick: this.handleCloseClick
          }) : null, vue.h("div", {
            ref: "bodyRef",
            class: `${mergedClsPrefix}-notification-main`
          }, this.title ? vue.h("div", {
            class: `${mergedClsPrefix}-notification-main__header`
          }, render(this.title)) : null, this.description ? vue.h("div", {
            class: `${mergedClsPrefix}-notification-main__description`
          }, render(this.description)) : null, this.content ? vue.h("pre", {
            class: `${mergedClsPrefix}-notification-main__content`
          }, render(this.content)) : null, this.meta || this.action ? vue.h("div", {
            class: `${mergedClsPrefix}-notification-main-footer`
          }, this.meta ? vue.h("div", {
            class: `${mergedClsPrefix}-notification-main-footer__meta`
          }, render(this.meta)) : null, this.action ? vue.h("div", {
            class: `${mergedClsPrefix}-notification-main-footer__action`
          }, render(this.action)) : null) : null)));
        }
      });
      const notificationEnvOptions = Object.assign(Object.assign({}, notificationProps), {
        duration: Number,
        onClose: Function,
        onLeave: Function,
        onAfterEnter: Function,
        onAfterLeave: Function,
onHide: Function,
onAfterShow: Function,
onAfterHide: Function
      });
      const NotificationEnvironment = vue.defineComponent({
        name: "NotificationEnvironment",
        props: Object.assign(Object.assign({}, notificationEnvOptions), {
internalKey: {
            type: String,
            required: true
          },
          onInternalAfterLeave: {
            type: Function,
            required: true
          }
        }),
        setup(props) {
          const {
            wipTransitionCountRef
          } = vue.inject(notificationProviderInjectionKey);
          const showRef = vue.ref(true);
          let timerId = null;
          function hide() {
            showRef.value = false;
            if (timerId) {
              window.clearTimeout(timerId);
            }
          }
          function handleBeforeEnter(el) {
            wipTransitionCountRef.value++;
            void vue.nextTick(() => {
              el.style.height = `${el.offsetHeight}px`;
              el.style.maxHeight = "0";
              el.style.transition = "none";
              void el.offsetHeight;
              el.style.transition = "";
              el.style.maxHeight = el.style.height;
            });
          }
          function handleAfterEnter(el) {
            wipTransitionCountRef.value--;
            el.style.height = "";
            el.style.maxHeight = "";
            const {
              onAfterEnter,
              onAfterShow
            } = props;
            if (onAfterEnter) onAfterEnter();
            if (onAfterShow) onAfterShow();
          }
          function handleBeforeLeave(el) {
            wipTransitionCountRef.value++;
            el.style.maxHeight = `${el.offsetHeight}px`;
            el.style.height = `${el.offsetHeight}px`;
            void el.offsetHeight;
          }
          function handleLeave(el) {
            const {
              onHide
            } = props;
            if (onHide) onHide();
            el.style.maxHeight = "0";
            void el.offsetHeight;
          }
          function handleAfterLeave() {
            wipTransitionCountRef.value--;
            const {
              onAfterLeave,
              onInternalAfterLeave,
              onAfterHide,
              internalKey
            } = props;
            if (onAfterLeave) onAfterLeave();
            onInternalAfterLeave(internalKey);
            if (onAfterHide) onAfterHide();
          }
          function setHideTimeout() {
            const {
              duration: duration2
            } = props;
            if (duration2) {
              timerId = window.setTimeout(hide, duration2);
            }
          }
          function handleMouseenter(e) {
            if (e.currentTarget !== e.target) return;
            if (timerId !== null) {
              window.clearTimeout(timerId);
              timerId = null;
            }
          }
          function handleMouseleave(e) {
            if (e.currentTarget !== e.target) return;
            setHideTimeout();
          }
          function handleClose() {
            const {
              onClose
            } = props;
            if (onClose) {
              void Promise.resolve(onClose()).then((feedback) => {
                if (feedback === false) return;
                hide();
              });
            } else {
              hide();
            }
          }
          vue.onMounted(() => {
            if (props.duration) {
              timerId = window.setTimeout(hide, props.duration);
            }
          });
          return {
            show: showRef,
            hide,
            handleClose,
            handleAfterLeave,
            handleLeave,
            handleBeforeLeave,
            handleAfterEnter,
            handleBeforeEnter,
            handleMouseenter,
            handleMouseleave
          };
        },
        render() {
          return vue.h(vue.Transition, {
            name: "notification-transition",
            appear: true,
onBeforeEnter: this.handleBeforeEnter,
            onAfterEnter: this.handleAfterEnter,
            onBeforeLeave: this.handleBeforeLeave,
            onLeave: this.handleLeave,
            onAfterLeave: this.handleAfterLeave
          }, {
            default: () => {
              return this.show ? vue.h(Notification, Object.assign({}, keep(this.$props, notificationPropKeys), {
                onClose: this.handleClose,
                onMouseenter: this.duration && this.keepAliveOnHover ? this.handleMouseenter : void 0,
                onMouseleave: this.duration && this.keepAliveOnHover ? this.handleMouseleave : void 0
              })) : null;
            }
          });
        }
      });
      const style$5 = c$1([cB("notification-container", `
 z-index: 4000;
 position: fixed;
 overflow: visible;
 display: flex;
 flex-direction: column;
 align-items: flex-end;
 `, [c$1(">", [cB("scrollbar", `
 width: initial;
 overflow: visible;
 height: -moz-fit-content !important;
 height: fit-content !important;
 max-height: 100vh !important;
 `, [c$1(">", [cB("scrollbar-container", `
 height: -moz-fit-content !important;
 height: fit-content !important;
 max-height: 100vh !important;
 `, [cB("scrollbar-content", `
 padding-top: 12px;
 padding-bottom: 33px;
 `)])])])]), cM("top, top-right, top-left", `
 top: 12px;
 `, [c$1("&.transitioning >", [cB("scrollbar", [c$1(">", [cB("scrollbar-container", `
 min-height: 100vh !important;
 `)])])])]), cM("bottom, bottom-right, bottom-left", `
 bottom: 12px;
 `, [c$1(">", [cB("scrollbar", [c$1(">", [cB("scrollbar-container", [cB("scrollbar-content", `
 padding-bottom: 12px;
 `)])])])]), cB("notification-wrapper", `
 display: flex;
 align-items: flex-end;
 margin-bottom: 0;
 margin-top: 12px;
 `)]), cM("top, bottom", `
 left: 50%;
 transform: translateX(-50%);
 `, [cB("notification-wrapper", [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
 transform: scale(0.85);
 `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
 transform: scale(1);
 `)])]), cM("top", [cB("notification-wrapper", `
 transform-origin: top center;
 `)]), cM("bottom", [cB("notification-wrapper", `
 transform-origin: bottom center;
 `)]), cM("top-right, bottom-right", [cB("notification", `
 margin-left: 28px;
 margin-right: 16px;
 `)]), cM("top-left, bottom-left", [cB("notification", `
 margin-left: 16px;
 margin-right: 28px;
 `)]), cM("top-right", `
 right: 0;
 `, [placementTransformStyle("top-right")]), cM("top-left", `
 left: 0;
 `, [placementTransformStyle("top-left")]), cM("bottom-right", `
 right: 0;
 `, [placementTransformStyle("bottom-right")]), cM("bottom-left", `
 left: 0;
 `, [placementTransformStyle("bottom-left")]), cM("scrollable", [cM("top-right", `
 top: 0;
 `), cM("top-left", `
 top: 0;
 `), cM("bottom-right", `
 bottom: 0;
 `), cM("bottom-left", `
 bottom: 0;
 `)]), cB("notification-wrapper", `
 margin-bottom: 12px;
 `, [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
 opacity: 0;
 margin-top: 0 !important;
 margin-bottom: 0 !important;
 `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
 opacity: 1;
 `), c$1("&.notification-transition-leave-active", `
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier-ease-in),
 max-height .3s var(--n-bezier),
 margin-top .3s linear,
 margin-bottom .3s linear,
 box-shadow .3s var(--n-bezier);
 `), c$1("&.notification-transition-enter-active", `
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 transform .3s var(--n-bezier-ease-out),
 max-height .3s var(--n-bezier),
 margin-top .3s linear,
 margin-bottom .3s linear,
 box-shadow .3s var(--n-bezier);
 `)]), cB("notification", `
 background-color: var(--n-color);
 color: var(--n-text-color);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 font-family: inherit;
 font-size: var(--n-font-size);
 font-weight: 400;
 position: relative;
 display: flex;
 overflow: hidden;
 flex-shrink: 0;
 padding-left: var(--n-padding-left);
 padding-right: var(--n-padding-right);
 width: var(--n-width);
 max-width: calc(100vw - 16px - 16px);
 border-radius: var(--n-border-radius);
 box-shadow: var(--n-box-shadow);
 box-sizing: border-box;
 opacity: 1;
 `, [cE("avatar", [cB("icon", `
 color: var(--n-icon-color);
 `), cB("base-icon", `
 color: var(--n-icon-color);
 `)]), cM("show-avatar", [cB("notification-main", `
 margin-left: 40px;
 width: calc(100% - 40px); 
 `)]), cM("closable", [cB("notification-main", [c$1("> *:first-child", `
 padding-right: 20px;
 `)]), cE("close", `
 position: absolute;
 top: 0;
 right: 0;
 margin: var(--n-close-margin);
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `)]), cE("avatar", `
 position: absolute;
 top: var(--n-padding-top);
 left: var(--n-padding-left);
 width: 28px;
 height: 28px;
 font-size: 28px;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB("icon", "transition: color .3s var(--n-bezier);")]), cB("notification-main", `
 padding-top: var(--n-padding-top);
 padding-bottom: var(--n-padding-bottom);
 box-sizing: border-box;
 display: flex;
 flex-direction: column;
 margin-left: 8px;
 width: calc(100% - 8px);
 `, [cB("notification-main-footer", `
 display: flex;
 align-items: center;
 justify-content: space-between;
 margin-top: 12px;
 `, [cE("meta", `
 font-size: var(--n-meta-font-size);
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-description-text-color);
 `), cE("action", `
 cursor: pointer;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-action-text-color);
 `)]), cE("header", `
 font-weight: var(--n-title-font-weight);
 font-size: var(--n-title-font-size);
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-title-text-color);
 `), cE("description", `
 margin-top: 8px;
 font-size: var(--n-description-font-size);
 white-space: pre-wrap;
 word-wrap: break-word;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-description-text-color);
 `), cE("content", `
 line-height: var(--n-line-height);
 margin: 12px 0 0 0;
 font-family: inherit;
 white-space: pre-wrap;
 word-wrap: break-word;
 transition: color .3s var(--n-bezier-ease-out);
 color: var(--n-text-color);
 `, [c$1("&:first-child", "margin: 0;")])])])])]);
      function placementTransformStyle(placement) {
        const direction = placement.split("-")[1];
        const transformXEnter = direction === "left" ? "calc(-100%)" : "calc(100%)";
        const transformXLeave = "0";
        return cB("notification-wrapper", [c$1("&.notification-transition-enter-from, &.notification-transition-leave-to", `
 transform: translate(${transformXEnter}, 0);
 `), c$1("&.notification-transition-leave-from, &.notification-transition-enter-to", `
 transform: translate(${transformXLeave}, 0);
 `)]);
      }
      const notificationApiInjectionKey = createInjectionKey("n-notification-api");
      const notificationProviderProps = Object.assign(Object.assign({}, useTheme.props), {
        containerClass: String,
        containerStyle: [String, Object],
        to: [String, Object],
        scrollable: {
          type: Boolean,
          default: true
        },
        max: Number,
        placement: {
          type: String,
          default: "top-right"
        },
        keepAliveOnHover: Boolean
      });
      const NNotificationProvider = vue.defineComponent({
        name: "NotificationProvider",
        props: notificationProviderProps,
        setup(props) {
          const {
            mergedClsPrefixRef
          } = useConfig(props);
          const notificationListRef = vue.ref([]);
          const notificationRefs = {};
          const leavingKeySet = new Set();
          function create(options) {
            const key = createId();
            const destroy = () => {
              leavingKeySet.add(key);
              if (notificationRefs[key]) {
                notificationRefs[key].hide();
              }
            };
            const notificationReactive = vue.reactive(Object.assign(Object.assign({}, options), {
              key,
              destroy,
              hide: destroy,
              deactivate: destroy
            }));
            const {
              max
            } = props;
            if (max && notificationListRef.value.length - leavingKeySet.size >= max) {
              let someoneMountedRemoved = false;
              let index = 0;
              for (const notification of notificationListRef.value) {
                if (!leavingKeySet.has(notification.key)) {
                  if (notificationRefs[notification.key]) {
                    notification.destroy();
                    someoneMountedRemoved = true;
                  }
                  break;
                }
                index++;
              }
              if (!someoneMountedRemoved) {
                notificationListRef.value.splice(index, 1);
              }
            }
            notificationListRef.value.push(notificationReactive);
            return notificationReactive;
          }
          const apis = ["info", "success", "warning", "error"].map((type) => {
            return (options) => create(Object.assign(Object.assign({}, options), {
              type
            }));
          });
          function handleAfterLeave(key) {
            leavingKeySet.delete(key);
            notificationListRef.value.splice(notificationListRef.value.findIndex((notification) => notification.key === key), 1);
          }
          const themeRef = useTheme("Notification", "-notification", style$5, notificationLight, props, mergedClsPrefixRef);
          const api = {
            create,
            info: apis[0],
            success: apis[1],
            warning: apis[2],
            error: apis[3],
            open,
            destroyAll
          };
          const wipTransitionCountRef = vue.ref(0);
          vue.provide(notificationApiInjectionKey, api);
          vue.provide(notificationProviderInjectionKey, {
            props,
            mergedClsPrefixRef,
            mergedThemeRef: themeRef,
            wipTransitionCountRef
          });
          function open(options) {
            return create(options);
          }
          function destroyAll() {
            Object.values(notificationListRef.value).forEach((notification) => {
              notification.hide();
            });
          }
          return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            notificationList: notificationListRef,
            notificationRefs,
            handleAfterLeave
          }, api);
        },
        render() {
          var _a, _b, _c;
          const {
            placement
          } = this;
          return vue.h(vue.Fragment, null, (_b = (_a = this.$slots).default) === null || _b === void 0 ? void 0 : _b.call(_a), this.notificationList.length ? vue.h(vue.Teleport, {
            to: (_c = this.to) !== null && _c !== void 0 ? _c : "body"
          }, vue.h(NotificationContainer, {
            class: this.containerClass,
            style: this.containerStyle,
            scrollable: this.scrollable && placement !== "top" && placement !== "bottom",
            placement
          }, {
            default: () => {
              return this.notificationList.map((notification) => {
                return vue.h(NotificationEnvironment, Object.assign({
                  ref: (inst) => {
                    const refKey = notification.key;
                    if (inst === null) {
                      delete this.notificationRefs[refKey];
                    } else {
                      this.notificationRefs[refKey] = inst;
                    }
                  }
                }, omit(notification, ["destroy", "hide", "deactivate"]), {
                  internalKey: notification.key,
                  onInternalAfterLeave: this.handleAfterLeave,
                  keepAliveOnHover: notification.keepAliveOnHover === void 0 ? this.keepAliveOnHover : notification.keepAliveOnHover
                }));
              });
            }
          })) : null);
        }
      });
      function useNotification() {
        const api = vue.inject(notificationApiInjectionKey, null);
        if (api === null) {
          throwError("use-notification", "No outer `n-notification-provider` found.");
        }
        return api;
      }
      const NInjectionExtractor = vue.defineComponent({
        name: "InjectionExtractor",
        props: {
          onSetup: Function
        },
        setup(props, {
          slots
        }) {
          var _a;
          (_a = props.onSetup) === null || _a === void 0 ? void 0 : _a.call(props);
          return () => {
            var _a2;
            return (_a2 = slots.default) === null || _a2 === void 0 ? void 0 : _a2.call(slots);
          };
        }
      });
      const injectionFactoryMap = {
        message: useMessage,
        notification: useNotification,
        loadingBar: useLoadingBar,
        dialog: useDialog,
        modal: useModal
      };
      function createDiscreteApp({
        providersAndProps,
        configProviderProps: configProviderProps2
      }) {
        let app = vue.createApp(App);
        const extractedApi = {
          app
        };
        function App() {
          return vue.h(NConfigProvider, vue.unref(configProviderProps2), {
            default: () => providersAndProps.map(({
              type,
              Provider,
              props
            }) => {
              return vue.h(Provider, vue.unref(props), {
                default: () => vue.h(NInjectionExtractor, {
                  onSetup: () => extractedApi[type] = injectionFactoryMap[type]()
                })
              });
            })
          });
        }
        let hostEl;
        if (isBrowser$1) {
          hostEl = document.createElement("div");
          document.body.appendChild(hostEl);
          app.mount(hostEl);
        }
        const unmount2 = () => {
          var _a;
          if (app === null || hostEl === null) {
            warn("discrete", "unmount call no need because discrete app has been unmounted");
            return;
          }
          app.unmount();
          (_a = hostEl.parentNode) === null || _a === void 0 ? void 0 : _a.removeChild(hostEl);
          hostEl = null;
          app = null;
        };
        return Object.assign({
          unmount: unmount2
        }, extractedApi);
      }
      function createDiscreteApi(includes, {
        configProviderProps: configProviderProps2,
        messageProviderProps: messageProviderProps2,
        dialogProviderProps: dialogProviderProps2,
        notificationProviderProps: notificationProviderProps2,
        loadingBarProviderProps: loadingBarProviderProps2,
        modalProviderProps: modalProviderProps2
      } = {}) {
        const providersAndProps = [];
        includes.forEach((type) => {
          switch (type) {
            case "message":
              providersAndProps.push({
                type,
                Provider: NMessageProvider,
                props: messageProviderProps2
              });
              break;
            case "notification":
              providersAndProps.push({
                type,
                Provider: NNotificationProvider,
                props: notificationProviderProps2
              });
              break;
            case "dialog":
              providersAndProps.push({
                type,
                Provider: NDialogProvider,
                props: dialogProviderProps2
              });
              break;
            case "loadingBar":
              providersAndProps.push({
                type,
                Provider: NLoadingBarProvider,
                props: loadingBarProviderProps2
              });
              break;
            case "modal":
              providersAndProps.push({
                type,
                Provider: NModalProvider,
                props: modalProviderProps2
              });
          }
        });
        const discreteApp = createDiscreteApp({
          providersAndProps,
          configProviderProps: configProviderProps2
        });
        return discreteApp;
      }
      const commonVars$3 = {
        gapSmall: "4px 8px",
        gapMedium: "8px 12px",
        gapLarge: "12px 16px"
      };
      function self$6() {
        return commonVars$3;
      }
      const spaceLight = {
        self: self$6
      };
      let supportFlexGap;
      function ensureSupportFlexGap() {
        if (!isBrowser$1) return true;
        if (supportFlexGap === void 0) {
          const flex = document.createElement("div");
          flex.style.display = "flex";
          flex.style.flexDirection = "column";
          flex.style.rowGap = "1px";
          flex.appendChild(document.createElement("div"));
          flex.appendChild(document.createElement("div"));
          document.body.appendChild(flex);
          const isSupported = flex.scrollHeight === 1;
          document.body.removeChild(flex);
          return supportFlexGap = isSupported;
        }
        return supportFlexGap;
      }
      const spaceProps = Object.assign(Object.assign({}, useTheme.props), {
        align: String,
        justify: {
          type: String,
          default: "start"
        },
        inline: Boolean,
        vertical: Boolean,
        reverse: Boolean,
        size: {
          type: [String, Number, Array],
          default: "medium"
        },
        wrapItem: {
          type: Boolean,
          default: true
        },
        itemClass: String,
        itemStyle: [String, Object],
        wrap: {
          type: Boolean,
          default: true
        },
internalUseGap: {
          type: Boolean,
          default: void 0
        }
      });
      const NSpace = vue.defineComponent({
        name: "Space",
        props: spaceProps,
        setup(props) {
          const {
            mergedClsPrefixRef,
            mergedRtlRef
          } = useConfig(props);
          const themeRef = useTheme("Space", "-space", void 0, spaceLight, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Space", mergedRtlRef, mergedClsPrefixRef);
          return {
            useGap: ensureSupportFlexGap(),
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            margin: vue.computed(() => {
              const {
                size: size2
              } = props;
              if (Array.isArray(size2)) {
                return {
                  horizontal: size2[0],
                  vertical: size2[1]
                };
              }
              if (typeof size2 === "number") {
                return {
                  horizontal: size2,
                  vertical: size2
                };
              }
              const {
                self: {
                  [createKey("gap", size2)]: gap
                }
              } = themeRef.value;
              const {
                row,
                col
              } = getGap(gap);
              return {
                horizontal: depx(col),
                vertical: depx(row)
              };
            })
          };
        },
        render() {
          const {
            vertical,
            reverse,
            align,
            inline,
            justify,
            itemClass,
            itemStyle,
            margin,
            wrap,
            mergedClsPrefix,
            rtlEnabled,
            useGap,
            wrapItem,
            internalUseGap
          } = this;
          const children = flatten$2(getSlot(this), false);
          if (!children.length) return null;
          const horizontalMargin = `${margin.horizontal}px`;
          const semiHorizontalMargin = `${margin.horizontal / 2}px`;
          const verticalMargin = `${margin.vertical}px`;
          const semiVerticalMargin = `${margin.vertical / 2}px`;
          const lastIndex = children.length - 1;
          const isJustifySpace = justify.startsWith("space-");
          return vue.h("div", {
            role: "none",
            class: [`${mergedClsPrefix}-space`, rtlEnabled && `${mergedClsPrefix}-space--rtl`],
            style: {
              display: inline ? "inline-flex" : "flex",
              flexDirection: (() => {
                if (vertical && !reverse) return "column";
                if (vertical && reverse) return "column-reverse";
                if (!vertical && reverse) return "row-reverse";
                else return "row";
              })(),
              justifyContent: ["start", "end"].includes(justify) ? `flex-${justify}` : justify,
              flexWrap: !wrap || vertical ? "nowrap" : "wrap",
              marginTop: useGap || vertical ? "" : `-${semiVerticalMargin}`,
              marginBottom: useGap || vertical ? "" : `-${semiVerticalMargin}`,
              alignItems: align,
              gap: useGap ? `${margin.vertical}px ${margin.horizontal}px` : ""
            }
          }, !wrapItem && (useGap || internalUseGap) ? children : children.map((child, index) => child.type === vue.Comment ? child : vue.h("div", {
            role: "none",
            class: itemClass,
            style: [itemStyle, {
              maxWidth: "100%"
            }, useGap ? "" : vertical ? {
              marginBottom: index !== lastIndex ? verticalMargin : ""
            } : rtlEnabled ? {
              marginLeft: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
              marginRight: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
              paddingTop: semiVerticalMargin,
              paddingBottom: semiVerticalMargin
            } : {
              marginRight: isJustifySpace ? justify === "space-between" && index === lastIndex ? "" : semiHorizontalMargin : index !== lastIndex ? horizontalMargin : "",
              marginLeft: isJustifySpace ? justify === "space-between" && index === 0 ? "" : semiHorizontalMargin : "",
              paddingTop: semiVerticalMargin,
              paddingBottom: semiVerticalMargin
            }]
          }, child)));
        }
      });
      const commonVars$2 = {
        gapSmall: "4px 8px",
        gapMedium: "8px 12px",
        gapLarge: "12px 16px"
      };
      function self$5() {
        return commonVars$2;
      }
      const flexLight = {
        self: self$5
      };
      const flexProps = Object.assign(Object.assign({}, useTheme.props), {
        align: String,
        justify: {
          type: String,
          default: "start"
        },
        inline: Boolean,
        vertical: Boolean,
        reverse: Boolean,
        size: {
          type: [String, Number, Array],
          default: "medium"
        },
        wrap: {
          type: Boolean,
          default: true
        }
      });
      const NFlex = vue.defineComponent({
        name: "Flex",
        props: flexProps,
        setup(props) {
          const {
            mergedClsPrefixRef,
            mergedRtlRef
          } = useConfig(props);
          const themeRef = useTheme("Flex", "-flex", void 0, flexLight, props, mergedClsPrefixRef);
          const rtlEnabledRef = useRtl("Flex", mergedRtlRef, mergedClsPrefixRef);
          return {
            rtlEnabled: rtlEnabledRef,
            mergedClsPrefix: mergedClsPrefixRef,
            margin: vue.computed(() => {
              const {
                size: size2
              } = props;
              if (Array.isArray(size2)) {
                return {
                  horizontal: size2[0],
                  vertical: size2[1]
                };
              }
              if (typeof size2 === "number") {
                return {
                  horizontal: size2,
                  vertical: size2
                };
              }
              const {
                self: {
                  [createKey("gap", size2)]: gap
                }
              } = themeRef.value;
              const {
                row,
                col
              } = getGap(gap);
              return {
                horizontal: depx(col),
                vertical: depx(row)
              };
            })
          };
        },
        render() {
          const {
            vertical,
            reverse,
            align,
            inline,
            justify,
            margin,
            wrap,
            mergedClsPrefix,
            rtlEnabled
          } = this;
          const children = flatten$2(getSlot(this), false);
          if (!children.length) return null;
          return vue.h("div", {
            role: "none",
            class: [`${mergedClsPrefix}-flex`, rtlEnabled && `${mergedClsPrefix}-flex--rtl`],
            style: {
              display: inline ? "inline-flex" : "flex",
              flexDirection: (() => {
                if (vertical && !reverse) return "column";
                if (vertical && reverse) return "column-reverse";
                if (!vertical && reverse) return "row-reverse";
                else return "row";
              })(),
              justifyContent: justify,
              flexWrap: !wrap || vertical ? "nowrap" : "wrap",
              alignItems: align,
              gap: `${margin.vertical}px ${margin.horizontal}px`
            }
          }, children);
        }
      });
      const commonVariables = {
        feedbackPadding: "4px 0 0 2px",
        feedbackHeightSmall: "24px",
        feedbackHeightMedium: "24px",
        feedbackHeightLarge: "26px",
        feedbackFontSizeSmall: "13px",
        feedbackFontSizeMedium: "14px",
        feedbackFontSizeLarge: "14px",
        labelFontSizeLeftSmall: "14px",
        labelFontSizeLeftMedium: "14px",
        labelFontSizeLeftLarge: "15px",
        labelFontSizeTopSmall: "13px",
        labelFontSizeTopMedium: "14px",
        labelFontSizeTopLarge: "14px",
        labelHeightSmall: "24px",
        labelHeightMedium: "26px",
        labelHeightLarge: "28px",
        labelPaddingVertical: "0 0 6px 2px",
        labelPaddingHorizontal: "0 12px 0 0",
        labelTextAlignVertical: "left",
        labelTextAlignHorizontal: "right",
        labelFontWeight: "400"
      };
      function self$4(vars) {
        const {
          heightSmall,
          heightMedium,
          heightLarge,
          textColor1,
          errorColor,
          warningColor,
          lineHeight: lineHeight2,
          textColor3
        } = vars;
        return Object.assign(Object.assign({}, commonVariables), {
          blankHeightSmall: heightSmall,
          blankHeightMedium: heightMedium,
          blankHeightLarge: heightLarge,
          lineHeight: lineHeight2,
          labelTextColor: textColor1,
          asteriskColor: errorColor,
          feedbackTextColorError: errorColor,
          feedbackTextColorWarning: warningColor,
          feedbackTextColor: textColor3
        });
      }
      const formLight = {
        common: derived,
        self: self$4
      };
      const commonVars$1 = {
        iconSize: "22px"
      };
      function self$3(vars) {
        const {
          fontSize: fontSize2,
          warningColor
        } = vars;
        return Object.assign(Object.assign({}, commonVars$1), {
          fontSize: fontSize2,
          iconColor: warningColor
        });
      }
      const popconfirmLight = createTheme({
        name: "Popconfirm",
        common: derived,
        peers: {
          Button: buttonLight,
          Popover: popoverLight
        },
        self: self$3
      });
      const commonVars = {
        buttonHeightSmall: "14px",
        buttonHeightMedium: "18px",
        buttonHeightLarge: "22px",
        buttonWidthSmall: "14px",
        buttonWidthMedium: "18px",
        buttonWidthLarge: "22px",
        buttonWidthPressedSmall: "20px",
        buttonWidthPressedMedium: "24px",
        buttonWidthPressedLarge: "28px",
        railHeightSmall: "18px",
        railHeightMedium: "22px",
        railHeightLarge: "26px",
        railWidthSmall: "32px",
        railWidthMedium: "40px",
        railWidthLarge: "48px"
      };
      function self$2(vars) {
        const {
          primaryColor,
          opacityDisabled,
          borderRadius,
          textColor3
        } = vars;
        const railOverlayColor = "rgba(0, 0, 0, .14)";
        return Object.assign(Object.assign({}, commonVars), {
          iconColor: textColor3,
          textColor: "white",
          loadingColor: primaryColor,
          opacityDisabled,
          railColor: railOverlayColor,
          railColorActive: primaryColor,
          buttonBoxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.3), inset 0 0 1px 0 rgba(0, 0, 0, 0.05)",
          buttonColor: "#FFF",
          railBorderRadiusSmall: borderRadius,
          railBorderRadiusMedium: borderRadius,
          railBorderRadiusLarge: borderRadius,
          buttonBorderRadiusSmall: borderRadius,
          buttonBorderRadiusMedium: borderRadius,
          buttonBorderRadiusLarge: borderRadius,
          boxShadowFocus: `0 0 0 2px ${changeColor(primaryColor, {
          alpha: 0.2
        })}`
        });
      }
      const switchLight = {
        common: derived,
        self: self$2
      };
      const sizeVariables = {
        tabFontSizeSmall: "14px",
        tabFontSizeMedium: "14px",
        tabFontSizeLarge: "16px",
        tabGapSmallLine: "36px",
        tabGapMediumLine: "36px",
        tabGapLargeLine: "36px",
        tabGapSmallLineVertical: "8px",
        tabGapMediumLineVertical: "8px",
        tabGapLargeLineVertical: "8px",
        tabPaddingSmallLine: "6px 0",
        tabPaddingMediumLine: "10px 0",
        tabPaddingLargeLine: "14px 0",
        tabPaddingVerticalSmallLine: "6px 12px",
        tabPaddingVerticalMediumLine: "8px 16px",
        tabPaddingVerticalLargeLine: "10px 20px",
        tabGapSmallBar: "36px",
        tabGapMediumBar: "36px",
        tabGapLargeBar: "36px",
        tabGapSmallBarVertical: "8px",
        tabGapMediumBarVertical: "8px",
        tabGapLargeBarVertical: "8px",
        tabPaddingSmallBar: "4px 0",
        tabPaddingMediumBar: "6px 0",
        tabPaddingLargeBar: "10px 0",
        tabPaddingVerticalSmallBar: "6px 12px",
        tabPaddingVerticalMediumBar: "8px 16px",
        tabPaddingVerticalLargeBar: "10px 20px",
        tabGapSmallCard: "4px",
        tabGapMediumCard: "4px",
        tabGapLargeCard: "4px",
        tabGapSmallCardVertical: "4px",
        tabGapMediumCardVertical: "4px",
        tabGapLargeCardVertical: "4px",
        tabPaddingSmallCard: "8px 16px",
        tabPaddingMediumCard: "10px 20px",
        tabPaddingLargeCard: "12px 24px",
        tabPaddingSmallSegment: "4px 0",
        tabPaddingMediumSegment: "6px 0",
        tabPaddingLargeSegment: "8px 0",
        tabPaddingVerticalLargeSegment: "0 8px",
        tabPaddingVerticalSmallCard: "8px 12px",
        tabPaddingVerticalMediumCard: "10px 16px",
        tabPaddingVerticalLargeCard: "12px 20px",
        tabPaddingVerticalSmallSegment: "0 4px",
        tabPaddingVerticalMediumSegment: "0 6px",
        tabGapSmallSegment: "0",
        tabGapMediumSegment: "0",
        tabGapLargeSegment: "0",
        tabGapSmallSegmentVertical: "0",
        tabGapMediumSegmentVertical: "0",
        tabGapLargeSegmentVertical: "0",
        panePaddingSmall: "8px 0 0 0",
        panePaddingMedium: "12px 0 0 0",
        panePaddingLarge: "16px 0 0 0",
        closeSize: "18px",
        closeIconSize: "14px"
      };
      function self$1(vars) {
        const {
          textColor2,
          primaryColor,
          textColorDisabled,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          tabColor,
          baseColor,
          dividerColor,
          fontWeight,
          textColor1,
          borderRadius,
          fontSize: fontSize2,
          fontWeightStrong
        } = vars;
        return Object.assign(Object.assign({}, sizeVariables), {
          colorSegment: tabColor,
          tabFontSizeCard: fontSize2,
          tabTextColorLine: textColor1,
          tabTextColorActiveLine: primaryColor,
          tabTextColorHoverLine: primaryColor,
          tabTextColorDisabledLine: textColorDisabled,
          tabTextColorSegment: textColor1,
          tabTextColorActiveSegment: textColor2,
          tabTextColorHoverSegment: textColor2,
          tabTextColorDisabledSegment: textColorDisabled,
          tabTextColorBar: textColor1,
          tabTextColorActiveBar: primaryColor,
          tabTextColorHoverBar: primaryColor,
          tabTextColorDisabledBar: textColorDisabled,
          tabTextColorCard: textColor1,
          tabTextColorHoverCard: textColor1,
          tabTextColorActiveCard: primaryColor,
          tabTextColorDisabledCard: textColorDisabled,
          barColor: primaryColor,
          closeIconColor,
          closeIconColorHover,
          closeIconColorPressed,
          closeColorHover,
          closeColorPressed,
          closeBorderRadius: borderRadius,
          tabColor,
          tabColorSegment: baseColor,
          tabBorderColor: dividerColor,
          tabFontWeightActive: fontWeight,
          tabFontWeight: fontWeight,
          tabBorderRadius: borderRadius,
          paneTextColor: textColor2,
          fontWeightStrong
        });
      }
      const tabsLight = {
        common: derived,
        self: self$1
      };
      const formInjectionKey = createInjectionKey("n-form");
      const formItemInstsInjectionKey = createInjectionKey("n-form-item-insts");
      const style$4 = cB("form", [cM("inline", `
 width: 100%;
 display: inline-flex;
 align-items: flex-start;
 align-content: space-around;
 `, [cB("form-item", {
        width: "auto",
        marginRight: "18px"
      }, [c$1("&:last-child", {
        marginRight: 0
      })])])]);
      var __awaiter$1 = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const formProps = Object.assign(Object.assign({}, useTheme.props), {
        inline: Boolean,
        labelWidth: [Number, String],
        labelAlign: String,
        labelPlacement: {
          type: String,
          default: "top"
        },
        model: {
          type: Object,
          default: () => {
          }
        },
        rules: Object,
        disabled: Boolean,
        size: String,
        showRequireMark: {
          type: Boolean,
          default: void 0
        },
        requireMarkPlacement: String,
        showFeedback: {
          type: Boolean,
          default: true
        },
        onSubmit: {
          type: Function,
          default: (e) => {
            e.preventDefault();
          }
        },
        showLabel: {
          type: Boolean,
          default: void 0
        },
        validateMessages: Object
      });
      const NForm = vue.defineComponent({
        name: "Form",
        props: formProps,
        setup(props) {
          const {
            mergedClsPrefixRef
          } = useConfig(props);
          useTheme("Form", "-form", style$4, formLight, props, mergedClsPrefixRef);
          const formItems = {};
          const maxChildLabelWidthRef = vue.ref(void 0);
          const deriveMaxChildLabelWidth = (currentWidth) => {
            const currentMaxChildLabelWidth = maxChildLabelWidthRef.value;
            if (currentMaxChildLabelWidth === void 0 || currentWidth >= currentMaxChildLabelWidth) {
              maxChildLabelWidthRef.value = currentWidth;
            }
          };
          function validate(validateCallback_1) {
            return __awaiter$1(this, arguments, void 0, function* (validateCallback, shouldRuleBeApplied = () => true) {
              return yield new Promise((resolve, reject) => {
                const formItemValidationPromises = [];
                for (const key of keysOf(formItems)) {
                  const formItemInstances = formItems[key];
                  for (const formItemInstance of formItemInstances) {
                    if (formItemInstance.path) {
                      formItemValidationPromises.push(formItemInstance.internalValidate(null, shouldRuleBeApplied));
                    }
                  }
                }
                void Promise.all(formItemValidationPromises).then((results) => {
                  const formInvalid = results.some((result) => !result.valid);
                  const errors = [];
                  const warnings = [];
                  results.forEach((result) => {
                    var _a, _b;
                    if ((_a = result.errors) === null || _a === void 0 ? void 0 : _a.length) {
                      errors.push(result.errors);
                    }
                    if ((_b = result.warnings) === null || _b === void 0 ? void 0 : _b.length) {
                      warnings.push(result.warnings);
                    }
                  });
                  if (validateCallback) {
                    validateCallback(errors.length ? errors : void 0, {
                      warnings: warnings.length ? warnings : void 0
                    });
                  }
                  if (formInvalid) {
                    reject(errors.length ? errors : void 0);
                  } else {
                    resolve({
                      warnings: warnings.length ? warnings : void 0
                    });
                  }
                });
              });
            });
          }
          function restoreValidation() {
            for (const key of keysOf(formItems)) {
              const formItemInstances = formItems[key];
              for (const formItemInstance of formItemInstances) {
                formItemInstance.restoreValidation();
              }
            }
          }
          vue.provide(formInjectionKey, {
            props,
            maxChildLabelWidthRef,
            deriveMaxChildLabelWidth
          });
          vue.provide(formItemInstsInjectionKey, {
            formItems
          });
          const formExposedMethod = {
            validate,
            restoreValidation
          };
          return Object.assign(formExposedMethod, {
            mergedClsPrefix: mergedClsPrefixRef
          });
        },
        render() {
          const {
            mergedClsPrefix
          } = this;
          return vue.h("form", {
            class: [`${mergedClsPrefix}-form`, this.inline && `${mergedClsPrefix}-form--inline`],
            onSubmit: this.onSubmit
          }, this.$slots);
        }
      });
      function _extends() {
        _extends = Object.assign ? Object.assign.bind() : function(target) {
          for (var i = 1; i < arguments.length; i++) {
            var source = arguments[i];
            for (var key in source) {
              if (Object.prototype.hasOwnProperty.call(source, key)) {
                target[key] = source[key];
              }
            }
          }
          return target;
        };
        return _extends.apply(this, arguments);
      }
      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        _setPrototypeOf(subClass, superClass);
      }
      function _getPrototypeOf(o) {
        _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
          return o2.__proto__ || Object.getPrototypeOf(o2);
        };
        return _getPrototypeOf(o);
      }
      function _setPrototypeOf(o, p) {
        _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p2) {
          o2.__proto__ = p2;
          return o2;
        };
        return _setPrototypeOf(o, p);
      }
      function _isNativeReflectConstruct() {
        if (typeof Reflect === "undefined" || !Reflect.construct) return false;
        if (Reflect.construct.sham) return false;
        if (typeof Proxy === "function") return true;
        try {
          Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
          }));
          return true;
        } catch (e) {
          return false;
        }
      }
      function _construct(Parent, args, Class) {
        if (_isNativeReflectConstruct()) {
          _construct = Reflect.construct.bind();
        } else {
          _construct = function _construct2(Parent2, args2, Class2) {
            var a = [null];
            a.push.apply(a, args2);
            var Constructor = Function.bind.apply(Parent2, a);
            var instance = new Constructor();
            if (Class2) _setPrototypeOf(instance, Class2.prototype);
            return instance;
          };
        }
        return _construct.apply(null, arguments);
      }
      function _isNativeFunction(fn) {
        return Function.toString.call(fn).indexOf("[native code]") !== -1;
      }
      function _wrapNativeSuper(Class) {
        var _cache = typeof Map === "function" ? new Map() : void 0;
        _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
          if (Class2 === null || !_isNativeFunction(Class2)) return Class2;
          if (typeof Class2 !== "function") {
            throw new TypeError("Super expression must either be null or a function");
          }
          if (typeof _cache !== "undefined") {
            if (_cache.has(Class2)) return _cache.get(Class2);
            _cache.set(Class2, Wrapper2);
          }
          function Wrapper2() {
            return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
          }
          Wrapper2.prototype = Object.create(Class2.prototype, {
            constructor: {
              value: Wrapper2,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
          return _setPrototypeOf(Wrapper2, Class2);
        };
        return _wrapNativeSuper(Class);
      }
      var formatRegExp = /%[sdj%]/g;
      var warning = function warning2() {
      };
      function convertFieldsError(errors) {
        if (!errors || !errors.length) return null;
        var fields = {};
        errors.forEach(function(error) {
          var field = error.field;
          fields[field] = fields[field] || [];
          fields[field].push(error);
        });
        return fields;
      }
      function format(template) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        var i = 0;
        var len2 = args.length;
        if (typeof template === "function") {
          return template.apply(null, args);
        }
        if (typeof template === "string") {
          var str = template.replace(formatRegExp, function(x) {
            if (x === "%%") {
              return "%";
            }
            if (i >= len2) {
              return x;
            }
            switch (x) {
              case "%s":
                return String(args[i++]);
              case "%d":
                return Number(args[i++]);
              case "%j":
                try {
                  return JSON.stringify(args[i++]);
                } catch (_) {
                  return "[Circular]";
                }
                break;
              default:
                return x;
            }
          });
          return str;
        }
        return template;
      }
      function isNativeStringType(type4) {
        return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
      }
      function isEmptyValue(value, type4) {
        if (value === void 0 || value === null) {
          return true;
        }
        if (type4 === "array" && Array.isArray(value) && !value.length) {
          return true;
        }
        if (isNativeStringType(type4) && typeof value === "string" && !value) {
          return true;
        }
        return false;
      }
      function asyncParallelArray(arr, func, callback) {
        var results = [];
        var total = 0;
        var arrLength = arr.length;
        function count(errors) {
          results.push.apply(results, errors || []);
          total++;
          if (total === arrLength) {
            callback(results);
          }
        }
        arr.forEach(function(a) {
          func(a, count);
        });
      }
      function asyncSerialArray(arr, func, callback) {
        var index = 0;
        var arrLength = arr.length;
        function next(errors) {
          if (errors && errors.length) {
            callback(errors);
            return;
          }
          var original = index;
          index = index + 1;
          if (original < arrLength) {
            func(arr[original], next);
          } else {
            callback([]);
          }
        }
        next([]);
      }
      function flattenObjArr(objArr) {
        var ret = [];
        Object.keys(objArr).forEach(function(k) {
          ret.push.apply(ret, objArr[k] || []);
        });
        return ret;
      }
      var AsyncValidationError = (function(_Error) {
        _inheritsLoose(AsyncValidationError2, _Error);
        function AsyncValidationError2(errors, fields) {
          var _this;
          _this = _Error.call(this, "Async Validation Error") || this;
          _this.errors = errors;
          _this.fields = fields;
          return _this;
        }
        return AsyncValidationError2;
      })( _wrapNativeSuper(Error));
      function asyncMap(objArr, option, func, callback, source) {
        if (option.first) {
          var _pending = new Promise(function(resolve, reject) {
            var next = function next2(errors) {
              callback(errors);
              return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
            };
            var flattenArr = flattenObjArr(objArr);
            asyncSerialArray(flattenArr, func, next);
          });
          _pending["catch"](function(e) {
            return e;
          });
          return _pending;
        }
        var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
        var objArrKeys = Object.keys(objArr);
        var objArrLength = objArrKeys.length;
        var total = 0;
        var results = [];
        var pending = new Promise(function(resolve, reject) {
          var next = function next2(errors) {
            results.push.apply(results, errors);
            total++;
            if (total === objArrLength) {
              callback(results);
              return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
            }
          };
          if (!objArrKeys.length) {
            callback(results);
            resolve(source);
          }
          objArrKeys.forEach(function(key) {
            var arr = objArr[key];
            if (firstFields.indexOf(key) !== -1) {
              asyncSerialArray(arr, func, next);
            } else {
              asyncParallelArray(arr, func, next);
            }
          });
        });
        pending["catch"](function(e) {
          return e;
        });
        return pending;
      }
      function isErrorObj(obj) {
        return !!(obj && obj.message !== void 0);
      }
      function getValue(value, path) {
        var v = value;
        for (var i = 0; i < path.length; i++) {
          if (v == void 0) {
            return v;
          }
          v = v[path[i]];
        }
        return v;
      }
      function complementError(rule, source) {
        return function(oe) {
          var fieldValue;
          if (rule.fullFields) {
            fieldValue = getValue(source, rule.fullFields);
          } else {
            fieldValue = source[oe.field || rule.fullField];
          }
          if (isErrorObj(oe)) {
            oe.field = oe.field || rule.fullField;
            oe.fieldValue = fieldValue;
            return oe;
          }
          return {
            message: typeof oe === "function" ? oe() : oe,
            fieldValue,
            field: oe.field || rule.fullField
          };
        };
      }
      function deepMerge(target, source) {
        if (source) {
          for (var s in source) {
            if (source.hasOwnProperty(s)) {
              var value = source[s];
              if (typeof value === "object" && typeof target[s] === "object") {
                target[s] = _extends({}, target[s], value);
              } else {
                target[s] = value;
              }
            }
          }
        }
        return target;
      }
      var required$1 = function required(rule, value, source, errors, options, type4) {
        if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
          errors.push(format(options.messages.required, rule.fullField));
        }
      };
      var whitespace = function whitespace2(rule, value, source, errors, options) {
        if (/^\s+$/.test(value) || value === "") {
          errors.push(format(options.messages.whitespace, rule.fullField));
        }
      };
      var urlReg;
      var getUrlRegex = (function() {
        if (urlReg) {
          return urlReg;
        }
        var word = "[a-fA-F\\d:]";
        var b = function b2(options) {
          return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
        };
        var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
        var v6seg = "[a-fA-F\\d]{1,4}";
        var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
        var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
        var v4exact = new RegExp("^" + v4 + "$");
        var v6exact = new RegExp("^" + v6 + "$");
        var ip = function ip2(options) {
          return options && options.exact ? v46Exact : new RegExp("(?:" + b(options) + v4 + b(options) + ")|(?:" + b(options) + v6 + b(options) + ")", "g");
        };
        ip.v4 = function(options) {
          return options && options.exact ? v4exact : new RegExp("" + b(options) + v4 + b(options), "g");
        };
        ip.v6 = function(options) {
          return options && options.exact ? v6exact : new RegExp("" + b(options) + v6 + b(options), "g");
        };
        var protocol = "(?:(?:[a-z]+:)?//)";
        var auth = "(?:\\S+(?::\\S*)?@)?";
        var ipv4 = ip.v4().source;
        var ipv6 = ip.v6().source;
        var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
        var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
        var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
        var port = "(?::\\d{2,5})?";
        var path = '(?:[/?#][^\\s"]*)?';
        var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path;
        urlReg = new RegExp("(?:^" + regex + "$)", "i");
        return urlReg;
      });
      var pattern$2 = {
email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,



hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
      };
      var types = {
        integer: function integer(value) {
          return types.number(value) && parseInt(value, 10) === value;
        },
        "float": function float2(value) {
          return types.number(value) && !types.integer(value);
        },
        array: function array(value) {
          return Array.isArray(value);
        },
        regexp: function regexp(value) {
          if (value instanceof RegExp) {
            return true;
          }
          try {
            return !!new RegExp(value);
          } catch (e) {
            return false;
          }
        },
        date: function date(value) {
          return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
        },
        number: function number(value) {
          if (isNaN(value)) {
            return false;
          }
          return typeof value === "number";
        },
        object: function object(value) {
          return typeof value === "object" && !types.array(value);
        },
        method: function method(value) {
          return typeof value === "function";
        },
        email: function email(value) {
          return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
        },
        url: function url(value) {
          return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
        },
        hex: function hex2(value) {
          return typeof value === "string" && !!value.match(pattern$2.hex);
        }
      };
      var type$1 = function type(rule, value, source, errors, options) {
        if (rule.required && value === void 0) {
          required$1(rule, value, source, errors, options);
          return;
        }
        var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
        var ruleType = rule.type;
        if (custom.indexOf(ruleType) > -1) {
          if (!types[ruleType](value)) {
            errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
          }
        } else if (ruleType && typeof value !== rule.type) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
      };
      var range = function range2(rule, value, source, errors, options) {
        var len2 = typeof rule.len === "number";
        var min = typeof rule.min === "number";
        var max = typeof rule.max === "number";
        var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
        var val = value;
        var key = null;
        var num = typeof value === "number";
        var str = typeof value === "string";
        var arr = Array.isArray(value);
        if (num) {
          key = "number";
        } else if (str) {
          key = "string";
        } else if (arr) {
          key = "array";
        }
        if (!key) {
          return false;
        }
        if (arr) {
          val = value.length;
        }
        if (str) {
          val = value.replace(spRegexp, "_").length;
        }
        if (len2) {
          if (val !== rule.len) {
            errors.push(format(options.messages[key].len, rule.fullField, rule.len));
          }
        } else if (min && !max && val < rule.min) {
          errors.push(format(options.messages[key].min, rule.fullField, rule.min));
        } else if (max && !min && val > rule.max) {
          errors.push(format(options.messages[key].max, rule.fullField, rule.max));
        } else if (min && max && (val < rule.min || val > rule.max)) {
          errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
        }
      };
      var ENUM$1 = "enum";
      var enumerable$1 = function enumerable(rule, value, source, errors, options) {
        rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
        if (rule[ENUM$1].indexOf(value) === -1) {
          errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
        }
      };
      var pattern$1 = function pattern(rule, value, source, errors, options) {
        if (rule.pattern) {
          if (rule.pattern instanceof RegExp) {
            rule.pattern.lastIndex = 0;
            if (!rule.pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          } else if (typeof rule.pattern === "string") {
            var _pattern = new RegExp(rule.pattern);
            if (!_pattern.test(value)) {
              errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
            }
          }
        }
      };
      var rules = {
        required: required$1,
        whitespace,
        type: type$1,
        range,
        "enum": enumerable$1,
        pattern: pattern$1
      };
      var string = function string2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "string");
          if (!isEmptyValue(value, "string")) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
            rules.pattern(rule, value, source, errors, options);
            if (rule.whitespace === true) {
              rules.whitespace(rule, value, source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var method2 = function method3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var number2 = function number3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (value === "") {
            value = void 0;
          }
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var _boolean = function _boolean2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var regexp2 = function regexp3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var integer2 = function integer3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var floatFn = function floatFn2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var array2 = function array3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if ((value === void 0 || value === null) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, "array");
          if (value !== void 0 && value !== null) {
            rules.type(rule, value, source, errors, options);
            rules.range(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var object2 = function object3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var ENUM = "enum";
      var enumerable2 = function enumerable3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (value !== void 0) {
            rules[ENUM](rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var pattern2 = function pattern3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "string") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "string")) {
            rules.pattern(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var date2 = function date3(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, "date") && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
          if (!isEmptyValue(value, "date")) {
            var dateObject;
            if (value instanceof Date) {
              dateObject = value;
            } else {
              dateObject = new Date(value);
            }
            rules.type(rule, dateObject, source, errors, options);
            if (dateObject) {
              rules.range(rule, dateObject.getTime(), source, errors, options);
            }
          }
        }
        callback(errors);
      };
      var required2 = function required3(rule, value, callback, source, options) {
        var errors = [];
        var type4 = Array.isArray(value) ? "array" : typeof value;
        rules.required(rule, value, source, errors, options, type4);
        callback(errors);
      };
      var type2 = function type3(rule, value, callback, source, options) {
        var ruleType = rule.type;
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value, ruleType) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options, ruleType);
          if (!isEmptyValue(value, ruleType)) {
            rules.type(rule, value, source, errors, options);
          }
        }
        callback(errors);
      };
      var any = function any2(rule, value, callback, source, options) {
        var errors = [];
        var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
        if (validate) {
          if (isEmptyValue(value) && !rule.required) {
            return callback();
          }
          rules.required(rule, value, source, errors, options);
        }
        callback(errors);
      };
      var validators = {
        string,
        method: method2,
        number: number2,
        "boolean": _boolean,
        regexp: regexp2,
        integer: integer2,
        "float": floatFn,
        array: array2,
        object: object2,
        "enum": enumerable2,
        pattern: pattern2,
        date: date2,
        url: type2,
        hex: type2,
        email: type2,
        required: required2,
        any
      };
      function newMessages() {
        return {
          "default": "Validation error on field %s",
          required: "%s is required",
          "enum": "%s must be one of %s",
          whitespace: "%s cannot be empty",
          date: {
            format: "%s date %s is invalid for format %s",
            parse: "%s date could not be parsed, %s is invalid ",
            invalid: "%s date %s is invalid"
          },
          types: {
            string: "%s is not a %s",
            method: "%s is not a %s (function)",
            array: "%s is not an %s",
            object: "%s is not an %s",
            number: "%s is not a %s",
            date: "%s is not a %s",
            "boolean": "%s is not a %s",
            integer: "%s is not an %s",
            "float": "%s is not a %s",
            regexp: "%s is not a valid %s",
            email: "%s is not a valid %s",
            url: "%s is not a valid %s",
            hex: "%s is not a valid %s"
          },
          string: {
            len: "%s must be exactly %s characters",
            min: "%s must be at least %s characters",
            max: "%s cannot be longer than %s characters",
            range: "%s must be between %s and %s characters"
          },
          number: {
            len: "%s must equal %s",
            min: "%s cannot be less than %s",
            max: "%s cannot be greater than %s",
            range: "%s must be between %s and %s"
          },
          array: {
            len: "%s must be exactly %s in length",
            min: "%s cannot be less than %s in length",
            max: "%s cannot be greater than %s in length",
            range: "%s must be between %s and %s in length"
          },
          pattern: {
            mismatch: "%s value %s does not match pattern %s"
          },
          clone: function clone() {
            var cloned = JSON.parse(JSON.stringify(this));
            cloned.clone = this.clone;
            return cloned;
          }
        };
      }
      var messages = newMessages();
      var Schema = (function() {
        function Schema2(descriptor) {
          this.rules = null;
          this._messages = messages;
          this.define(descriptor);
        }
        var _proto = Schema2.prototype;
        _proto.define = function define(rules2) {
          var _this = this;
          if (!rules2) {
            throw new Error("Cannot configure a schema with no rules");
          }
          if (typeof rules2 !== "object" || Array.isArray(rules2)) {
            throw new Error("Rules must be an object");
          }
          this.rules = {};
          Object.keys(rules2).forEach(function(name) {
            var item = rules2[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        };
        _proto.messages = function messages2(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        };
        _proto.validate = function validate(source_, o, oc) {
          var _this2 = this;
          if (o === void 0) {
            o = {};
          }
          if (oc === void 0) {
            oc = function oc2() {
            };
          }
          var source = source_;
          var options = o;
          var callback = oc;
          if (typeof options === "function") {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add(e) {
              if (Array.isArray(e)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, e);
              } else {
                errors.push(e);
              }
            }
            for (var i = 0; i < results.length; i++) {
              add(results[i]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys2 = options.keys || Object.keys(this.rules);
          keys2.forEach(function(z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function(r) {
              var rule = r;
              if (typeof rule.transform === "function") {
                if (source === source_) {
                  source = _extends({}, source);
                }
                value = source[z] = rule.transform(value);
              }
              if (typeof rule === "function") {
                rule = {
                  validator: rule
                };
              } else {
                rule = _extends({}, rule);
              }
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this2.getType(rule);
              series[z] = series[z] || [];
              series[z].push({
                rule,
                value,
                source,
                field: z
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function(data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _extends({}, schema, {
                fullField: rule.fullField + "." + key,
                fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
              });
            }
            function cb(e) {
              if (e === void 0) {
                e = [];
              }
              var errorList = Array.isArray(e) ? e : [e];
              if (!options.suppressWarning && errorList.length) {
                Schema2.warning("async-validator:", errorList);
              }
              if (errorList.length && rule.message !== void 0) {
                errorList = [].concat(rule.message);
              }
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                if (rule.required && !data.value) {
                  if (rule.message !== void 0) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function(key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _extends({}, fieldsSchema, data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function(field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema2(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function(errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, filledErrors);
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, errs);
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                console.error == null ? void 0 : console.error(error);
                if (!options.suppressValidatorError) {
                  setTimeout(function() {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function() {
                return cb();
              }, function(e) {
                return cb(e);
              });
            }
          }, function(results) {
            complete(results);
          }, source);
        };
        _proto.getType = function getType(rule) {
          if (rule.type === void 0 && rule.pattern instanceof RegExp) {
            rule.type = "pattern";
          }
          if (typeof rule.validator !== "function" && rule.type && !validators.hasOwnProperty(rule.type)) {
            throw new Error(format("Unknown rule type %s", rule.type));
          }
          return rule.type || "string";
        };
        _proto.getValidationMethod = function getValidationMethod(rule) {
          if (typeof rule.validator === "function") {
            return rule.validator;
          }
          var keys2 = Object.keys(rule);
          var messageIndex = keys2.indexOf("message");
          if (messageIndex !== -1) {
            keys2.splice(messageIndex, 1);
          }
          if (keys2.length === 1 && keys2[0] === "required") {
            return validators.required;
          }
          return validators[this.getType(rule)] || void 0;
        };
        return Schema2;
      })();
      Schema.register = function register(type4, validator) {
        if (typeof validator !== "function") {
          throw new Error("Cannot register a validator by type, validator is not a function");
        }
        validators[type4] = validator;
      };
      Schema.warning = warning;
      Schema.messages = messages;
      Schema.validators = validators;
      const {
        cubicBezierEaseInOut
      } = commonVariables$e;
      function fadeDownTransition({
        name = "fade-down",
        fromOffset = "-4px",
        enterDuration = ".3s",
        leaveDuration = ".3s",
        enterCubicBezier = cubicBezierEaseInOut,
        leaveCubicBezier = cubicBezierEaseInOut
      } = {}) {
        return [c$1(`&.${name}-transition-enter-from, &.${name}-transition-leave-to`, {
          opacity: 0,
          transform: `translateY(${fromOffset})`
        }), c$1(`&.${name}-transition-enter-to, &.${name}-transition-leave-from`, {
          opacity: 1,
          transform: "translateY(0)"
        }), c$1(`&.${name}-transition-leave-active`, {
          transition: `opacity ${leaveDuration} ${leaveCubicBezier}, transform ${leaveDuration} ${leaveCubicBezier}`
        }), c$1(`&.${name}-transition-enter-active`, {
          transition: `opacity ${enterDuration} ${enterCubicBezier}, transform ${enterDuration} ${enterCubicBezier}`
        })];
      }
      const style$3 = cB("form-item", `
 display: grid;
 line-height: var(--n-line-height);
`, [cB("form-item-label", `
 grid-area: label;
 align-items: center;
 line-height: 1.25;
 text-align: var(--n-label-text-align);
 font-size: var(--n-label-font-size);
 min-height: var(--n-label-height);
 padding: var(--n-label-padding);
 color: var(--n-label-text-color);
 transition: color .3s var(--n-bezier);
 box-sizing: border-box;
 font-weight: var(--n-label-font-weight);
 `, [cE("asterisk", `
 white-space: nowrap;
 user-select: none;
 -webkit-user-select: none;
 color: var(--n-asterisk-color);
 transition: color .3s var(--n-bezier);
 `), cE("asterisk-placeholder", `
 grid-area: mark;
 user-select: none;
 -webkit-user-select: none;
 visibility: hidden; 
 `)]), cB("form-item-blank", `
 grid-area: blank;
 min-height: var(--n-blank-height);
 `), cM("auto-label-width", [cB("form-item-label", "white-space: nowrap;")]), cM("left-labelled", `
 grid-template-areas:
 "label blank"
 "label feedback";
 grid-template-columns: auto minmax(0, 1fr);
 grid-template-rows: auto 1fr;
 align-items: flex-start;
 `, [cB("form-item-label", `
 display: grid;
 grid-template-columns: 1fr auto;
 min-height: var(--n-blank-height);
 height: auto;
 box-sizing: border-box;
 flex-shrink: 0;
 flex-grow: 0;
 `, [cM("reverse-columns-space", `
 grid-template-columns: auto 1fr;
 `), cM("left-mark", `
 grid-template-areas:
 "mark text"
 ". text";
 `), cM("right-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cM("right-hanging-mark", `
 grid-template-areas: 
 "text mark"
 "text .";
 `), cE("text", `
 grid-area: text; 
 `), cE("asterisk", `
 grid-area: mark; 
 align-self: end;
 `)])]), cM("top-labelled", `
 grid-template-areas:
 "label"
 "blank"
 "feedback";
 grid-template-rows: minmax(var(--n-label-height), auto) 1fr;
 grid-template-columns: minmax(0, 100%);
 `, [cM("no-label", `
 grid-template-areas:
 "blank"
 "feedback";
 grid-template-rows: 1fr;
 `), cB("form-item-label", `
 display: flex;
 align-items: flex-start;
 justify-content: var(--n-label-text-align);
 `)]), cB("form-item-blank", `
 box-sizing: border-box;
 display: flex;
 align-items: center;
 position: relative;
 `), cB("form-item-feedback-wrapper", `
 grid-area: feedback;
 box-sizing: border-box;
 min-height: var(--n-feedback-height);
 font-size: var(--n-feedback-font-size);
 line-height: 1.25;
 transform-origin: top left;
 `, [c$1("&:not(:empty)", `
 padding: var(--n-feedback-padding);
 `), cB("form-item-feedback", {
        transition: "color .3s var(--n-bezier)",
        color: "var(--n-feedback-text-color)"
      }, [cM("warning", {
        color: "var(--n-feedback-text-color-warning)"
      }), cM("error", {
        color: "var(--n-feedback-text-color-error)"
      }), fadeDownTransition({
        fromOffset: "-3px",
        enterDuration: ".3s",
        leaveDuration: ".2s"
      })])])]);
      function formItemSize(props) {
        const NForm2 = vue.inject(formInjectionKey, null);
        return {
          mergedSize: vue.computed(() => {
            if (props.size !== void 0) return props.size;
            if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.size) !== void 0) return NForm2.props.size;
            return "medium";
          })
        };
      }
      function formItemMisc(props) {
        const NForm2 = vue.inject(formInjectionKey, null);
        const mergedLabelPlacementRef = vue.computed(() => {
          const {
            labelPlacement
          } = props;
          if (labelPlacement !== void 0) return labelPlacement;
          if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelPlacement) return NForm2.props.labelPlacement;
          return "top";
        });
        const isAutoLabelWidthRef = vue.computed(() => {
          return mergedLabelPlacementRef.value === "left" && (props.labelWidth === "auto" || (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) === "auto");
        });
        const mergedLabelWidthRef = vue.computed(() => {
          if (mergedLabelPlacementRef.value === "top") return;
          const {
            labelWidth
          } = props;
          if (labelWidth !== void 0 && labelWidth !== "auto") {
            return formatLength(labelWidth);
          }
          if (isAutoLabelWidthRef.value) {
            const autoComputedWidth = NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.maxChildLabelWidthRef.value;
            if (autoComputedWidth !== void 0) {
              return formatLength(autoComputedWidth);
            } else {
              return void 0;
            }
          }
          if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelWidth) !== void 0) {
            return formatLength(NForm2.props.labelWidth);
          }
          return void 0;
        });
        const mergedLabelAlignRef = vue.computed(() => {
          const {
            labelAlign
          } = props;
          if (labelAlign) return labelAlign;
          if (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.labelAlign) return NForm2.props.labelAlign;
          return void 0;
        });
        const mergedLabelStyleRef = vue.computed(() => {
          var _a;
          return [(_a = props.labelProps) === null || _a === void 0 ? void 0 : _a.style, props.labelStyle, {
            width: mergedLabelWidthRef.value
          }];
        });
        const mergedShowRequireMarkRef = vue.computed(() => {
          const {
            showRequireMark
          } = props;
          if (showRequireMark !== void 0) return showRequireMark;
          return NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showRequireMark;
        });
        const mergedRequireMarkPlacementRef = vue.computed(() => {
          const {
            requireMarkPlacement
          } = props;
          if (requireMarkPlacement !== void 0) return requireMarkPlacement;
          return (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.requireMarkPlacement) || "right";
        });
        const validationErroredRef = vue.ref(false);
        const validationWarnedRef = vue.ref(false);
        const mergedValidationStatusRef = vue.computed(() => {
          const {
            validationStatus
          } = props;
          if (validationStatus !== void 0) return validationStatus;
          if (validationErroredRef.value) return "error";
          if (validationWarnedRef.value) return "warning";
          return void 0;
        });
        const mergedShowFeedbackRef = vue.computed(() => {
          const {
            showFeedback
          } = props;
          if (showFeedback !== void 0) return showFeedback;
          if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showFeedback) !== void 0) return NForm2.props.showFeedback;
          return true;
        });
        const mergedShowLabelRef = vue.computed(() => {
          const {
            showLabel
          } = props;
          if (showLabel !== void 0) return showLabel;
          if ((NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props.showLabel) !== void 0) return NForm2.props.showLabel;
          return true;
        });
        return {
          validationErrored: validationErroredRef,
          validationWarned: validationWarnedRef,
          mergedLabelStyle: mergedLabelStyleRef,
          mergedLabelPlacement: mergedLabelPlacementRef,
          mergedLabelAlign: mergedLabelAlignRef,
          mergedShowRequireMark: mergedShowRequireMarkRef,
          mergedRequireMarkPlacement: mergedRequireMarkPlacementRef,
          mergedValidationStatus: mergedValidationStatusRef,
          mergedShowFeedback: mergedShowFeedbackRef,
          mergedShowLabel: mergedShowLabelRef,
          isAutoLabelWidth: isAutoLabelWidthRef
        };
      }
      function formItemRule(props) {
        const NForm2 = vue.inject(formInjectionKey, null);
        const compatibleRulePathRef = vue.computed(() => {
          const {
            rulePath
          } = props;
          if (rulePath !== void 0) return rulePath;
          const {
            path
          } = props;
          if (path !== void 0) return path;
          return void 0;
        });
        const mergedRulesRef = vue.computed(() => {
          const rules2 = [];
          const {
            rule
          } = props;
          if (rule !== void 0) {
            if (Array.isArray(rule)) rules2.push(...rule);
            else rules2.push(rule);
          }
          if (NForm2) {
            const {
              rules: formRules
            } = NForm2.props;
            const {
              value: rulePath
            } = compatibleRulePathRef;
            if (formRules !== void 0 && rulePath !== void 0) {
              const formRule = get(formRules, rulePath);
              if (formRule !== void 0) {
                if (Array.isArray(formRule)) {
                  rules2.push(...formRule);
                } else {
                  rules2.push(formRule);
                }
              }
            }
          }
          return rules2;
        });
        const hasRequiredRuleRef = vue.computed(() => {
          return mergedRulesRef.value.some((rule) => rule.required);
        });
        const mergedRequiredRef = vue.computed(() => {
          return hasRequiredRuleRef.value || props.required;
        });
        return {
          mergedRules: mergedRulesRef,
          mergedRequired: mergedRequiredRef
        };
      }
      var __awaiter = function(thisArg, _arguments, P, generator) {
        function adopt(value) {
          return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
          });
        }
        return new (P || (P = Promise))(function(resolve, reject) {
          function fulfilled(value) {
            try {
              step(generator.next(value));
            } catch (e) {
              reject(e);
            }
          }
          function rejected(value) {
            try {
              step(generator["throw"](value));
            } catch (e) {
              reject(e);
            }
          }
          function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
          }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
      };
      const formItemProps = Object.assign(Object.assign({}, useTheme.props), {
        label: String,
        labelWidth: [Number, String],
        labelStyle: [String, Object],
        labelAlign: String,
        labelPlacement: String,
        path: String,
        first: Boolean,
        rulePath: String,
        required: Boolean,
        showRequireMark: {
          type: Boolean,
          default: void 0
        },
        requireMarkPlacement: String,
        showFeedback: {
          type: Boolean,
          default: void 0
        },
        rule: [Object, Array],
        size: String,
        ignorePathChange: Boolean,
        validationStatus: String,
        feedback: String,
        feedbackClass: String,
        feedbackStyle: [String, Object],
        showLabel: {
          type: Boolean,
          default: void 0
        },
        labelProps: Object,
        contentClass: String,
        contentStyle: [String, Object]
      });
      function wrapValidator(validator, async) {
        return (...args) => {
          try {
            const validateResult = validator(...args);
            if (!async && (typeof validateResult === "boolean" || validateResult instanceof Error || Array.isArray(validateResult)) || (validateResult === null || validateResult === void 0 ? void 0 : validateResult.then)) {
              return validateResult;
            } else if (validateResult === void 0) {
              return true;
            } else {
              warn("form-item/validate", `You return a ${typeof validateResult} typed value in the validator method, which is not recommended. Please use ${async ? "`Promise`" : "`boolean`, `Error` or `Promise`"} typed value instead.`);
              return true;
            }
          } catch (err) {
            warn("form-item/validate", "An error is catched in the validation, so the validation won't be done. Your callback in `validate` method of `n-form` or `n-form-item` won't be called in this validation.");
            console.error(err);
            return void 0;
          }
        };
      }
      const NFormItem = vue.defineComponent({
        name: "FormItem",
        props: formItemProps,
        setup(props) {
          useInjectionInstanceCollection(formItemInstsInjectionKey, "formItems", vue.toRef(props, "path"));
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled
          } = useConfig(props);
          const NForm2 = vue.inject(formInjectionKey, null);
          const formItemSizeRefs = formItemSize(props);
          const formItemMiscRefs = formItemMisc(props);
          const {
            validationErrored: validationErroredRef,
            validationWarned: validationWarnedRef
          } = formItemMiscRefs;
          const {
            mergedRequired: mergedRequiredRef,
            mergedRules: mergedRulesRef
          } = formItemRule(props);
          const {
            mergedSize: mergedSizeRef
          } = formItemSizeRefs;
          const {
            mergedLabelPlacement: labelPlacementRef,
            mergedLabelAlign: labelTextAlignRef,
            mergedRequireMarkPlacement: mergedRequireMarkPlacementRef
          } = formItemMiscRefs;
          const renderExplainsRef = vue.ref([]);
          const feedbackIdRef = vue.ref(createId());
          const mergedDisabledRef = NForm2 ? vue.toRef(NForm2.props, "disabled") : vue.ref(false);
          const themeRef = useTheme("Form", "-form-item", style$3, formLight, props, mergedClsPrefixRef);
          vue.watch(vue.toRef(props, "path"), () => {
            if (props.ignorePathChange) return;
            restoreValidation();
          });
          function restoreValidation() {
            renderExplainsRef.value = [];
            validationErroredRef.value = false;
            validationWarnedRef.value = false;
            if (props.feedback) {
              feedbackIdRef.value = createId();
            }
          }
          const internalValidate = (...args_1) => __awaiter(this, [...args_1], void 0, function* (trigger2 = null, shouldRuleBeApplied = () => true, options = {
            suppressWarning: true
          }) {
            const {
              path
            } = props;
            if (!options) {
              options = {};
            } else {
              if (!options.first) options.first = props.first;
            }
            const {
              value: rules2
            } = mergedRulesRef;
            const value = NForm2 ? get(NForm2.props.model, path || "") : void 0;
            const messageRenderers = {};
            const originalMessageRendersMessage = {};
            const activeRules = (!trigger2 ? rules2 : rules2.filter((rule) => {
              if (Array.isArray(rule.trigger)) {
                return rule.trigger.includes(trigger2);
              } else {
                return rule.trigger === trigger2;
              }
            })).filter(shouldRuleBeApplied).map((rule, i) => {
              const shallowClonedRule = Object.assign({}, rule);
              if (shallowClonedRule.validator) {
                shallowClonedRule.validator = wrapValidator(shallowClonedRule.validator, false);
              }
              if (shallowClonedRule.asyncValidator) {
                shallowClonedRule.asyncValidator = wrapValidator(shallowClonedRule.asyncValidator, true);
              }
              if (shallowClonedRule.renderMessage) {
                const rendererKey = `__renderMessage__${i}`;
                originalMessageRendersMessage[rendererKey] = shallowClonedRule.message;
                shallowClonedRule.message = rendererKey;
                messageRenderers[rendererKey] = shallowClonedRule.renderMessage;
              }
              return shallowClonedRule;
            });
            const activeErrorRules = activeRules.filter((r) => r.level !== "warning");
            const activeWarningRules = activeRules.filter((r) => r.level === "warning");
            const validationResult = {
              valid: true,
              errors: void 0,
              warnings: void 0
            };
            if (!activeRules.length) return validationResult;
            const mergedPath = path !== null && path !== void 0 ? path : "__n_no_path__";
            const validator = new Schema({
              [mergedPath]: activeErrorRules
            });
            const warningValidator = new Schema({
              [mergedPath]: activeWarningRules
            });
            const {
              validateMessages
            } = (NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.props) || {};
            if (validateMessages) {
              validator.messages(validateMessages);
              warningValidator.messages(validateMessages);
            }
            const renderMessages = (errors) => {
              renderExplainsRef.value = errors.map((error) => {
                const transformedMessage = (error === null || error === void 0 ? void 0 : error.message) || "";
                return {
                  key: transformedMessage,
                  render: () => {
                    if (transformedMessage.startsWith("__renderMessage__")) {
                      return messageRenderers[transformedMessage]();
                    }
                    return transformedMessage;
                  }
                };
              });
              errors.forEach((error) => {
                var _a;
                if ((_a = error.message) === null || _a === void 0 ? void 0 : _a.startsWith("__renderMessage__")) {
                  error.message = originalMessageRendersMessage[error.message];
                }
              });
            };
            if (activeErrorRules.length) {
              const errors = yield new Promise((resolve) => {
                void validator.validate({
                  [mergedPath]: value
                }, options, resolve);
              });
              if (errors === null || errors === void 0 ? void 0 : errors.length) {
                validationResult.valid = false;
                validationResult.errors = errors;
                renderMessages(errors);
              }
            }
            if (activeWarningRules.length && !validationResult.errors) {
              const warnings = yield new Promise((resolve) => {
                void warningValidator.validate({
                  [mergedPath]: value
                }, options, resolve);
              });
              if (warnings === null || warnings === void 0 ? void 0 : warnings.length) {
                renderMessages(warnings);
                validationResult.warnings = warnings;
              }
            }
            if (!validationResult.errors && !validationResult.warnings) {
              restoreValidation();
            } else {
              validationErroredRef.value = !!validationResult.errors;
              validationWarnedRef.value = !!validationResult.warnings;
            }
            return validationResult;
          });
          function handleContentBlur() {
            void internalValidate("blur");
          }
          function handleContentChange() {
            void internalValidate("change");
          }
          function handleContentFocus() {
            void internalValidate("focus");
          }
          function handleContentInput() {
            void internalValidate("input");
          }
          function validate(options, callback) {
            return __awaiter(this, void 0, void 0, function* () {
              let trigger2;
              let validateCallback;
              let shouldRuleBeApplied;
              let asyncValidatorOptions;
              if (typeof options === "string") {
                trigger2 = options;
                validateCallback = callback;
              } else if (options !== null && typeof options === "object") {
                trigger2 = options.trigger;
                validateCallback = options.callback;
                shouldRuleBeApplied = options.shouldRuleBeApplied;
                asyncValidatorOptions = options.options;
              }
              return yield new Promise((resolve, reject) => {
                void internalValidate(trigger2, shouldRuleBeApplied, asyncValidatorOptions).then(({
                  valid,
                  errors,
                  warnings
                }) => {
                  if (valid) {
                    if (validateCallback) {
                      validateCallback(void 0, {
                        warnings
                      });
                    }
                    resolve({
                      warnings
                    });
                  } else {
                    if (validateCallback) {
                      validateCallback(errors, {
                        warnings
                      });
                    }
                    reject(errors);
                  }
                });
              });
            });
          }
          vue.provide(formItemInjectionKey, {
            path: vue.toRef(props, "path"),
            disabled: mergedDisabledRef,
            mergedSize: formItemSizeRefs.mergedSize,
            mergedValidationStatus: formItemMiscRefs.mergedValidationStatus,
            restoreValidation,
            handleContentBlur,
            handleContentChange,
            handleContentFocus,
            handleContentInput
          });
          const exposedRef = {
            validate,
            restoreValidation,
            internalValidate
          };
          const labelElementRef = vue.ref(null);
          vue.onMounted(() => {
            if (!formItemMiscRefs.isAutoLabelWidth.value) return;
            const labelElement = labelElementRef.value;
            if (labelElement !== null) {
              const memoizedWhitespace = labelElement.style.whiteSpace;
              labelElement.style.whiteSpace = "nowrap";
              labelElement.style.width = "";
              NForm2 === null || NForm2 === void 0 ? void 0 : NForm2.deriveMaxChildLabelWidth(Number(getComputedStyle(labelElement).width.slice(0, -2)));
              labelElement.style.whiteSpace = memoizedWhitespace;
            }
          });
          const cssVarsRef = vue.computed(() => {
            var _a;
            const {
              value: size2
            } = mergedSizeRef;
            const {
              value: labelPlacement
            } = labelPlacementRef;
            const direction = labelPlacement === "top" ? "vertical" : "horizontal";
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                labelTextColor,
                asteriskColor,
                lineHeight: lineHeight2,
                feedbackTextColor,
                feedbackTextColorWarning,
                feedbackTextColorError,
                feedbackPadding,
                labelFontWeight,
                [createKey("labelHeight", size2)]: labelHeight,
                [createKey("blankHeight", size2)]: blankHeight,
                [createKey("feedbackFontSize", size2)]: feedbackFontSize,
                [createKey("feedbackHeight", size2)]: feedbackHeight,
                [createKey("labelPadding", direction)]: labelPadding,
                [createKey("labelTextAlign", direction)]: labelTextAlign,
                [createKey(createKey("labelFontSize", labelPlacement), size2)]: labelFontSize
              }
            } = themeRef.value;
            let mergedLabelTextAlign = (_a = labelTextAlignRef.value) !== null && _a !== void 0 ? _a : labelTextAlign;
            if (labelPlacement === "top") {
              mergedLabelTextAlign = mergedLabelTextAlign === "right" ? "flex-end" : "flex-start";
            }
            const cssVars = {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-line-height": lineHeight2,
              "--n-blank-height": blankHeight,
              "--n-label-font-size": labelFontSize,
              "--n-label-text-align": mergedLabelTextAlign,
              "--n-label-height": labelHeight,
              "--n-label-padding": labelPadding,
              "--n-label-font-weight": labelFontWeight,
              "--n-asterisk-color": asteriskColor,
              "--n-label-text-color": labelTextColor,
              "--n-feedback-padding": feedbackPadding,
              "--n-feedback-font-size": feedbackFontSize,
              "--n-feedback-height": feedbackHeight,
              "--n-feedback-text-color": feedbackTextColor,
              "--n-feedback-text-color-warning": feedbackTextColorWarning,
              "--n-feedback-text-color-error": feedbackTextColorError
            };
            return cssVars;
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("form-item", vue.computed(() => {
            var _a;
            return `${mergedSizeRef.value[0]}${labelPlacementRef.value[0]}${((_a = labelTextAlignRef.value) === null || _a === void 0 ? void 0 : _a[0]) || ""}`;
          }), cssVarsRef, props) : void 0;
          const reverseColSpaceRef = vue.computed(() => {
            return labelPlacementRef.value === "left" && mergedRequireMarkPlacementRef.value === "left" && labelTextAlignRef.value === "left";
          });
          return Object.assign(Object.assign(Object.assign(Object.assign({
            labelElementRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedRequired: mergedRequiredRef,
            feedbackId: feedbackIdRef,
            renderExplains: renderExplainsRef,
            reverseColSpace: reverseColSpaceRef
          }, formItemMiscRefs), formItemSizeRefs), exposedRef), {
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          const {
            $slots,
            mergedClsPrefix,
            mergedShowLabel,
            mergedShowRequireMark,
            mergedRequireMarkPlacement,
            onRender
          } = this;
          const renderedShowRequireMark = mergedShowRequireMark !== void 0 ? mergedShowRequireMark : this.mergedRequired;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const renderLabel = () => {
            const labelText = this.$slots.label ? this.$slots.label() : this.label;
            if (!labelText) return null;
            const textNode = vue.h("span", {
              class: `${mergedClsPrefix}-form-item-label__text`
            }, labelText);
            const markNode = renderedShowRequireMark ? vue.h("span", {
              class: `${mergedClsPrefix}-form-item-label__asterisk`
            }, mergedRequireMarkPlacement !== "left" ? " *" : "* ") : mergedRequireMarkPlacement === "right-hanging" && vue.h("span", {
              class: `${mergedClsPrefix}-form-item-label__asterisk-placeholder`
            }, " *");
            const {
              labelProps
            } = this;
            return vue.h("label", Object.assign({}, labelProps, {
              class: [labelProps === null || labelProps === void 0 ? void 0 : labelProps.class, `${mergedClsPrefix}-form-item-label`, `${mergedClsPrefix}-form-item-label--${mergedRequireMarkPlacement}-mark`, this.reverseColSpace && `${mergedClsPrefix}-form-item-label--reverse-columns-space`],
              style: this.mergedLabelStyle,
              ref: "labelElementRef"
            }), mergedRequireMarkPlacement === "left" ? [markNode, textNode] : [textNode, markNode]);
          };
          return vue.h("div", {
            class: [`${mergedClsPrefix}-form-item`, this.themeClass, `${mergedClsPrefix}-form-item--${this.mergedSize}-size`, `${mergedClsPrefix}-form-item--${this.mergedLabelPlacement}-labelled`, this.isAutoLabelWidth && `${mergedClsPrefix}-form-item--auto-label-width`, !mergedShowLabel && `${mergedClsPrefix}-form-item--no-label`],
            style: this.cssVars
          }, mergedShowLabel && renderLabel(), vue.h("div", {
            class: [`${mergedClsPrefix}-form-item-blank`, this.contentClass, this.mergedValidationStatus && `${mergedClsPrefix}-form-item-blank--${this.mergedValidationStatus}`],
            style: this.contentStyle
          }, $slots), this.mergedShowFeedback ? vue.h("div", {
            key: this.feedbackId,
            style: this.feedbackStyle,
            class: [`${mergedClsPrefix}-form-item-feedback-wrapper`, this.feedbackClass]
          }, vue.h(vue.Transition, {
            name: "fade-down-transition",
            mode: "out-in"
          }, {
            default: () => {
              const {
                mergedValidationStatus
              } = this;
              return resolveWrappedSlot($slots.feedback, (children) => {
                var _a;
                const {
                  feedback
                } = this;
                const feedbackNodes = children || feedback ? vue.h("div", {
                  key: "__feedback__",
                  class: `${mergedClsPrefix}-form-item-feedback__line`
                }, children || feedback) : this.renderExplains.length ? (_a = this.renderExplains) === null || _a === void 0 ? void 0 : _a.map(({
                  key,
                  render: render2
                }) => vue.h("div", {
                  key,
                  class: `${mergedClsPrefix}-form-item-feedback__line`
                }, render2())) : null;
                return feedbackNodes ? mergedValidationStatus === "warning" ? vue.h("div", {
                  key: "controlled-warning",
                  class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--warning`
                }, feedbackNodes) : mergedValidationStatus === "error" ? vue.h("div", {
                  key: "controlled-error",
                  class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--error`
                }, feedbackNodes) : mergedValidationStatus === "success" ? vue.h("div", {
                  key: "controlled-success",
                  class: `${mergedClsPrefix}-form-item-feedback ${mergedClsPrefix}-form-item-feedback--success`
                }, feedbackNodes) : vue.h("div", {
                  key: "controlled-default",
                  class: `${mergedClsPrefix}-form-item-feedback`
                }, feedbackNodes) : null;
              });
            }
          })) : null);
        }
      });
      const popconfirmInjectionKey = createInjectionKey("n-popconfirm");
      const panelProps = {
        positiveText: String,
        negativeText: String,
        showIcon: {
          type: Boolean,
          default: true
        },
        onPositiveClick: {
          type: Function,
          required: true
        },
        onNegativeClick: {
          type: Function,
          required: true
        }
      };
      const panelPropKeys = keysOf(panelProps);
      const PopconfirmPanel = vue.defineComponent({
        name: "NPopconfirmPanel",
        props: panelProps,
        setup(props) {
          const {
            localeRef
          } = useLocale("Popconfirm");
          const {
            inlineThemeDisabled
          } = useConfig();
          const {
            mergedClsPrefixRef,
            mergedThemeRef,
            props: popconfirmProps2
          } = vue.inject(popconfirmInjectionKey);
          const cssVarsRef = vue.computed(() => {
            const {
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              },
              self: {
                fontSize: fontSize2,
                iconSize,
                iconColor
              }
            } = mergedThemeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-font-size": fontSize2,
              "--n-icon-size": iconSize,
              "--n-icon-color": iconColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("popconfirm-panel", void 0, cssVarsRef, popconfirmProps2) : void 0;
          return Object.assign(Object.assign({}, useLocale("Popconfirm")), {
            mergedClsPrefix: mergedClsPrefixRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            localizedPositiveText: vue.computed(() => {
              return props.positiveText || localeRef.value.positiveText;
            }),
            localizedNegativeText: vue.computed(() => {
              return props.negativeText || localeRef.value.negativeText;
            }),
            positiveButtonProps: vue.toRef(popconfirmProps2, "positiveButtonProps"),
            negativeButtonProps: vue.toRef(popconfirmProps2, "negativeButtonProps"),
            handlePositiveClick(e) {
              props.onPositiveClick(e);
            },
            handleNegativeClick(e) {
              props.onNegativeClick(e);
            },
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          });
        },
        render() {
          var _a;
          const {
            mergedClsPrefix,
            showIcon,
            $slots
          } = this;
          const actionContentNode = resolveSlot($slots.action, () => this.negativeText === null && this.positiveText === null ? [] : [this.negativeText !== null && vue.h(Button, Object.assign({
            size: "small",
            onClick: this.handleNegativeClick
          }, this.negativeButtonProps), {
            default: () => this.localizedNegativeText
          }), this.positiveText !== null && vue.h(Button, Object.assign({
            size: "small",
            type: "primary",
            onClick: this.handlePositiveClick
          }, this.positiveButtonProps), {
            default: () => this.localizedPositiveText
          })]);
          (_a = this.onRender) === null || _a === void 0 ? void 0 : _a.call(this);
          return vue.h("div", {
            class: [`${mergedClsPrefix}-popconfirm__panel`, this.themeClass],
            style: this.cssVars
          }, resolveWrappedSlot($slots.default, (children) => showIcon || children ? vue.h("div", {
            class: `${mergedClsPrefix}-popconfirm__body`
          }, showIcon ? vue.h("div", {
            class: `${mergedClsPrefix}-popconfirm__icon`
          }, resolveSlot($slots.icon, () => [vue.h(NBaseIcon, {
            clsPrefix: mergedClsPrefix
          }, {
            default: () => vue.h(WarningIcon, null)
          })])) : null, children) : null), actionContentNode ? vue.h("div", {
            class: [`${mergedClsPrefix}-popconfirm__action`]
          }, actionContentNode) : null);
        }
      });
      const style$2 = cB("popconfirm", [cE("body", `
 font-size: var(--n-font-size);
 display: flex;
 align-items: center;
 flex-wrap: nowrap;
 position: relative;
 `, [cE("icon", `
 display: flex;
 font-size: var(--n-icon-size);
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 margin: 0 8px 0 0;
 `)]), cE("action", `
 display: flex;
 justify-content: flex-end;
 `, [c$1("&:not(:first-child)", "margin-top: 8px"), cB("button", [c$1("&:not(:last-child)", "margin-right: 8px;")])])]);
      const popconfirmProps = Object.assign(Object.assign(Object.assign({}, useTheme.props), popoverBaseProps), {
        positiveText: String,
        negativeText: String,
        showIcon: {
          type: Boolean,
          default: true
        },
        trigger: {
          type: String,
          default: "click"
        },
        positiveButtonProps: Object,
        negativeButtonProps: Object,
        onPositiveClick: Function,
        onNegativeClick: Function
      });
      const NPopconfirm = vue.defineComponent({
        name: "Popconfirm",
        props: popconfirmProps,
        slots: Object,
        __popover__: true,
        setup(props) {
          const {
            mergedClsPrefixRef
          } = useConfig();
          const themeRef = useTheme("Popconfirm", "-popconfirm", style$2, popconfirmLight, props, mergedClsPrefixRef);
          const popoverInstRef = vue.ref(null);
          function handlePositiveClick(e) {
            var _a;
            if (!((_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.getMergedShow())) return;
            const {
              onPositiveClick,
              "onUpdate:show": onUpdateShow
            } = props;
            void Promise.resolve(onPositiveClick ? onPositiveClick(e) : true).then((value) => {
              var _a2;
              if (value === false) return;
              (_a2 = popoverInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.setShow(false);
              if (onUpdateShow) call(onUpdateShow, false);
            });
          }
          function handleNegativeClick(e) {
            var _a;
            if (!((_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.getMergedShow())) return;
            const {
              onNegativeClick,
              "onUpdate:show": onUpdateShow
            } = props;
            void Promise.resolve(onNegativeClick ? onNegativeClick(e) : true).then((value) => {
              var _a2;
              if (value === false) return;
              (_a2 = popoverInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.setShow(false);
              if (onUpdateShow) call(onUpdateShow, false);
            });
          }
          vue.provide(popconfirmInjectionKey, {
            mergedThemeRef: themeRef,
            mergedClsPrefixRef,
            props
          });
          const returned = {
            setShow(value) {
              var _a;
              (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.setShow(value);
            },
            syncPosition() {
              var _a;
              (_a = popoverInstRef.value) === null || _a === void 0 ? void 0 : _a.syncPosition();
            },
            mergedTheme: themeRef,
            popoverInstRef,
            handlePositiveClick,
            handleNegativeClick
          };
          return returned;
        },
        render() {
          const {
            $slots: slots,
            $props: props,
            mergedTheme
          } = this;
          return vue.h(NPopover, Object.assign({}, omit(props, panelPropKeys), {
            theme: mergedTheme.peers.Popover,
            themeOverrides: mergedTheme.peerOverrides.Popover,
            internalExtraClass: ["popconfirm"],
            ref: "popoverInstRef"
          }), {
            trigger: slots.trigger,
            default: () => {
              const panelProps2 = keep(props, panelPropKeys);
              return vue.h(PopconfirmPanel, Object.assign({}, panelProps2, {
                onPositiveClick: this.handlePositiveClick,
                onNegativeClick: this.handleNegativeClick
              }), slots);
            }
          });
        }
      });
      const style$1 = cB("switch", `
 height: var(--n-height);
 min-width: var(--n-width);
 vertical-align: middle;
 user-select: none;
 -webkit-user-select: none;
 display: inline-flex;
 outline: none;
 justify-content: center;
 align-items: center;
`, [cE("children-placeholder", `
 height: var(--n-rail-height);
 display: flex;
 flex-direction: column;
 overflow: hidden;
 pointer-events: none;
 visibility: hidden;
 `), cE("rail-placeholder", `
 display: flex;
 flex-wrap: none;
 `), cE("button-placeholder", `
 width: calc(1.75 * var(--n-rail-height));
 height: var(--n-rail-height);
 `), cB("base-loading", `
 position: absolute;
 top: 50%;
 left: 50%;
 transform: translateX(-50%) translateY(-50%);
 font-size: calc(var(--n-button-width) - 4px);
 color: var(--n-loading-color);
 transition: color .3s var(--n-bezier);
 `, [iconSwitchTransition({
        left: "50%",
        top: "50%",
        originalTransform: "translateX(-50%) translateY(-50%)"
      })]), cE("checked, unchecked", `
 transition: color .3s var(--n-bezier);
 color: var(--n-text-color);
 box-sizing: border-box;
 position: absolute;
 white-space: nowrap;
 top: 0;
 bottom: 0;
 display: flex;
 align-items: center;
 line-height: 1;
 `), cE("checked", `
 right: 0;
 padding-right: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), cE("unchecked", `
 left: 0;
 justify-content: flex-end;
 padding-left: calc(1.25 * var(--n-rail-height) - var(--n-offset));
 `), c$1("&:focus", [cE("rail", `
 box-shadow: var(--n-box-shadow-focus);
 `)]), cM("round", [cE("rail", "border-radius: calc(var(--n-rail-height) / 2);", [cE("button", "border-radius: calc(var(--n-button-height) / 2);")])]), cNotM("disabled", [cNotM("icon", [cM("rubber-band", [cM("pressed", [cE("rail", [cE("button", "max-width: var(--n-button-width-pressed);")])]), cE("rail", [c$1("&:active", [cE("button", "max-width: var(--n-button-width-pressed);")])]), cM("active", [cM("pressed", [cE("rail", [cE("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])]), cE("rail", [c$1("&:active", [cE("button", "left: calc(100% - var(--n-offset) - var(--n-button-width-pressed));")])])])])])]), cM("active", [cE("rail", [cE("button", "left: calc(100% - var(--n-button-width) - var(--n-offset))")])]), cE("rail", `
 overflow: hidden;
 height: var(--n-rail-height);
 min-width: var(--n-rail-width);
 border-radius: var(--n-rail-border-radius);
 cursor: pointer;
 position: relative;
 transition:
 opacity .3s var(--n-bezier),
 background .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 background-color: var(--n-rail-color);
 `, [cE("button-icon", `
 color: var(--n-icon-color);
 transition: color .3s var(--n-bezier);
 font-size: calc(var(--n-button-height) - 4px);
 position: absolute;
 left: 0;
 right: 0;
 top: 0;
 bottom: 0;
 display: flex;
 justify-content: center;
 align-items: center;
 line-height: 1;
 `, [iconSwitchTransition()]), cE("button", `
 align-items: center; 
 top: var(--n-offset);
 left: var(--n-offset);
 height: var(--n-button-height);
 width: var(--n-button-width-pressed);
 max-width: var(--n-button-width);
 border-radius: var(--n-button-border-radius);
 background-color: var(--n-button-color);
 box-shadow: var(--n-button-box-shadow);
 box-sizing: border-box;
 cursor: inherit;
 content: "";
 position: absolute;
 transition:
 background-color .3s var(--n-bezier),
 left .3s var(--n-bezier),
 opacity .3s var(--n-bezier),
 max-width .3s var(--n-bezier),
 box-shadow .3s var(--n-bezier);
 `)]), cM("active", [cE("rail", "background-color: var(--n-rail-color-active);")]), cM("loading", [cE("rail", `
 cursor: wait;
 `)]), cM("disabled", [cE("rail", `
 cursor: not-allowed;
 opacity: .5;
 `)])]);
      const switchProps = Object.assign(Object.assign({}, useTheme.props), {
        size: {
          type: String,
          default: "medium"
        },
        value: {
          type: [String, Number, Boolean],
          default: void 0
        },
        loading: Boolean,
        defaultValue: {
          type: [String, Number, Boolean],
          default: false
        },
        disabled: {
          type: Boolean,
          default: void 0
        },
        round: {
          type: Boolean,
          default: true
        },
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        checkedValue: {
          type: [String, Number, Boolean],
          default: true
        },
        uncheckedValue: {
          type: [String, Number, Boolean],
          default: false
        },
        railStyle: Function,
        rubberBand: {
          type: Boolean,
          default: true
        },
onChange: [Function, Array]
      });
      let supportCssMax;
      const NSwitch = vue.defineComponent({
        name: "Switch",
        props: switchProps,
        slots: Object,
        setup(props) {
          if (supportCssMax === void 0) {
            if (typeof CSS !== "undefined") {
              if (typeof CSS.supports !== "undefined") {
                supportCssMax = CSS.supports("width", "max(1px)");
              } else {
                supportCssMax = false;
              }
            } else {
              supportCssMax = true;
            }
          }
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled
          } = useConfig(props);
          const themeRef = useTheme("Switch", "-switch", style$1, switchLight, props, mergedClsPrefixRef);
          const formItem = useFormItem(props);
          const {
            mergedSizeRef,
            mergedDisabledRef
          } = formItem;
          const uncontrolledValueRef = vue.ref(props.defaultValue);
          const controlledValueRef = vue.toRef(props, "value");
          const mergedValueRef = useMergedState(controlledValueRef, uncontrolledValueRef);
          const checkedRef = vue.computed(() => {
            return mergedValueRef.value === props.checkedValue;
          });
          const pressedRef = vue.ref(false);
          const focusedRef = vue.ref(false);
          const mergedRailStyleRef = vue.computed(() => {
            const {
              railStyle
            } = props;
            if (!railStyle) return void 0;
            return railStyle({
              focused: focusedRef.value,
              checked: checkedRef.value
            });
          });
          function doUpdateValue(value) {
            const {
              "onUpdate:value": _onUpdateValue,
              onChange,
              onUpdateValue
            } = props;
            const {
              nTriggerFormInput,
              nTriggerFormChange
            } = formItem;
            if (_onUpdateValue) call(_onUpdateValue, value);
            if (onUpdateValue) call(onUpdateValue, value);
            if (onChange) call(onChange, value);
            uncontrolledValueRef.value = value;
            nTriggerFormInput();
            nTriggerFormChange();
          }
          function doFocus() {
            const {
              nTriggerFormFocus
            } = formItem;
            nTriggerFormFocus();
          }
          function doBlur() {
            const {
              nTriggerFormBlur
            } = formItem;
            nTriggerFormBlur();
          }
          function handleClick2() {
            if (props.loading || mergedDisabledRef.value) return;
            if (mergedValueRef.value !== props.checkedValue) {
              doUpdateValue(props.checkedValue);
            } else {
              doUpdateValue(props.uncheckedValue);
            }
          }
          function handleFocus() {
            focusedRef.value = true;
            doFocus();
          }
          function handleBlur() {
            focusedRef.value = false;
            doBlur();
            pressedRef.value = false;
          }
          function handleKeyup(e) {
            if (props.loading || mergedDisabledRef.value) return;
            if (e.key === " ") {
              if (mergedValueRef.value !== props.checkedValue) {
                doUpdateValue(props.checkedValue);
              } else {
                doUpdateValue(props.uncheckedValue);
              }
              pressedRef.value = false;
            }
          }
          function handleKeydown(e) {
            if (props.loading || mergedDisabledRef.value) return;
            if (e.key === " ") {
              e.preventDefault();
              pressedRef.value = true;
            }
          }
          const cssVarsRef = vue.computed(() => {
            const {
              value: size2
            } = mergedSizeRef;
            const {
              self: {
                opacityDisabled,
                railColor,
                railColorActive,
                buttonBoxShadow,
                buttonColor,
                boxShadowFocus,
                loadingColor,
                textColor,
                iconColor,
                [createKey("buttonHeight", size2)]: buttonHeight,
                [createKey("buttonWidth", size2)]: buttonWidth,
                [createKey("buttonWidthPressed", size2)]: buttonWidthPressed,
                [createKey("railHeight", size2)]: railHeight,
                [createKey("railWidth", size2)]: railWidth,
                [createKey("railBorderRadius", size2)]: railBorderRadius,
                [createKey("buttonBorderRadius", size2)]: buttonBorderRadius
              },
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              }
            } = themeRef.value;
            let offset;
            let height;
            let width;
            if (supportCssMax) {
              offset = `calc((${railHeight} - ${buttonHeight}) / 2)`;
              height = `max(${railHeight}, ${buttonHeight})`;
              width = `max(${railWidth}, calc(${railWidth} + ${buttonHeight} - ${railHeight}))`;
            } else {
              offset = pxfy((depx(railHeight) - depx(buttonHeight)) / 2);
              height = pxfy(Math.max(depx(railHeight), depx(buttonHeight)));
              width = depx(railHeight) > depx(buttonHeight) ? railWidth : pxfy(depx(railWidth) + depx(buttonHeight) - depx(railHeight));
            }
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-button-border-radius": buttonBorderRadius,
              "--n-button-box-shadow": buttonBoxShadow,
              "--n-button-color": buttonColor,
              "--n-button-width": buttonWidth,
              "--n-button-width-pressed": buttonWidthPressed,
              "--n-button-height": buttonHeight,
              "--n-height": height,
              "--n-offset": offset,
              "--n-opacity-disabled": opacityDisabled,
              "--n-rail-border-radius": railBorderRadius,
              "--n-rail-color": railColor,
              "--n-rail-color-active": railColorActive,
              "--n-rail-height": railHeight,
              "--n-rail-width": railWidth,
              "--n-width": width,
              "--n-box-shadow-focus": boxShadowFocus,
              "--n-loading-color": loadingColor,
              "--n-text-color": textColor,
              "--n-icon-color": iconColor
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("switch", vue.computed(() => {
            return mergedSizeRef.value[0];
          }), cssVarsRef, props) : void 0;
          return {
            handleClick: handleClick2,
            handleBlur,
            handleFocus,
            handleKeyup,
            handleKeydown,
            mergedRailStyle: mergedRailStyleRef,
            pressed: pressedRef,
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue: mergedValueRef,
            checked: checkedRef,
            mergedDisabled: mergedDisabledRef,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          };
        },
        render() {
          const {
            mergedClsPrefix,
            mergedDisabled,
            checked,
            mergedRailStyle,
            onRender,
            $slots
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const {
            checked: checkedSlot,
            unchecked: uncheckedSlot,
            icon: iconSlot,
            "checked-icon": checkedIconSlot,
            "unchecked-icon": uncheckedIconSlot
          } = $slots;
          const hasIcon = !(isSlotEmpty(iconSlot) && isSlotEmpty(checkedIconSlot) && isSlotEmpty(uncheckedIconSlot));
          return vue.h("div", {
            role: "switch",
            "aria-checked": checked,
            class: [`${mergedClsPrefix}-switch`, this.themeClass, hasIcon && `${mergedClsPrefix}-switch--icon`, checked && `${mergedClsPrefix}-switch--active`, mergedDisabled && `${mergedClsPrefix}-switch--disabled`, this.round && `${mergedClsPrefix}-switch--round`, this.loading && `${mergedClsPrefix}-switch--loading`, this.pressed && `${mergedClsPrefix}-switch--pressed`, this.rubberBand && `${mergedClsPrefix}-switch--rubber-band`],
            tabindex: !this.mergedDisabled ? 0 : void 0,
            style: this.cssVars,
            onClick: this.handleClick,
            onFocus: this.handleFocus,
            onBlur: this.handleBlur,
            onKeyup: this.handleKeyup,
            onKeydown: this.handleKeydown
          }, vue.h("div", {
            class: `${mergedClsPrefix}-switch__rail`,
            "aria-hidden": "true",
            style: mergedRailStyle
          }, resolveWrappedSlot(checkedSlot, (checkedSlotChildren) => resolveWrappedSlot(uncheckedSlot, (uncheckedSlotChildren) => {
            if (checkedSlotChildren || uncheckedSlotChildren) {
              return vue.h("div", {
                "aria-hidden": true,
                class: `${mergedClsPrefix}-switch__children-placeholder`
              }, vue.h("div", {
                class: `${mergedClsPrefix}-switch__rail-placeholder`
              }, vue.h("div", {
                class: `${mergedClsPrefix}-switch__button-placeholder`
              }), checkedSlotChildren), vue.h("div", {
                class: `${mergedClsPrefix}-switch__rail-placeholder`
              }, vue.h("div", {
                class: `${mergedClsPrefix}-switch__button-placeholder`
              }), uncheckedSlotChildren));
            }
            return null;
          })), vue.h("div", {
            class: `${mergedClsPrefix}-switch__button`
          }, resolveWrappedSlot(iconSlot, (icon) => resolveWrappedSlot(checkedIconSlot, (checkedIcon) => resolveWrappedSlot(uncheckedIconSlot, (uncheckedIcon) => {
            return vue.h(NIconSwitchTransition, null, {
              default: () => this.loading ? vue.h(NBaseLoading, {
                key: "loading",
                clsPrefix: mergedClsPrefix,
                strokeWidth: 20
              }) : this.checked && (checkedIcon || icon) ? vue.h("div", {
                class: `${mergedClsPrefix}-switch__button-icon`,
                key: checkedIcon ? "checked-icon" : "icon"
              }, checkedIcon || icon) : !this.checked && (uncheckedIcon || icon) ? vue.h("div", {
                class: `${mergedClsPrefix}-switch__button-icon`,
                key: uncheckedIcon ? "unchecked-icon" : "icon"
              }, uncheckedIcon || icon) : null
            });
          }))), resolveWrappedSlot(checkedSlot, (children) => children && vue.h("div", {
            key: "checked",
            class: `${mergedClsPrefix}-switch__checked`
          }, children)), resolveWrappedSlot(uncheckedSlot, (children) => children && vue.h("div", {
            key: "unchecked",
            class: `${mergedClsPrefix}-switch__unchecked`
          }, children)))));
        }
      });
      const tabsInjectionKey = createInjectionKey("n-tabs");
      const tabPaneProps = {
        tab: [String, Number, Object, Function],
        name: {
          type: [String, Number],
          required: true
        },
        disabled: Boolean,
        displayDirective: {
          type: String,
          default: "if"
        },
        closable: {
          type: Boolean,
          default: void 0
        },
        tabProps: Object,
label: [String, Number, Object, Function]
      };
      const NTabPane = vue.defineComponent({
        __TAB_PANE__: true,
        name: "TabPane",
        alias: ["TabPanel"],
        props: tabPaneProps,
        slots: Object,
        setup(props) {
          const NTab = vue.inject(tabsInjectionKey, null);
          if (!NTab) {
            throwError("tab-pane", "`n-tab-pane` must be placed inside `n-tabs`.");
          }
          return {
            style: NTab.paneStyleRef,
            class: NTab.paneClassRef,
            mergedClsPrefix: NTab.mergedClsPrefixRef
          };
        },
        render() {
          return vue.h("div", {
            class: [`${this.mergedClsPrefix}-tab-pane`, this.class],
            style: this.style
          }, this.$slots);
        }
      });
      const tabProps = Object.assign({
        internalLeftPadded: Boolean,
        internalAddable: Boolean,
        internalCreatedByPane: Boolean
      }, omit(tabPaneProps, ["displayDirective"]));
      const Tab = vue.defineComponent({
        __TAB__: true,
        inheritAttrs: false,
        name: "Tab",
        props: tabProps,
        setup(props) {
          const {
            mergedClsPrefixRef,
            valueRef,
            typeRef,
            closableRef,
            tabStyleRef,
            addTabStyleRef,
            tabClassRef,
            addTabClassRef,
            tabChangeIdRef,
            onBeforeLeaveRef,
            triggerRef,
            handleAdd,
            activateTab,
            handleClose
          } = vue.inject(tabsInjectionKey);
          return {
            trigger: triggerRef,
            mergedClosable: vue.computed(() => {
              if (props.internalAddable) return false;
              const {
                closable
              } = props;
              if (closable === void 0) return closableRef.value;
              return closable;
            }),
            style: tabStyleRef,
            addStyle: addTabStyleRef,
            tabClass: tabClassRef,
            addTabClass: addTabClassRef,
            clsPrefix: mergedClsPrefixRef,
            value: valueRef,
            type: typeRef,
            handleClose(e) {
              e.stopPropagation();
              if (props.disabled) return;
              handleClose(props.name);
            },
            activateTab() {
              if (props.disabled) return;
              if (props.internalAddable) {
                handleAdd();
                return;
              }
              const {
                name: nameProp
              } = props;
              const id = ++tabChangeIdRef.id;
              if (nameProp !== valueRef.value) {
                const {
                  value: onBeforeLeave
                } = onBeforeLeaveRef;
                if (!onBeforeLeave) {
                  activateTab(nameProp);
                } else {
                  void Promise.resolve(onBeforeLeave(props.name, valueRef.value)).then((allowLeave) => {
                    if (allowLeave && tabChangeIdRef.id === id) {
                      activateTab(nameProp);
                    }
                  });
                }
              }
            }
          };
        },
        render() {
          const {
            internalAddable,
            clsPrefix,
            name,
            disabled,
            label,
            tab,
            value,
            mergedClosable,
            trigger: trigger2,
            $slots: {
              default: defaultSlot
            }
          } = this;
          const mergedTab = label !== null && label !== void 0 ? label : tab;
          return vue.h("div", {
            class: `${clsPrefix}-tabs-tab-wrapper`
          }, this.internalLeftPadded ? vue.h("div", {
            class: `${clsPrefix}-tabs-tab-pad`
          }) : null, vue.h("div", Object.assign({
            key: name,
            "data-name": name,
            "data-disabled": disabled ? true : void 0
          }, vue.mergeProps({
            class: [`${clsPrefix}-tabs-tab`, value === name && `${clsPrefix}-tabs-tab--active`, disabled && `${clsPrefix}-tabs-tab--disabled`, mergedClosable && `${clsPrefix}-tabs-tab--closable`, internalAddable && `${clsPrefix}-tabs-tab--addable`, internalAddable ? this.addTabClass : this.tabClass],
            onClick: trigger2 === "click" ? this.activateTab : void 0,
            onMouseenter: trigger2 === "hover" ? this.activateTab : void 0,
            style: internalAddable ? this.addStyle : this.style
          }, this.internalCreatedByPane ? this.tabProps || {} : this.$attrs)), vue.h("span", {
            class: `${clsPrefix}-tabs-tab__label`
          }, internalAddable ? vue.h(vue.Fragment, null, vue.h("div", {
            class: `${clsPrefix}-tabs-tab__height-placeholder`
          }, " "), vue.h(NBaseIcon, {
            clsPrefix
          }, {
            default: () => vue.h(AddIcon, null)
          })) : defaultSlot ? defaultSlot() : typeof mergedTab === "object" ? mergedTab : render(mergedTab !== null && mergedTab !== void 0 ? mergedTab : name)), mergedClosable && this.type === "card" ? vue.h(NBaseClose, {
            clsPrefix,
            class: `${clsPrefix}-tabs-tab__close`,
            onClick: this.handleClose,
            disabled
          }) : null));
        }
      });
      const style = cB("tabs", `
 box-sizing: border-box;
 width: 100%;
 display: flex;
 flex-direction: column;
 transition:
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
`, [cM("segment-type", [cB("tabs-rail", [c$1("&.transition-disabled", [cB("tabs-capsule", `
 transition: none;
 `)])])]), cM("top", [cB("tab-pane", `
 padding: var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left);
 `)]), cM("left", [cB("tab-pane", `
 padding: var(--n-pane-padding-right) var(--n-pane-padding-bottom) var(--n-pane-padding-left) var(--n-pane-padding-top);
 `)]), cM("left, right", `
 flex-direction: row;
 `, [cB("tabs-bar", `
 width: 2px;
 right: 0;
 transition:
 top .2s var(--n-bezier),
 max-height .2s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `), cB("tabs-tab", `
 padding: var(--n-tab-padding-vertical); 
 `)]), cM("right", `
 flex-direction: row-reverse;
 `, [cB("tab-pane", `
 padding: var(--n-pane-padding-left) var(--n-pane-padding-top) var(--n-pane-padding-right) var(--n-pane-padding-bottom);
 `), cB("tabs-bar", `
 left: 0;
 `)]), cM("bottom", `
 flex-direction: column-reverse;
 justify-content: flex-end;
 `, [cB("tab-pane", `
 padding: var(--n-pane-padding-bottom) var(--n-pane-padding-right) var(--n-pane-padding-top) var(--n-pane-padding-left);
 `), cB("tabs-bar", `
 top: 0;
 `)]), cB("tabs-rail", `
 position: relative;
 padding: 3px;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 background-color: var(--n-color-segment);
 transition: background-color .3s var(--n-bezier);
 display: flex;
 align-items: center;
 `, [cB("tabs-capsule", `
 border-radius: var(--n-tab-border-radius);
 position: absolute;
 pointer-events: none;
 background-color: var(--n-tab-color-segment);
 box-shadow: 0 1px 3px 0 rgba(0, 0, 0, .08);
 transition: transform 0.3s var(--n-bezier);
 `), cB("tabs-tab-wrapper", `
 flex-basis: 0;
 flex-grow: 1;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cB("tabs-tab", `
 overflow: hidden;
 border-radius: var(--n-tab-border-radius);
 width: 100%;
 display: flex;
 align-items: center;
 justify-content: center;
 `, [cM("active", `
 font-weight: var(--n-font-weight-strong);
 color: var(--n-tab-text-color-active);
 `), c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])])]), cM("flex", [cB("tabs-nav", `
 width: 100%;
 position: relative;
 `, [cB("tabs-wrapper", `
 width: 100%;
 `, [cB("tabs-tab", `
 margin-right: 0;
 `)])])]), cB("tabs-nav", `
 box-sizing: border-box;
 line-height: 1.5;
 display: flex;
 transition: border-color .3s var(--n-bezier);
 `, [cE("prefix, suffix", `
 display: flex;
 align-items: center;
 `), cE("prefix", "padding-right: 16px;"), cE("suffix", "padding-left: 16px;")]), cM("top, bottom", [c$1(">", [cB("tabs-nav", [cB("tabs-nav-scroll-wrapper", [c$1("&::before", `
 top: 0;
 bottom: 0;
 left: 0;
 width: 20px;
 `), c$1("&::after", `
 top: 0;
 bottom: 0;
 right: 0;
 width: 20px;
 `), cM("shadow-start", [c$1("&::before", `
 box-shadow: inset 10px 0 8px -8px rgba(0, 0, 0, .12);
 `)]), cM("shadow-end", [c$1("&::after", `
 box-shadow: inset -10px 0 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), cM("left, right", [cB("tabs-nav-scroll-content", `
 flex-direction: column;
 `), c$1(">", [cB("tabs-nav", [cB("tabs-nav-scroll-wrapper", [c$1("&::before", `
 top: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), c$1("&::after", `
 bottom: 0;
 left: 0;
 right: 0;
 height: 20px;
 `), cM("shadow-start", [c$1("&::before", `
 box-shadow: inset 0 10px 8px -8px rgba(0, 0, 0, .12);
 `)]), cM("shadow-end", [c$1("&::after", `
 box-shadow: inset 0 -10px 8px -8px rgba(0, 0, 0, .12);
 `)])])])])]), cB("tabs-nav-scroll-wrapper", `
 flex: 1;
 position: relative;
 overflow: hidden;
 `, [cB("tabs-nav-y-scroll", `
 height: 100%;
 width: 100%;
 overflow-y: auto; 
 scrollbar-width: none;
 `, [c$1("&::-webkit-scrollbar, &::-webkit-scrollbar-track-piece, &::-webkit-scrollbar-thumb", `
 width: 0;
 height: 0;
 display: none;
 `)]), c$1("&::before, &::after", `
 transition: box-shadow .3s var(--n-bezier);
 pointer-events: none;
 content: "";
 position: absolute;
 z-index: 1;
 `)]), cB("tabs-nav-scroll-content", `
 display: flex;
 position: relative;
 min-width: 100%;
 min-height: 100%;
 width: fit-content;
 box-sizing: border-box;
 `), cB("tabs-wrapper", `
 display: inline-flex;
 flex-wrap: nowrap;
 position: relative;
 `), cB("tabs-tab-wrapper", `
 display: flex;
 flex-wrap: nowrap;
 flex-shrink: 0;
 flex-grow: 0;
 `), cB("tabs-tab", `
 cursor: pointer;
 white-space: nowrap;
 flex-wrap: nowrap;
 display: inline-flex;
 align-items: center;
 color: var(--n-tab-text-color);
 font-size: var(--n-tab-font-size);
 background-clip: padding-box;
 padding: var(--n-tab-padding);
 transition:
 box-shadow .3s var(--n-bezier),
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 border-color .3s var(--n-bezier);
 `, [cM("disabled", {
        cursor: "not-allowed"
      }), cE("close", `
 margin-left: 6px;
 transition:
 background-color .3s var(--n-bezier),
 color .3s var(--n-bezier);
 `), cE("label", `
 display: flex;
 align-items: center;
 z-index: 1;
 `)]), cB("tabs-bar", `
 position: absolute;
 bottom: 0;
 height: 2px;
 border-radius: 1px;
 background-color: var(--n-bar-color);
 transition:
 left .2s var(--n-bezier),
 max-width .2s var(--n-bezier),
 opacity .3s var(--n-bezier),
 background-color .3s var(--n-bezier);
 `, [c$1("&.transition-disabled", `
 transition: none;
 `), cM("disabled", `
 background-color: var(--n-tab-text-color-disabled)
 `)]), cB("tabs-pane-wrapper", `
 position: relative;
 overflow: hidden;
 transition: max-height .2s var(--n-bezier);
 `), cB("tab-pane", `
 color: var(--n-pane-text-color);
 width: 100%;
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 opacity .2s var(--n-bezier);
 left: 0;
 right: 0;
 top: 0;
 `, [c$1("&.next-transition-leave-active, &.prev-transition-leave-active, &.next-transition-enter-active, &.prev-transition-enter-active", `
 transition:
 color .3s var(--n-bezier),
 background-color .3s var(--n-bezier),
 transform .2s var(--n-bezier),
 opacity .2s var(--n-bezier);
 `), c$1("&.next-transition-leave-active, &.prev-transition-leave-active", `
 position: absolute;
 `), c$1("&.next-transition-enter-from, &.prev-transition-leave-to", `
 transform: translateX(32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-to, &.prev-transition-enter-from", `
 transform: translateX(-32px);
 opacity: 0;
 `), c$1("&.next-transition-leave-from, &.next-transition-enter-to, &.prev-transition-leave-from, &.prev-transition-enter-to", `
 transform: translateX(0);
 opacity: 1;
 `)]), cB("tabs-tab-pad", `
 box-sizing: border-box;
 width: var(--n-tab-gap);
 flex-grow: 0;
 flex-shrink: 0;
 `), cM("line-type, bar-type", [cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 box-sizing: border-box;
 vertical-align: bottom;
 `, [c$1("&:hover", {
        color: "var(--n-tab-text-color-hover)"
      }), cM("active", `
 color: var(--n-tab-text-color-active);
 font-weight: var(--n-tab-font-weight-active);
 `), cM("disabled", {
        color: "var(--n-tab-text-color-disabled)"
      })])]), cB("tabs-nav", [cM("line-type", [cM("top", [cE("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 bottom: -1px;
 `)]), cM("left", [cE("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 right: -1px;
 `)]), cM("right", [cE("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 left: -1px;
 `)]), cM("bottom", [cE("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-nav-scroll-content", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-bar", `
 top: -1px;
 `)]), cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-nav-scroll-content", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-bar", `
 border-radius: 0;
 `)]), cM("card-type", [cE("prefix, suffix", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-pad", `
 flex-grow: 1;
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-tab-pad", `
 transition: border-color .3s var(--n-bezier);
 `), cB("tabs-tab", `
 font-weight: var(--n-tab-font-weight);
 border: 1px solid var(--n-tab-border-color);
 background-color: var(--n-tab-color);
 box-sizing: border-box;
 position: relative;
 vertical-align: bottom;
 display: flex;
 justify-content: space-between;
 font-size: var(--n-tab-font-size);
 color: var(--n-tab-text-color);
 `, [cM("addable", `
 padding-left: 8px;
 padding-right: 8px;
 font-size: 16px;
 justify-content: center;
 `, [cE("height-placeholder", `
 width: 0;
 font-size: var(--n-tab-font-size);
 `), cNotM("disabled", [c$1("&:hover", `
 color: var(--n-tab-text-color-hover);
 `)])]), cM("closable", "padding-right: 8px;"), cM("active", `
 background-color: #0000;
 font-weight: var(--n-tab-font-weight-active);
 color: var(--n-tab-text-color-active);
 `), cM("disabled", "color: var(--n-tab-text-color-disabled);")])]), cM("left, right", `
 flex-direction: column; 
 `, [cE("prefix, suffix", `
 padding: var(--n-tab-padding-vertical);
 `), cB("tabs-wrapper", `
 flex-direction: column;
 `), cB("tabs-tab-wrapper", `
 flex-direction: column;
 `, [cB("tabs-tab-pad", `
 height: var(--n-tab-gap-vertical);
 width: 100%;
 `)])]), cM("top", [cM("card-type", [cB("tabs-scroll-padding", "border-bottom: 1px solid var(--n-tab-border-color);"), cE("prefix, suffix", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-top-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-bottom: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-bottom: 1px solid var(--n-tab-border-color);
 `)])]), cM("left", [cM("card-type", [cB("tabs-scroll-padding", "border-right: 1px solid var(--n-tab-border-color);"), cE("prefix, suffix", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab", `
 border-top-left-radius: var(--n-tab-border-radius);
 border-bottom-left-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-right: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-right: 1px solid var(--n-tab-border-color);
 `)])]), cM("right", [cM("card-type", [cB("tabs-scroll-padding", "border-left: 1px solid var(--n-tab-border-color);"), cE("prefix, suffix", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab", `
 border-top-right-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-left: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-left: 1px solid var(--n-tab-border-color);
 `)])]), cM("bottom", [cM("card-type", [cB("tabs-scroll-padding", "border-top: 1px solid var(--n-tab-border-color);"), cE("prefix, suffix", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-tab", `
 border-bottom-left-radius: var(--n-tab-border-radius);
 border-bottom-right-radius: var(--n-tab-border-radius);
 `, [cM("active", `
 border-top: 1px solid #0000;
 `)]), cB("tabs-tab-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `), cB("tabs-pad", `
 border-top: 1px solid var(--n-tab-border-color);
 `)])])])]);
      const throttle = throttle$1;
      const tabsProps = Object.assign(Object.assign({}, useTheme.props), {
        value: [String, Number],
        defaultValue: [String, Number],
        trigger: {
          type: String,
          default: "click"
        },
        type: {
          type: String,
          default: "bar"
        },
        closable: Boolean,
        justifyContent: String,
        size: {
          type: String,
          default: "medium"
        },
        placement: {
          type: String,
          default: "top"
        },
        tabStyle: [String, Object],
        tabClass: String,
        addTabStyle: [String, Object],
        addTabClass: String,
        barWidth: Number,
        paneClass: String,
        paneStyle: [String, Object],
        paneWrapperClass: String,
        paneWrapperStyle: [String, Object],
        addable: [Boolean, Object],
        tabsPadding: {
          type: Number,
          default: 0
        },
        animated: Boolean,
        onBeforeLeave: Function,
        onAdd: Function,
        "onUpdate:value": [Function, Array],
        onUpdateValue: [Function, Array],
        onClose: [Function, Array],
labelSize: String,
        activeName: [String, Number],
        onActiveNameChange: [Function, Array]
      });
      const NTabs = vue.defineComponent({
        name: "Tabs",
        props: tabsProps,
        slots: Object,
        setup(props, {
          slots
        }) {
          var _a, _b, _c, _d;
          const {
            mergedClsPrefixRef,
            inlineThemeDisabled
          } = useConfig(props);
          const themeRef = useTheme("Tabs", "-tabs", style, tabsLight, props, mergedClsPrefixRef);
          const tabsElRef = vue.ref(null);
          const barElRef = vue.ref(null);
          const scrollWrapperElRef = vue.ref(null);
          const addTabInstRef = vue.ref(null);
          const xScrollInstRef = vue.ref(null);
          const yScrollElRef = vue.ref(null);
          const startReachedRef = vue.ref(true);
          const endReachedRef = vue.ref(true);
          const compitableSizeRef = useCompitable(props, ["labelSize", "size"]);
          const compitableValueRef = useCompitable(props, ["activeName", "value"]);
          const uncontrolledValueRef = vue.ref((_b = (_a = compitableValueRef.value) !== null && _a !== void 0 ? _a : props.defaultValue) !== null && _b !== void 0 ? _b : slots.default ? (_d = (_c = flatten$2(slots.default())[0]) === null || _c === void 0 ? void 0 : _c.props) === null || _d === void 0 ? void 0 : _d.name : null);
          const mergedValueRef = useMergedState(compitableValueRef, uncontrolledValueRef);
          const tabChangeIdRef = {
            id: 0
          };
          const tabWrapperStyleRef = vue.computed(() => {
            if (!props.justifyContent || props.type === "card") return void 0;
            return {
              display: "flex",
              justifyContent: props.justifyContent
            };
          });
          vue.watch(mergedValueRef, () => {
            tabChangeIdRef.id = 0;
            updateCurrentBarStyle();
            updateCurrentScrollPosition();
          });
          function getCurrentEl() {
            var _a2;
            const {
              value
            } = mergedValueRef;
            if (value === null) return null;
            const tabEl = (_a2 = tabsElRef.value) === null || _a2 === void 0 ? void 0 : _a2.querySelector(`[data-name="${value}"]`);
            return tabEl;
          }
          function updateBarStyle(tabEl) {
            if (props.type === "card") return;
            const {
              value: barEl
            } = barElRef;
            if (!barEl) return;
            const barIsHide = barEl.style.opacity === "0";
            if (tabEl) {
              const disabledClassName = `${mergedClsPrefixRef.value}-tabs-bar--disabled`;
              const {
                barWidth,
                placement
              } = props;
              if (tabEl.dataset.disabled === "true") {
                barEl.classList.add(disabledClassName);
              } else {
                barEl.classList.remove(disabledClassName);
              }
              if (["top", "bottom"].includes(placement)) {
                clearBarStyle(["top", "maxHeight", "height"]);
                if (typeof barWidth === "number" && tabEl.offsetWidth >= barWidth) {
                  const offsetDiffLeft = Math.floor((tabEl.offsetWidth - barWidth) / 2) + tabEl.offsetLeft;
                  barEl.style.left = `${offsetDiffLeft}px`;
                  barEl.style.maxWidth = `${barWidth}px`;
                } else {
                  barEl.style.left = `${tabEl.offsetLeft}px`;
                  barEl.style.maxWidth = `${tabEl.offsetWidth}px`;
                }
                barEl.style.width = "8192px";
                if (barIsHide) {
                  barEl.style.transition = "none";
                }
                void barEl.offsetWidth;
                if (barIsHide) {
                  barEl.style.transition = "";
                  barEl.style.opacity = "1";
                }
              } else {
                clearBarStyle(["left", "maxWidth", "width"]);
                if (typeof barWidth === "number" && tabEl.offsetHeight >= barWidth) {
                  const offsetDiffTop = Math.floor((tabEl.offsetHeight - barWidth) / 2) + tabEl.offsetTop;
                  barEl.style.top = `${offsetDiffTop}px`;
                  barEl.style.maxHeight = `${barWidth}px`;
                } else {
                  barEl.style.top = `${tabEl.offsetTop}px`;
                  barEl.style.maxHeight = `${tabEl.offsetHeight}px`;
                }
                barEl.style.height = "8192px";
                if (barIsHide) {
                  barEl.style.transition = "none";
                }
                void barEl.offsetHeight;
                if (barIsHide) {
                  barEl.style.transition = "";
                  barEl.style.opacity = "1";
                }
              }
            }
          }
          function hideBarStyle() {
            if (props.type === "card") return;
            const {
              value: barEl
            } = barElRef;
            if (!barEl) return;
            barEl.style.opacity = "0";
          }
          function clearBarStyle(styleProps) {
            const {
              value: barEl
            } = barElRef;
            if (!barEl) return;
            for (const prop of styleProps) {
              barEl.style[prop] = "";
            }
          }
          function updateCurrentBarStyle() {
            if (props.type === "card") return;
            const tabEl = getCurrentEl();
            if (tabEl) {
              updateBarStyle(tabEl);
            } else {
              hideBarStyle();
            }
          }
          function updateCurrentScrollPosition() {
            var _a2;
            const scrollWrapperEl = (_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el;
            if (!scrollWrapperEl) return;
            const tabEl = getCurrentEl();
            if (!tabEl) return;
            const {
              scrollLeft: scrollWrapperElScrollLeft,
              offsetWidth: scrollWrapperElOffsetWidth
            } = scrollWrapperEl;
            const {
              offsetLeft: tabElOffsetLeft,
              offsetWidth: tabElOffsetWidth
            } = tabEl;
            if (scrollWrapperElScrollLeft > tabElOffsetLeft) {
              scrollWrapperEl.scrollTo({
                top: 0,
                left: tabElOffsetLeft,
                behavior: "smooth"
              });
            } else if (tabElOffsetLeft + tabElOffsetWidth > scrollWrapperElScrollLeft + scrollWrapperElOffsetWidth) {
              scrollWrapperEl.scrollTo({
                top: 0,
                left: tabElOffsetLeft + tabElOffsetWidth - scrollWrapperElOffsetWidth,
                behavior: "smooth"
              });
            }
          }
          const tabsPaneWrapperRef = vue.ref(null);
          let fromHeight = 0;
          let hangingTransition = null;
          function onAnimationBeforeLeave(el) {
            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
            if (tabsPaneWrapperEl) {
              fromHeight = el.getBoundingClientRect().height;
              const fromHeightPx = `${fromHeight}px`;
              const applyFromStyle = () => {
                tabsPaneWrapperEl.style.height = fromHeightPx;
                tabsPaneWrapperEl.style.maxHeight = fromHeightPx;
              };
              if (!hangingTransition) {
                hangingTransition = applyFromStyle;
              } else {
                applyFromStyle();
                hangingTransition();
                hangingTransition = null;
              }
            }
          }
          function onAnimationEnter(el) {
            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
            if (tabsPaneWrapperEl) {
              const targetHeight = el.getBoundingClientRect().height;
              const applyTargetStyle = () => {
                void document.body.offsetHeight;
                tabsPaneWrapperEl.style.maxHeight = `${targetHeight}px`;
                tabsPaneWrapperEl.style.height = `${Math.max(fromHeight, targetHeight)}px`;
              };
              if (!hangingTransition) {
                hangingTransition = applyTargetStyle;
              } else {
                hangingTransition();
                hangingTransition = null;
                applyTargetStyle();
              }
            }
          }
          function onAnimationAfterEnter() {
            const tabsPaneWrapperEl = tabsPaneWrapperRef.value;
            if (tabsPaneWrapperEl) {
              tabsPaneWrapperEl.style.maxHeight = "";
              tabsPaneWrapperEl.style.height = "";
              const {
                paneWrapperStyle
              } = props;
              if (typeof paneWrapperStyle === "string") {
                tabsPaneWrapperEl.style.cssText = paneWrapperStyle;
              } else if (paneWrapperStyle) {
                const {
                  maxHeight,
                  height
                } = paneWrapperStyle;
                if (maxHeight !== void 0) {
                  tabsPaneWrapperEl.style.maxHeight = maxHeight;
                }
                if (height !== void 0) {
                  tabsPaneWrapperEl.style.height = height;
                }
              }
            }
          }
          const renderNameListRef = {
            value: []
          };
          const animationDirectionRef = vue.ref("next");
          function activateTab(panelName) {
            const currentValue = mergedValueRef.value;
            let dir = "next";
            for (const name of renderNameListRef.value) {
              if (name === currentValue) {
                break;
              }
              if (name === panelName) {
                dir = "prev";
                break;
              }
            }
            animationDirectionRef.value = dir;
            doUpdateValue(panelName);
          }
          function doUpdateValue(panelName) {
            const {
              onActiveNameChange,
              onUpdateValue,
              "onUpdate:value": _onUpdateValue
            } = props;
            if (onActiveNameChange) {
              call(onActiveNameChange, panelName);
            }
            if (onUpdateValue) call(onUpdateValue, panelName);
            if (_onUpdateValue) call(_onUpdateValue, panelName);
            uncontrolledValueRef.value = panelName;
          }
          function handleClose(panelName) {
            const {
              onClose
            } = props;
            if (onClose) call(onClose, panelName);
          }
          function updateBarPositionInstantly() {
            const {
              value: barEl
            } = barElRef;
            if (!barEl) return;
            const disableTransitionClassName = "transition-disabled";
            barEl.classList.add(disableTransitionClassName);
            updateCurrentBarStyle();
            barEl.classList.remove(disableTransitionClassName);
          }
          const segmentCapsuleElRef = vue.ref(null);
          function updateSegmentPosition({
            transitionDisabled
          }) {
            const tabsEl = tabsElRef.value;
            if (!tabsEl) return;
            if (transitionDisabled) tabsEl.classList.add("transition-disabled");
            const activeTabEl = getCurrentEl();
            if (activeTabEl && segmentCapsuleElRef.value) {
              segmentCapsuleElRef.value.style.width = `${activeTabEl.offsetWidth}px`;
              segmentCapsuleElRef.value.style.height = `${activeTabEl.offsetHeight}px`;
              segmentCapsuleElRef.value.style.transform = `translateX(${activeTabEl.offsetLeft - depx(getComputedStyle(tabsEl).paddingLeft)}px)`;
              if (transitionDisabled) {
                void segmentCapsuleElRef.value.offsetWidth;
              }
            }
            if (transitionDisabled) {
              tabsEl.classList.remove("transition-disabled");
            }
          }
          vue.watch([mergedValueRef], () => {
            if (props.type === "segment") {
              void vue.nextTick(() => {
                updateSegmentPosition({
                  transitionDisabled: false
                });
              });
            }
          });
          vue.onMounted(() => {
            if (props.type === "segment") {
              updateSegmentPosition({
                transitionDisabled: true
              });
            }
          });
          let memorizedWidth = 0;
          function _handleNavResize(entry) {
            var _b2;
            if (entry.contentRect.width === 0 && entry.contentRect.height === 0) {
              return;
            }
            if (memorizedWidth === entry.contentRect.width) {
              return;
            }
            memorizedWidth = entry.contentRect.width;
            const {
              type
            } = props;
            if (type === "line" || type === "bar") {
              {
                updateBarPositionInstantly();
              }
            }
            if (type !== "segment") {
              const {
                placement
              } = props;
              deriveScrollShadow((placement === "top" || placement === "bottom" ? (_b2 = xScrollInstRef.value) === null || _b2 === void 0 ? void 0 : _b2.$el : yScrollElRef.value) || null);
            }
          }
          const handleNavResize = throttle(_handleNavResize, 64);
          vue.watch([() => props.justifyContent, () => props.size], () => {
            void vue.nextTick(() => {
              const {
                type
              } = props;
              if (type === "line" || type === "bar") {
                updateBarPositionInstantly();
              }
            });
          });
          const addTabFixedRef = vue.ref(false);
          function _handleTabsResize(entry) {
            var _a2;
            const {
              target,
              contentRect: {
                width,
                height
              }
            } = entry;
            const containerWidth = target.parentElement.parentElement.offsetWidth;
            const containerHeight = target.parentElement.parentElement.offsetHeight;
            const {
              placement
            } = props;
            if (!addTabFixedRef.value) {
              if (placement === "top" || placement === "bottom") {
                if (containerWidth < width) {
                  addTabFixedRef.value = true;
                }
              } else {
                if (containerHeight < height) {
                  addTabFixedRef.value = true;
                }
              }
            } else {
              const {
                value: addTabInst
              } = addTabInstRef;
              if (!addTabInst) return;
              if (placement === "top" || placement === "bottom") {
                if (containerWidth - width > addTabInst.$el.offsetWidth) {
                  addTabFixedRef.value = false;
                }
              } else {
                if (containerHeight - height > addTabInst.$el.offsetHeight) {
                  addTabFixedRef.value = false;
                }
              }
            }
            deriveScrollShadow(((_a2 = xScrollInstRef.value) === null || _a2 === void 0 ? void 0 : _a2.$el) || null);
          }
          const handleTabsResize = throttle(_handleTabsResize, 64);
          function handleAdd() {
            const {
              onAdd
            } = props;
            if (onAdd) onAdd();
            void vue.nextTick(() => {
              const currentEl = getCurrentEl();
              const {
                value: xScrollInst
              } = xScrollInstRef;
              if (!currentEl || !xScrollInst) return;
              xScrollInst.scrollTo({
                left: currentEl.offsetLeft,
                top: 0,
                behavior: "smooth"
              });
            });
          }
          function deriveScrollShadow(el) {
            if (!el) return;
            const {
              placement
            } = props;
            if (placement === "top" || placement === "bottom") {
              const {
                scrollLeft,
                scrollWidth,
                offsetWidth
              } = el;
              startReachedRef.value = scrollLeft <= 0;
              endReachedRef.value = scrollLeft + offsetWidth >= scrollWidth;
            } else {
              const {
                scrollTop,
                scrollHeight,
                offsetHeight
              } = el;
              startReachedRef.value = scrollTop <= 0;
              endReachedRef.value = scrollTop + offsetHeight >= scrollHeight;
            }
          }
          const handleScroll = throttle((e) => {
            deriveScrollShadow(e.target);
          }, 64);
          vue.provide(tabsInjectionKey, {
            triggerRef: vue.toRef(props, "trigger"),
            tabStyleRef: vue.toRef(props, "tabStyle"),
            tabClassRef: vue.toRef(props, "tabClass"),
            addTabStyleRef: vue.toRef(props, "addTabStyle"),
            addTabClassRef: vue.toRef(props, "addTabClass"),
            paneClassRef: vue.toRef(props, "paneClass"),
            paneStyleRef: vue.toRef(props, "paneStyle"),
            mergedClsPrefixRef,
            typeRef: vue.toRef(props, "type"),
            closableRef: vue.toRef(props, "closable"),
            valueRef: mergedValueRef,
            tabChangeIdRef,
            onBeforeLeaveRef: vue.toRef(props, "onBeforeLeave"),
            activateTab,
            handleClose,
            handleAdd
          });
          onFontsReady(() => {
            updateCurrentBarStyle();
            updateCurrentScrollPosition();
          });
          vue.watchEffect(() => {
            const {
              value: el
            } = scrollWrapperElRef;
            if (!el) return;
            const {
              value: clsPrefix
            } = mergedClsPrefixRef;
            const shadowStartClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-start`;
            const shadowEndClass = `${clsPrefix}-tabs-nav-scroll-wrapper--shadow-end`;
            if (startReachedRef.value) {
              el.classList.remove(shadowStartClass);
            } else {
              el.classList.add(shadowStartClass);
            }
            if (endReachedRef.value) {
              el.classList.remove(shadowEndClass);
            } else {
              el.classList.add(shadowEndClass);
            }
          });
          const exposedMethods = {
            syncBarPosition: () => {
              updateCurrentBarStyle();
            }
          };
          const handleSegmentResize = () => {
            updateSegmentPosition({
              transitionDisabled: true
            });
          };
          const cssVarsRef = vue.computed(() => {
            const {
              value: size2
            } = compitableSizeRef;
            const {
              type
            } = props;
            const typeSuffix = {
              card: "Card",
              bar: "Bar",
              line: "Line",
              segment: "Segment"
            }[type];
            const sizeType = `${size2}${typeSuffix}`;
            const {
              self: {
                barColor,
                closeIconColor,
                closeIconColorHover,
                closeIconColorPressed,
                tabColor,
                tabBorderColor,
                paneTextColor,
                tabFontWeight,
                tabBorderRadius,
                tabFontWeightActive,
                colorSegment,
                fontWeightStrong,
                tabColorSegment,
                closeSize,
                closeIconSize,
                closeColorHover,
                closeColorPressed,
                closeBorderRadius,
                [createKey("panePadding", size2)]: panePadding,
                [createKey("tabPadding", sizeType)]: tabPadding,
                [createKey("tabPaddingVertical", sizeType)]: tabPaddingVertical,
                [createKey("tabGap", sizeType)]: tabGap,
                [createKey("tabGap", `${sizeType}Vertical`)]: tabGapVertical,
                [createKey("tabTextColor", type)]: tabTextColor,
                [createKey("tabTextColorActive", type)]: tabTextColorActive,
                [createKey("tabTextColorHover", type)]: tabTextColorHover,
                [createKey("tabTextColorDisabled", type)]: tabTextColorDisabled,
                [createKey("tabFontSize", size2)]: tabFontSize
              },
              common: {
                cubicBezierEaseInOut: cubicBezierEaseInOut2
              }
            } = themeRef.value;
            return {
              "--n-bezier": cubicBezierEaseInOut2,
              "--n-color-segment": colorSegment,
              "--n-bar-color": barColor,
              "--n-tab-font-size": tabFontSize,
              "--n-tab-text-color": tabTextColor,
              "--n-tab-text-color-active": tabTextColorActive,
              "--n-tab-text-color-disabled": tabTextColorDisabled,
              "--n-tab-text-color-hover": tabTextColorHover,
              "--n-pane-text-color": paneTextColor,
              "--n-tab-border-color": tabBorderColor,
              "--n-tab-border-radius": tabBorderRadius,
              "--n-close-size": closeSize,
              "--n-close-icon-size": closeIconSize,
              "--n-close-color-hover": closeColorHover,
              "--n-close-color-pressed": closeColorPressed,
              "--n-close-border-radius": closeBorderRadius,
              "--n-close-icon-color": closeIconColor,
              "--n-close-icon-color-hover": closeIconColorHover,
              "--n-close-icon-color-pressed": closeIconColorPressed,
              "--n-tab-color": tabColor,
              "--n-tab-font-weight": tabFontWeight,
              "--n-tab-font-weight-active": tabFontWeightActive,
              "--n-tab-padding": tabPadding,
              "--n-tab-padding-vertical": tabPaddingVertical,
              "--n-tab-gap": tabGap,
              "--n-tab-gap-vertical": tabGapVertical,
              "--n-pane-padding-left": getMargin(panePadding, "left"),
              "--n-pane-padding-right": getMargin(panePadding, "right"),
              "--n-pane-padding-top": getMargin(panePadding, "top"),
              "--n-pane-padding-bottom": getMargin(panePadding, "bottom"),
              "--n-font-weight-strong": fontWeightStrong,
              "--n-tab-color-segment": tabColorSegment
            };
          });
          const themeClassHandle = inlineThemeDisabled ? useThemeClass("tabs", vue.computed(() => {
            return `${compitableSizeRef.value[0]}${props.type[0]}`;
          }), cssVarsRef, props) : void 0;
          return Object.assign({
            mergedClsPrefix: mergedClsPrefixRef,
            mergedValue: mergedValueRef,
            renderedNames: new Set(),
            segmentCapsuleElRef,
            tabsPaneWrapperRef,
            tabsElRef,
            barElRef,
            addTabInstRef,
            xScrollInstRef,
            scrollWrapperElRef,
            addTabFixed: addTabFixedRef,
            tabWrapperStyle: tabWrapperStyleRef,
            handleNavResize,
            mergedSize: compitableSizeRef,
            handleScroll,
            handleTabsResize,
            cssVars: inlineThemeDisabled ? void 0 : cssVarsRef,
            themeClass: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.themeClass,
            animationDirection: animationDirectionRef,
            renderNameListRef,
            yScrollElRef,
            handleSegmentResize,
            onAnimationBeforeLeave,
            onAnimationEnter,
            onAnimationAfterEnter,
            onRender: themeClassHandle === null || themeClassHandle === void 0 ? void 0 : themeClassHandle.onRender
          }, exposedMethods);
        },
        render() {
          const {
            mergedClsPrefix,
            type,
            placement,
            addTabFixed,
            addable,
            mergedSize,
            renderNameListRef,
            onRender,
            paneWrapperClass,
            paneWrapperStyle,
            $slots: {
              default: defaultSlot,
              prefix: prefixSlot,
              suffix: suffixSlot
            }
          } = this;
          onRender === null || onRender === void 0 ? void 0 : onRender();
          const tabPaneChildren = defaultSlot ? flatten$2(defaultSlot()).filter((v) => {
            return v.type.__TAB_PANE__ === true;
          }) : [];
          const tabChildren = defaultSlot ? flatten$2(defaultSlot()).filter((v) => {
            return v.type.__TAB__ === true;
          }) : [];
          const showPane = !tabChildren.length;
          const isCard = type === "card";
          const isSegment = type === "segment";
          const mergedJustifyContent = !isCard && !isSegment && this.justifyContent;
          renderNameListRef.value = [];
          const scrollContent = () => {
            const tabs = vue.h("div", {
              style: this.tabWrapperStyle,
              class: `${mergedClsPrefix}-tabs-wrapper`
            }, mergedJustifyContent ? null : vue.h("div", {
              class: `${mergedClsPrefix}-tabs-scroll-padding`,
              style: placement === "top" || placement === "bottom" ? {
                width: `${this.tabsPadding}px`
              } : {
                height: `${this.tabsPadding}px`
              }
            }), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
              renderNameListRef.value.push(tabPaneVNode.props.name);
              return justifyTabDynamicProps(vue.h(Tab, Object.assign({}, tabPaneVNode.props, {
                internalCreatedByPane: true,
                internalLeftPadded: index !== 0 && (!mergedJustifyContent || mergedJustifyContent === "center" || mergedJustifyContent === "start" || mergedJustifyContent === "end")
              }), tabPaneVNode.children ? {
                default: tabPaneVNode.children.tab
              } : void 0));
            }) : tabChildren.map((tabVNode, index) => {
              renderNameListRef.value.push(tabVNode.props.name);
              if (index !== 0 && !mergedJustifyContent) {
                return justifyTabDynamicProps(createLeftPaddedTabVNode(tabVNode));
              } else {
                return justifyTabDynamicProps(tabVNode);
              }
            }), !addTabFixed && addable && isCard ? createAddTag(addable, (showPane ? tabPaneChildren.length : tabChildren.length) !== 0) : null, mergedJustifyContent ? null : vue.h("div", {
              class: `${mergedClsPrefix}-tabs-scroll-padding`,
              style: {
                width: `${this.tabsPadding}px`
              }
            }));
            return vue.h("div", {
              ref: "tabsElRef",
              class: `${mergedClsPrefix}-tabs-nav-scroll-content`
            }, isCard && addable ? vue.h(VResizeObserver, {
              onResize: this.handleTabsResize
            }, {
              default: () => tabs
            }) : tabs, isCard ? vue.h("div", {
              class: `${mergedClsPrefix}-tabs-pad`
            }) : null, isCard ? null : vue.h("div", {
              ref: "barElRef",
              class: `${mergedClsPrefix}-tabs-bar`
            }));
          };
          const resolvedPlacement = isSegment ? "top" : placement;
          return vue.h("div", {
            class: [`${mergedClsPrefix}-tabs`, this.themeClass, `${mergedClsPrefix}-tabs--${type}-type`, `${mergedClsPrefix}-tabs--${mergedSize}-size`, mergedJustifyContent && `${mergedClsPrefix}-tabs--flex`, `${mergedClsPrefix}-tabs--${resolvedPlacement}`],
            style: this.cssVars
          }, vue.h("div", {
            class: [



`${mergedClsPrefix}-tabs-nav--${type}-type`,
              `${mergedClsPrefix}-tabs-nav--${resolvedPlacement}`,
              `${mergedClsPrefix}-tabs-nav`
            ]
          }, resolveWrappedSlot(prefixSlot, (children) => children && vue.h("div", {
            class: `${mergedClsPrefix}-tabs-nav__prefix`
          }, children)), isSegment ? vue.h(VResizeObserver, {
            onResize: this.handleSegmentResize
          }, {
            default: () => vue.h("div", {
              class: `${mergedClsPrefix}-tabs-rail`,
              ref: "tabsElRef"
            }, vue.h("div", {
              class: `${mergedClsPrefix}-tabs-capsule`,
              ref: "segmentCapsuleElRef"
            }, vue.h("div", {
              class: `${mergedClsPrefix}-tabs-wrapper`
            }, vue.h("div", {
              class: `${mergedClsPrefix}-tabs-tab`
            }))), showPane ? tabPaneChildren.map((tabPaneVNode, index) => {
              renderNameListRef.value.push(tabPaneVNode.props.name);
              return vue.h(Tab, Object.assign({}, tabPaneVNode.props, {
                internalCreatedByPane: true,
                internalLeftPadded: index !== 0
              }), tabPaneVNode.children ? {
                default: tabPaneVNode.children.tab
              } : void 0);
            }) : tabChildren.map((tabVNode, index) => {
              renderNameListRef.value.push(tabVNode.props.name);
              if (index === 0) {
                return tabVNode;
              } else {
                return createLeftPaddedTabVNode(tabVNode);
              }
            }))
          }) : vue.h(VResizeObserver, {
            onResize: this.handleNavResize
          }, {
            default: () => vue.h("div", {
              class: `${mergedClsPrefix}-tabs-nav-scroll-wrapper`,
              ref: "scrollWrapperElRef"
            }, ["top", "bottom"].includes(resolvedPlacement) ? vue.h(VXScroll, {
              ref: "xScrollInstRef",
              onScroll: this.handleScroll
            }, {
              default: scrollContent
            }) : vue.h("div", {
              class: `${mergedClsPrefix}-tabs-nav-y-scroll`,
              onScroll: this.handleScroll,
              ref: "yScrollElRef"
            }, scrollContent()))
          }), addTabFixed && addable && isCard ? createAddTag(addable, true) : null, resolveWrappedSlot(suffixSlot, (children) => children && vue.h("div", {
            class: `${mergedClsPrefix}-tabs-nav__suffix`
          }, children))), showPane && (this.animated && (resolvedPlacement === "top" || resolvedPlacement === "bottom") ? vue.h("div", {
            ref: "tabsPaneWrapperRef",
            style: paneWrapperStyle,
            class: [`${mergedClsPrefix}-tabs-pane-wrapper`, paneWrapperClass]
          }, filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames, this.onAnimationBeforeLeave, this.onAnimationEnter, this.onAnimationAfterEnter, this.animationDirection)) : filterMapTabPanes(tabPaneChildren, this.mergedValue, this.renderedNames)));
        }
      });
      function filterMapTabPanes(tabPaneVNodes, value, renderedNames, onBeforeLeave, onEnter, onAfterEnter, animationDirection) {
        const children = [];
        tabPaneVNodes.forEach((vNode) => {
          const {
            name,
            displayDirective,
            "display-directive": _displayDirective
          } = vNode.props;
          const matchDisplayDirective = (directive) => displayDirective === directive || _displayDirective === directive;
          const show = value === name;
          if (vNode.key !== void 0) {
            vNode.key = name;
          }
          if (show || matchDisplayDirective("show") || matchDisplayDirective("show:lazy") && renderedNames.has(name)) {
            if (!renderedNames.has(name)) {
              renderedNames.add(name);
            }
            const useVShow = !matchDisplayDirective("if");
            children.push(useVShow ? vue.withDirectives(vNode, [[vue.vShow, show]]) : vNode);
          }
        });
        if (!animationDirection) {
          return children;
        }
        return vue.h(vue.TransitionGroup, {
          name: `${animationDirection}-transition`,
          onBeforeLeave,
          onEnter,
          onAfterEnter
        }, {
          default: () => children
        });
      }
      function createAddTag(addable, internalLeftPadded) {
        return vue.h(Tab, {
          ref: "addTabInstRef",
          key: "__addable",
          name: "__addable",
          internalCreatedByPane: true,
          internalAddable: true,
          internalLeftPadded,
          disabled: typeof addable === "object" && addable.disabled
        });
      }
      function createLeftPaddedTabVNode(tabVNode) {
        const modifiedVNode = vue.cloneVNode(tabVNode);
        if (modifiedVNode.props) {
          modifiedVNode.props.internalLeftPadded = true;
        } else {
          modifiedVNode.props = {
            internalLeftPadded: true
          };
        }
        return modifiedVNode;
      }
      function justifyTabDynamicProps(tabVNode) {
        if (Array.isArray(tabVNode.dynamicProps)) {
          if (!tabVNode.dynamicProps.includes("internalLeftPadded")) {
            tabVNode.dynamicProps.push("internalLeftPadded");
          }
        } else {
          tabVNode.dynamicProps = ["internalLeftPadded"];
        }
        return tabVNode;
      }
      var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
      var lodash$1 = { exports: {} };
      /**
       * @license
       * Lodash <https://lodash.com/>
       * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
       * Released under MIT license <https://lodash.com/license>
       * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
       * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
       */
      var lodash = lodash$1.exports;
      var hasRequiredLodash;
      function requireLodash() {
        if (hasRequiredLodash) return lodash$1.exports;
        hasRequiredLodash = 1;
        (function(module2, exports2) {
          (function() {
            var undefined$1;
            var VERSION = "4.17.21";
            var LARGE_ARRAY_SIZE2 = 200;
            var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT2 = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
            var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
            var MAX_MEMOIZE_SIZE2 = 500;
            var PLACEHOLDER = "__lodash_placeholder__";
            var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
            var COMPARE_PARTIAL_FLAG2 = 1, COMPARE_UNORDERED_FLAG2 = 2;
            var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
            var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
            var HOT_COUNT2 = 800, HOT_SPAN2 = 16;
            var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
            var INFINITY = 1 / 0, MAX_SAFE_INTEGER2 = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN2 = 0 / 0;
            var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
            var wrapFlags = [
              ["ary", WRAP_ARY_FLAG],
              ["bind", WRAP_BIND_FLAG],
              ["bindKey", WRAP_BIND_KEY_FLAG],
              ["curry", WRAP_CURRY_FLAG],
              ["curryRight", WRAP_CURRY_RIGHT_FLAG],
              ["flip", WRAP_FLIP_FLAG],
              ["partial", WRAP_PARTIAL_FLAG],
              ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
              ["rearg", WRAP_REARG_FLAG]
            ];
            var argsTag2 = "[object Arguments]", arrayTag2 = "[object Array]", asyncTag2 = "[object AsyncFunction]", boolTag2 = "[object Boolean]", dateTag2 = "[object Date]", domExcTag = "[object DOMException]", errorTag2 = "[object Error]", funcTag2 = "[object Function]", genTag2 = "[object GeneratorFunction]", mapTag2 = "[object Map]", numberTag2 = "[object Number]", nullTag2 = "[object Null]", objectTag2 = "[object Object]", promiseTag2 = "[object Promise]", proxyTag2 = "[object Proxy]", regexpTag2 = "[object RegExp]", setTag2 = "[object Set]", stringTag2 = "[object String]", symbolTag2 = "[object Symbol]", undefinedTag2 = "[object Undefined]", weakMapTag2 = "[object WeakMap]", weakSetTag = "[object WeakSet]";
            var arrayBufferTag2 = "[object ArrayBuffer]", dataViewTag2 = "[object DataView]", float32Tag2 = "[object Float32Array]", float64Tag2 = "[object Float64Array]", int8Tag2 = "[object Int8Array]", int16Tag2 = "[object Int16Array]", int32Tag2 = "[object Int32Array]", uint8Tag2 = "[object Uint8Array]", uint8ClampedTag2 = "[object Uint8ClampedArray]", uint16Tag2 = "[object Uint16Array]", uint32Tag2 = "[object Uint32Array]";
            var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
            var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
            var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
            var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp2 = /^\w*$/, rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
            var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar2.source);
            var reTrimStart2 = /^\s+/;
            var reWhitespace2 = /\s/;
            var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
            var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
            var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
            var reEscapeChar2 = /\\(\\)?/g;
            var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
            var reFlags = /\w*$/;
            var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
            var reIsBinary2 = /^0b[01]+$/i;
            var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
            var reIsOctal2 = /^0o[0-7]+$/i;
            var reIsUint2 = /^(?:0|[1-9]\d*)$/;
            var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
            var reNoMatch = /($^)/;
            var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
            var rsAstralRange2 = "\\ud800-\\udfff", rsComboMarksRange2 = "\\u0300-\\u036f", reComboHalfMarksRange2 = "\\ufe20-\\ufe2f", rsComboSymbolsRange2 = "\\u20d0-\\u20ff", rsComboRange2 = rsComboMarksRange2 + reComboHalfMarksRange2 + rsComboSymbolsRange2, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange2 = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
            var rsApos = "['’]", rsAstral2 = "[" + rsAstralRange2 + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo2 = "[" + rsComboRange2 + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange2 + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz2 = "\\ud83c[\\udffb-\\udfff]", rsModifier2 = "(?:" + rsCombo2 + "|" + rsFitz2 + ")", rsNonAstral2 = "[^" + rsAstralRange2 + "]", rsRegional2 = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair2 = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ2 = "\\u200d";
            var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod2 = rsModifier2 + "?", rsOptVar2 = "[" + rsVarRange2 + "]?", rsOptJoin2 = "(?:" + rsZWJ2 + "(?:" + [rsNonAstral2, rsRegional2, rsSurrPair2].join("|") + ")" + rsOptVar2 + reOptMod2 + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq2 = rsOptVar2 + reOptMod2 + rsOptJoin2, rsEmoji = "(?:" + [rsDingbat, rsRegional2, rsSurrPair2].join("|") + ")" + rsSeq2, rsSymbol2 = "(?:" + [rsNonAstral2 + rsCombo2 + "?", rsCombo2, rsRegional2, rsSurrPair2, rsAstral2].join("|") + ")";
            var reApos = RegExp(rsApos, "g");
            var reComboMark = RegExp(rsCombo2, "g");
            var reUnicode2 = RegExp(rsFitz2 + "(?=" + rsFitz2 + ")|" + rsSymbol2 + rsSeq2, "g");
            var reUnicodeWord = RegExp([
              rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
              rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
              rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
              rsUpper + "+" + rsOptContrUpper,
              rsOrdUpper,
              rsOrdLower,
              rsDigits,
              rsEmoji
            ].join("|"), "g");
            var reHasUnicode2 = RegExp("[" + rsZWJ2 + rsAstralRange2 + rsComboRange2 + rsVarRange2 + "]");
            var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
            var contextProps = [
              "Array",
              "Buffer",
              "DataView",
              "Date",
              "Error",
              "Float32Array",
              "Float64Array",
              "Function",
              "Int8Array",
              "Int16Array",
              "Int32Array",
              "Map",
              "Math",
              "Object",
              "Promise",
              "RegExp",
              "Set",
              "String",
              "Symbol",
              "TypeError",
              "Uint8Array",
              "Uint8ClampedArray",
              "Uint16Array",
              "Uint32Array",
              "WeakMap",
              "_",
              "clearTimeout",
              "isFinite",
              "parseInt",
              "setTimeout"
            ];
            var templateCounter = -1;
            var typedArrayTags2 = {};
            typedArrayTags2[float32Tag2] = typedArrayTags2[float64Tag2] = typedArrayTags2[int8Tag2] = typedArrayTags2[int16Tag2] = typedArrayTags2[int32Tag2] = typedArrayTags2[uint8Tag2] = typedArrayTags2[uint8ClampedTag2] = typedArrayTags2[uint16Tag2] = typedArrayTags2[uint32Tag2] = true;
            typedArrayTags2[argsTag2] = typedArrayTags2[arrayTag2] = typedArrayTags2[arrayBufferTag2] = typedArrayTags2[boolTag2] = typedArrayTags2[dataViewTag2] = typedArrayTags2[dateTag2] = typedArrayTags2[errorTag2] = typedArrayTags2[funcTag2] = typedArrayTags2[mapTag2] = typedArrayTags2[numberTag2] = typedArrayTags2[objectTag2] = typedArrayTags2[regexpTag2] = typedArrayTags2[setTag2] = typedArrayTags2[stringTag2] = typedArrayTags2[weakMapTag2] = false;
            var cloneableTags = {};
            cloneableTags[argsTag2] = cloneableTags[arrayTag2] = cloneableTags[arrayBufferTag2] = cloneableTags[dataViewTag2] = cloneableTags[boolTag2] = cloneableTags[dateTag2] = cloneableTags[float32Tag2] = cloneableTags[float64Tag2] = cloneableTags[int8Tag2] = cloneableTags[int16Tag2] = cloneableTags[int32Tag2] = cloneableTags[mapTag2] = cloneableTags[numberTag2] = cloneableTags[objectTag2] = cloneableTags[regexpTag2] = cloneableTags[setTag2] = cloneableTags[stringTag2] = cloneableTags[symbolTag2] = cloneableTags[uint8Tag2] = cloneableTags[uint8ClampedTag2] = cloneableTags[uint16Tag2] = cloneableTags[uint32Tag2] = true;
            cloneableTags[errorTag2] = cloneableTags[funcTag2] = cloneableTags[weakMapTag2] = false;
            var deburredLetters = {
"À": "A",
              "Á": "A",
              "Â": "A",
              "Ã": "A",
              "Ä": "A",
              "Å": "A",
              "à": "a",
              "á": "a",
              "â": "a",
              "ã": "a",
              "ä": "a",
              "å": "a",
              "Ç": "C",
              "ç": "c",
              "Ð": "D",
              "ð": "d",
              "È": "E",
              "É": "E",
              "Ê": "E",
              "Ë": "E",
              "è": "e",
              "é": "e",
              "ê": "e",
              "ë": "e",
              "Ì": "I",
              "Í": "I",
              "Î": "I",
              "Ï": "I",
              "ì": "i",
              "í": "i",
              "î": "i",
              "ï": "i",
              "Ñ": "N",
              "ñ": "n",
              "Ò": "O",
              "Ó": "O",
              "Ô": "O",
              "Õ": "O",
              "Ö": "O",
              "Ø": "O",
              "ò": "o",
              "ó": "o",
              "ô": "o",
              "õ": "o",
              "ö": "o",
              "ø": "o",
              "Ù": "U",
              "Ú": "U",
              "Û": "U",
              "Ü": "U",
              "ù": "u",
              "ú": "u",
              "û": "u",
              "ü": "u",
              "Ý": "Y",
              "ý": "y",
              "ÿ": "y",
              "Æ": "Ae",
              "æ": "ae",
              "Þ": "Th",
              "þ": "th",
              "ß": "ss",
"Ā": "A",
              "Ă": "A",
              "Ą": "A",
              "ā": "a",
              "ă": "a",
              "ą": "a",
              "Ć": "C",
              "Ĉ": "C",
              "Ċ": "C",
              "Č": "C",
              "ć": "c",
              "ĉ": "c",
              "ċ": "c",
              "č": "c",
              "Ď": "D",
              "Đ": "D",
              "ď": "d",
              "đ": "d",
              "Ē": "E",
              "Ĕ": "E",
              "Ė": "E",
              "Ę": "E",
              "Ě": "E",
              "ē": "e",
              "ĕ": "e",
              "ė": "e",
              "ę": "e",
              "ě": "e",
              "Ĝ": "G",
              "Ğ": "G",
              "Ġ": "G",
              "Ģ": "G",
              "ĝ": "g",
              "ğ": "g",
              "ġ": "g",
              "ģ": "g",
              "Ĥ": "H",
              "Ħ": "H",
              "ĥ": "h",
              "ħ": "h",
              "Ĩ": "I",
              "Ī": "I",
              "Ĭ": "I",
              "Į": "I",
              "İ": "I",
              "ĩ": "i",
              "ī": "i",
              "ĭ": "i",
              "į": "i",
              "ı": "i",
              "Ĵ": "J",
              "ĵ": "j",
              "Ķ": "K",
              "ķ": "k",
              "ĸ": "k",
              "Ĺ": "L",
              "Ļ": "L",
              "Ľ": "L",
              "Ŀ": "L",
              "Ł": "L",
              "ĺ": "l",
              "ļ": "l",
              "ľ": "l",
              "ŀ": "l",
              "ł": "l",
              "Ń": "N",
              "Ņ": "N",
              "Ň": "N",
              "Ŋ": "N",
              "ń": "n",
              "ņ": "n",
              "ň": "n",
              "ŋ": "n",
              "Ō": "O",
              "Ŏ": "O",
              "Ő": "O",
              "ō": "o",
              "ŏ": "o",
              "ő": "o",
              "Ŕ": "R",
              "Ŗ": "R",
              "Ř": "R",
              "ŕ": "r",
              "ŗ": "r",
              "ř": "r",
              "Ś": "S",
              "Ŝ": "S",
              "Ş": "S",
              "Š": "S",
              "ś": "s",
              "ŝ": "s",
              "ş": "s",
              "š": "s",
              "Ţ": "T",
              "Ť": "T",
              "Ŧ": "T",
              "ţ": "t",
              "ť": "t",
              "ŧ": "t",
              "Ũ": "U",
              "Ū": "U",
              "Ŭ": "U",
              "Ů": "U",
              "Ű": "U",
              "Ų": "U",
              "ũ": "u",
              "ū": "u",
              "ŭ": "u",
              "ů": "u",
              "ű": "u",
              "ų": "u",
              "Ŵ": "W",
              "ŵ": "w",
              "Ŷ": "Y",
              "ŷ": "y",
              "Ÿ": "Y",
              "Ź": "Z",
              "Ż": "Z",
              "Ž": "Z",
              "ź": "z",
              "ż": "z",
              "ž": "z",
              "Ĳ": "IJ",
              "ĳ": "ij",
              "Œ": "Oe",
              "œ": "oe",
              "ŉ": "'n",
              "ſ": "s"
            };
            var htmlEscapes = {
              "&": "&amp;",
              "<": "&lt;",
              ">": "&gt;",
              '"': "&quot;",
              "'": "&#39;"
            };
            var htmlUnescapes = {
              "&amp;": "&",
              "&lt;": "<",
              "&gt;": ">",
              "&quot;": '"',
              "&#39;": "'"
            };
            var stringEscapes = {
              "\\": "\\",
              "'": "'",
              "\n": "n",
              "\r": "r",
              "\u2028": "u2028",
              "\u2029": "u2029"
            };
            var freeParseFloat = parseFloat, freeParseInt2 = parseInt;
            var freeGlobal2 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
            var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
            var root2 = freeGlobal2 || freeSelf2 || Function("return this")();
            var freeExports2 = exports2 && !exports2.nodeType && exports2;
            var freeModule2 = freeExports2 && true && module2 && !module2.nodeType && module2;
            var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
            var freeProcess2 = moduleExports2 && freeGlobal2.process;
            var nodeUtil2 = (function() {
              try {
                var types2 = freeModule2 && freeModule2.require && freeModule2.require("util").types;
                if (types2) {
                  return types2;
                }
                return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
              } catch (e) {
              }
            })();
            var nodeIsArrayBuffer = nodeUtil2 && nodeUtil2.isArrayBuffer, nodeIsDate = nodeUtil2 && nodeUtil2.isDate, nodeIsMap = nodeUtil2 && nodeUtil2.isMap, nodeIsRegExp = nodeUtil2 && nodeUtil2.isRegExp, nodeIsSet = nodeUtil2 && nodeUtil2.isSet, nodeIsTypedArray2 = nodeUtil2 && nodeUtil2.isTypedArray;
            function apply2(func, thisArg, args) {
              switch (args.length) {
                case 0:
                  return func.call(thisArg);
                case 1:
                  return func.call(thisArg, args[0]);
                case 2:
                  return func.call(thisArg, args[0], args[1]);
                case 3:
                  return func.call(thisArg, args[0], args[1], args[2]);
              }
              return func.apply(thisArg, args);
            }
            function arrayAggregator(array, setter, iteratee, accumulator) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                var value = array[index];
                setter(accumulator, value, iteratee(value), array);
              }
              return accumulator;
            }
            function arrayEach2(array, iteratee) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                if (iteratee(array[index], index, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayEachRight(array, iteratee) {
              var length = array == null ? 0 : array.length;
              while (length--) {
                if (iteratee(array[length], length, array) === false) {
                  break;
                }
              }
              return array;
            }
            function arrayEvery(array, predicate) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                if (!predicate(array[index], index, array)) {
                  return false;
                }
              }
              return true;
            }
            function arrayFilter2(array, predicate) {
              var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
              while (++index < length) {
                var value = array[index];
                if (predicate(value, index, array)) {
                  result[resIndex++] = value;
                }
              }
              return result;
            }
            function arrayIncludes(array, value) {
              var length = array == null ? 0 : array.length;
              return !!length && baseIndexOf(array, value, 0) > -1;
            }
            function arrayIncludesWith(array, value, comparator) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                if (comparator(value, array[index])) {
                  return true;
                }
              }
              return false;
            }
            function arrayMap2(array, iteratee) {
              var index = -1, length = array == null ? 0 : array.length, result = Array(length);
              while (++index < length) {
                result[index] = iteratee(array[index], index, array);
              }
              return result;
            }
            function arrayPush2(array, values) {
              var index = -1, length = values.length, offset = array.length;
              while (++index < length) {
                array[offset + index] = values[index];
              }
              return array;
            }
            function arrayReduce(array, iteratee, accumulator, initAccum) {
              var index = -1, length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[++index];
              }
              while (++index < length) {
                accumulator = iteratee(accumulator, array[index], index, array);
              }
              return accumulator;
            }
            function arrayReduceRight(array, iteratee, accumulator, initAccum) {
              var length = array == null ? 0 : array.length;
              if (initAccum && length) {
                accumulator = array[--length];
              }
              while (length--) {
                accumulator = iteratee(accumulator, array[length], length, array);
              }
              return accumulator;
            }
            function arraySome2(array, predicate) {
              var index = -1, length = array == null ? 0 : array.length;
              while (++index < length) {
                if (predicate(array[index], index, array)) {
                  return true;
                }
              }
              return false;
            }
            var asciiSize = baseProperty2("length");
            function asciiToArray2(string2) {
              return string2.split("");
            }
            function asciiWords(string2) {
              return string2.match(reAsciiWord) || [];
            }
            function baseFindKey(collection, predicate, eachFunc) {
              var result;
              eachFunc(collection, function(value, key, collection2) {
                if (predicate(value, key, collection2)) {
                  result = key;
                  return false;
                }
              });
              return result;
            }
            function baseFindIndex(array, predicate, fromIndex, fromRight) {
              var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
              while (fromRight ? index-- : ++index < length) {
                if (predicate(array[index], index, array)) {
                  return index;
                }
              }
              return -1;
            }
            function baseIndexOf(array, value, fromIndex) {
              return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
            }
            function baseIndexOfWith(array, value, fromIndex, comparator) {
              var index = fromIndex - 1, length = array.length;
              while (++index < length) {
                if (comparator(array[index], value)) {
                  return index;
                }
              }
              return -1;
            }
            function baseIsNaN(value) {
              return value !== value;
            }
            function baseMean(array, iteratee) {
              var length = array == null ? 0 : array.length;
              return length ? baseSum(array, iteratee) / length : NAN2;
            }
            function baseProperty2(key) {
              return function(object) {
                return object == null ? undefined$1 : object[key];
              };
            }
            function basePropertyOf(object) {
              return function(key) {
                return object == null ? undefined$1 : object[key];
              };
            }
            function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
              eachFunc(collection, function(value, index, collection2) {
                accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
              });
              return accumulator;
            }
            function baseSortBy(array, comparer) {
              var length = array.length;
              array.sort(comparer);
              while (length--) {
                array[length] = array[length].value;
              }
              return array;
            }
            function baseSum(array, iteratee) {
              var result, index = -1, length = array.length;
              while (++index < length) {
                var current = iteratee(array[index]);
                if (current !== undefined$1) {
                  result = result === undefined$1 ? current : result + current;
                }
              }
              return result;
            }
            function baseTimes2(n, iteratee) {
              var index = -1, result = Array(n);
              while (++index < n) {
                result[index] = iteratee(index);
              }
              return result;
            }
            function baseToPairs(object, props) {
              return arrayMap2(props, function(key) {
                return [key, object[key]];
              });
            }
            function baseTrim2(string2) {
              return string2 ? string2.slice(0, trimmedEndIndex2(string2) + 1).replace(reTrimStart2, "") : string2;
            }
            function baseUnary2(func) {
              return function(value) {
                return func(value);
              };
            }
            function baseValues(object, props) {
              return arrayMap2(props, function(key) {
                return object[key];
              });
            }
            function cacheHas2(cache2, key) {
              return cache2.has(key);
            }
            function charsStartIndex(strSymbols, chrSymbols) {
              var index = -1, length = strSymbols.length;
              while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
              }
              return index;
            }
            function charsEndIndex(strSymbols, chrSymbols) {
              var index = strSymbols.length;
              while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
              }
              return index;
            }
            function countHolders(array, placeholder) {
              var length = array.length, result = 0;
              while (length--) {
                if (array[length] === placeholder) {
                  ++result;
                }
              }
              return result;
            }
            var deburrLetter = basePropertyOf(deburredLetters);
            var escapeHtmlChar = basePropertyOf(htmlEscapes);
            function escapeStringChar(chr) {
              return "\\" + stringEscapes[chr];
            }
            function getValue2(object, key) {
              return object == null ? undefined$1 : object[key];
            }
            function hasUnicode2(string2) {
              return reHasUnicode2.test(string2);
            }
            function hasUnicodeWord(string2) {
              return reHasUnicodeWord.test(string2);
            }
            function iteratorToArray(iterator) {
              var data, result = [];
              while (!(data = iterator.next()).done) {
                result.push(data.value);
              }
              return result;
            }
            function mapToArray2(map2) {
              var index = -1, result = Array(map2.size);
              map2.forEach(function(value, key) {
                result[++index] = [key, value];
              });
              return result;
            }
            function overArg2(func, transform) {
              return function(arg) {
                return func(transform(arg));
              };
            }
            function replaceHolders(array, placeholder) {
              var index = -1, length = array.length, resIndex = 0, result = [];
              while (++index < length) {
                var value = array[index];
                if (value === placeholder || value === PLACEHOLDER) {
                  array[index] = PLACEHOLDER;
                  result[resIndex++] = index;
                }
              }
              return result;
            }
            function setToArray2(set) {
              var index = -1, result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = value;
              });
              return result;
            }
            function setToPairs(set) {
              var index = -1, result = Array(set.size);
              set.forEach(function(value) {
                result[++index] = [value, value];
              });
              return result;
            }
            function strictIndexOf(array, value, fromIndex) {
              var index = fromIndex - 1, length = array.length;
              while (++index < length) {
                if (array[index] === value) {
                  return index;
                }
              }
              return -1;
            }
            function strictLastIndexOf(array, value, fromIndex) {
              var index = fromIndex + 1;
              while (index--) {
                if (array[index] === value) {
                  return index;
                }
              }
              return index;
            }
            function stringSize(string2) {
              return hasUnicode2(string2) ? unicodeSize(string2) : asciiSize(string2);
            }
            function stringToArray2(string2) {
              return hasUnicode2(string2) ? unicodeToArray2(string2) : asciiToArray2(string2);
            }
            function trimmedEndIndex2(string2) {
              var index = string2.length;
              while (index-- && reWhitespace2.test(string2.charAt(index))) {
              }
              return index;
            }
            var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
            function unicodeSize(string2) {
              var result = reUnicode2.lastIndex = 0;
              while (reUnicode2.test(string2)) {
                ++result;
              }
              return result;
            }
            function unicodeToArray2(string2) {
              return string2.match(reUnicode2) || [];
            }
            function unicodeWords(string2) {
              return string2.match(reUnicodeWord) || [];
            }
            var runInContext = (function runInContext2(context) {
              context = context == null ? root2 : _.defaults(root2.Object(), context, _.pick(root2, contextProps));
              var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
              var arrayProto2 = Array2.prototype, funcProto2 = Function2.prototype, objectProto2 = Object2.prototype;
              var coreJsData2 = context["__core-js_shared__"];
              var funcToString2 = funcProto2.toString;
              var hasOwnProperty2 = objectProto2.hasOwnProperty;
              var idCounter = 0;
              var maskSrcKey2 = (function() {
                var uid = /[^.]+$/.exec(coreJsData2 && coreJsData2.keys && coreJsData2.keys.IE_PROTO || "");
                return uid ? "Symbol(src)_1." + uid : "";
              })();
              var nativeObjectToString2 = objectProto2.toString;
              var objectCtorString2 = funcToString2.call(Object2);
              var oldDash = root2._;
              var reIsNative2 = RegExp2(
                "^" + funcToString2.call(hasOwnProperty2).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
              );
              var Buffer3 = moduleExports2 ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array3 = context.Uint8Array, allocUnsafe = Buffer3 ? Buffer3.allocUnsafe : undefined$1, getPrototype2 = overArg2(Object2.getPrototypeOf, Object2), objectCreate2 = Object2.create, propertyIsEnumerable2 = objectProto2.propertyIsEnumerable, splice2 = arrayProto2.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag2 = Symbol2 ? Symbol2.toStringTag : undefined$1;
              var defineProperty2 = (function() {
                try {
                  var func = getNative2(Object2, "defineProperty");
                  func({}, "", {});
                  return func;
                } catch (e) {
                }
              })();
              var ctxClearTimeout = context.clearTimeout !== root2.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root2.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root2.setTimeout && context.setTimeout;
              var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols2 = Object2.getOwnPropertySymbols, nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto2.join, nativeKeys2 = overArg2(Object2.keys, Object2), nativeMax2 = Math2.max, nativeMin2 = Math2.min, nativeNow2 = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto2.reverse;
              var DataView2 = getNative2(context, "DataView"), Map2 = getNative2(context, "Map"), Promise2 = getNative2(context, "Promise"), Set2 = getNative2(context, "Set"), WeakMap2 = getNative2(context, "WeakMap"), nativeCreate2 = getNative2(Object2, "create");
              var metaMap = WeakMap2 && new WeakMap2();
              var realNames = {};
              var dataViewCtorString2 = toSource2(DataView2), mapCtorString2 = toSource2(Map2), promiseCtorString2 = toSource2(Promise2), setCtorString2 = toSource2(Set2), weakMapCtorString2 = toSource2(WeakMap2);
              var symbolProto2 = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : undefined$1, symbolToString2 = symbolProto2 ? symbolProto2.toString : undefined$1;
              function lodash2(value) {
                if (isObjectLike2(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
                  if (value instanceof LodashWrapper) {
                    return value;
                  }
                  if (hasOwnProperty2.call(value, "__wrapped__")) {
                    return wrapperClone(value);
                  }
                }
                return new LodashWrapper(value);
              }
              var baseCreate2 = (function() {
                function object() {
                }
                return function(proto) {
                  if (!isObject2(proto)) {
                    return {};
                  }
                  if (objectCreate2) {
                    return objectCreate2(proto);
                  }
                  object.prototype = proto;
                  var result2 = new object();
                  object.prototype = undefined$1;
                  return result2;
                };
              })();
              function baseLodash() {
              }
              function LodashWrapper(value, chainAll) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__chain__ = !!chainAll;
                this.__index__ = 0;
                this.__values__ = undefined$1;
              }
              lodash2.templateSettings = {
"escape": reEscape,
"evaluate": reEvaluate,
"interpolate": reInterpolate,
"variable": "",
"imports": {
"_": lodash2
                }
              };
              lodash2.prototype = baseLodash.prototype;
              lodash2.prototype.constructor = lodash2;
              LodashWrapper.prototype = baseCreate2(baseLodash.prototype);
              LodashWrapper.prototype.constructor = LodashWrapper;
              function LazyWrapper(value) {
                this.__wrapped__ = value;
                this.__actions__ = [];
                this.__dir__ = 1;
                this.__filtered__ = false;
                this.__iteratees__ = [];
                this.__takeCount__ = MAX_ARRAY_LENGTH;
                this.__views__ = [];
              }
              function lazyClone() {
                var result2 = new LazyWrapper(this.__wrapped__);
                result2.__actions__ = copyArray2(this.__actions__);
                result2.__dir__ = this.__dir__;
                result2.__filtered__ = this.__filtered__;
                result2.__iteratees__ = copyArray2(this.__iteratees__);
                result2.__takeCount__ = this.__takeCount__;
                result2.__views__ = copyArray2(this.__views__);
                return result2;
              }
              function lazyReverse() {
                if (this.__filtered__) {
                  var result2 = new LazyWrapper(this);
                  result2.__dir__ = -1;
                  result2.__filtered__ = true;
                } else {
                  result2 = this.clone();
                  result2.__dir__ *= -1;
                }
                return result2;
              }
              function lazyValue() {
                var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin2(length, this.__takeCount__);
                if (!isArr || !isRight && arrLength == length && takeCount == length) {
                  return baseWrapperValue(array, this.__actions__);
                }
                var result2 = [];
                outer:
                  while (length-- && resIndex < takeCount) {
                    index += dir;
                    var iterIndex = -1, value = array[index];
                    while (++iterIndex < iterLength) {
                      var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed2 = iteratee2(value);
                      if (type == LAZY_MAP_FLAG) {
                        value = computed2;
                      } else if (!computed2) {
                        if (type == LAZY_FILTER_FLAG) {
                          continue outer;
                        } else {
                          break outer;
                        }
                      }
                    }
                    result2[resIndex++] = value;
                  }
                return result2;
              }
              LazyWrapper.prototype = baseCreate2(baseLodash.prototype);
              LazyWrapper.prototype.constructor = LazyWrapper;
              function Hash2(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              function hashClear2() {
                this.__data__ = nativeCreate2 ? nativeCreate2(null) : {};
                this.size = 0;
              }
              function hashDelete2(key) {
                var result2 = this.has(key) && delete this.__data__[key];
                this.size -= result2 ? 1 : 0;
                return result2;
              }
              function hashGet2(key) {
                var data = this.__data__;
                if (nativeCreate2) {
                  var result2 = data[key];
                  return result2 === HASH_UNDEFINED2 ? undefined$1 : result2;
                }
                return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
              }
              function hashHas2(key) {
                var data = this.__data__;
                return nativeCreate2 ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
              }
              function hashSet2(key, value) {
                var data = this.__data__;
                this.size += this.has(key) ? 0 : 1;
                data[key] = nativeCreate2 && value === undefined$1 ? HASH_UNDEFINED2 : value;
                return this;
              }
              Hash2.prototype.clear = hashClear2;
              Hash2.prototype["delete"] = hashDelete2;
              Hash2.prototype.get = hashGet2;
              Hash2.prototype.has = hashHas2;
              Hash2.prototype.set = hashSet2;
              function ListCache2(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              function listCacheClear2() {
                this.__data__ = [];
                this.size = 0;
              }
              function listCacheDelete2(key) {
                var data = this.__data__, index = assocIndexOf2(data, key);
                if (index < 0) {
                  return false;
                }
                var lastIndex = data.length - 1;
                if (index == lastIndex) {
                  data.pop();
                } else {
                  splice2.call(data, index, 1);
                }
                --this.size;
                return true;
              }
              function listCacheGet2(key) {
                var data = this.__data__, index = assocIndexOf2(data, key);
                return index < 0 ? undefined$1 : data[index][1];
              }
              function listCacheHas2(key) {
                return assocIndexOf2(this.__data__, key) > -1;
              }
              function listCacheSet2(key, value) {
                var data = this.__data__, index = assocIndexOf2(data, key);
                if (index < 0) {
                  ++this.size;
                  data.push([key, value]);
                } else {
                  data[index][1] = value;
                }
                return this;
              }
              ListCache2.prototype.clear = listCacheClear2;
              ListCache2.prototype["delete"] = listCacheDelete2;
              ListCache2.prototype.get = listCacheGet2;
              ListCache2.prototype.has = listCacheHas2;
              ListCache2.prototype.set = listCacheSet2;
              function MapCache2(entries) {
                var index = -1, length = entries == null ? 0 : entries.length;
                this.clear();
                while (++index < length) {
                  var entry = entries[index];
                  this.set(entry[0], entry[1]);
                }
              }
              function mapCacheClear2() {
                this.size = 0;
                this.__data__ = {
                  "hash": new Hash2(),
                  "map": new (Map2 || ListCache2)(),
                  "string": new Hash2()
                };
              }
              function mapCacheDelete2(key) {
                var result2 = getMapData2(this, key)["delete"](key);
                this.size -= result2 ? 1 : 0;
                return result2;
              }
              function mapCacheGet2(key) {
                return getMapData2(this, key).get(key);
              }
              function mapCacheHas2(key) {
                return getMapData2(this, key).has(key);
              }
              function mapCacheSet2(key, value) {
                var data = getMapData2(this, key), size3 = data.size;
                data.set(key, value);
                this.size += data.size == size3 ? 0 : 1;
                return this;
              }
              MapCache2.prototype.clear = mapCacheClear2;
              MapCache2.prototype["delete"] = mapCacheDelete2;
              MapCache2.prototype.get = mapCacheGet2;
              MapCache2.prototype.has = mapCacheHas2;
              MapCache2.prototype.set = mapCacheSet2;
              function SetCache2(values2) {
                var index = -1, length = values2 == null ? 0 : values2.length;
                this.__data__ = new MapCache2();
                while (++index < length) {
                  this.add(values2[index]);
                }
              }
              function setCacheAdd2(value) {
                this.__data__.set(value, HASH_UNDEFINED2);
                return this;
              }
              function setCacheHas2(value) {
                return this.__data__.has(value);
              }
              SetCache2.prototype.add = SetCache2.prototype.push = setCacheAdd2;
              SetCache2.prototype.has = setCacheHas2;
              function Stack2(entries) {
                var data = this.__data__ = new ListCache2(entries);
                this.size = data.size;
              }
              function stackClear2() {
                this.__data__ = new ListCache2();
                this.size = 0;
              }
              function stackDelete2(key) {
                var data = this.__data__, result2 = data["delete"](key);
                this.size = data.size;
                return result2;
              }
              function stackGet2(key) {
                return this.__data__.get(key);
              }
              function stackHas2(key) {
                return this.__data__.has(key);
              }
              function stackSet2(key, value) {
                var data = this.__data__;
                if (data instanceof ListCache2) {
                  var pairs = data.__data__;
                  if (!Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
                    pairs.push([key, value]);
                    this.size = ++data.size;
                    return this;
                  }
                  data = this.__data__ = new MapCache2(pairs);
                }
                data.set(key, value);
                this.size = data.size;
                return this;
              }
              Stack2.prototype.clear = stackClear2;
              Stack2.prototype["delete"] = stackDelete2;
              Stack2.prototype.get = stackGet2;
              Stack2.prototype.has = stackHas2;
              Stack2.prototype.set = stackSet2;
              function arrayLikeKeys2(value, inherited) {
                var isArr = isArray2(value), isArg = !isArr && isArguments2(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes2(value.length, String2) : [], length = result2.length;
                for (var key in value) {
                  if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes &&
(key == "length" ||
isBuff && (key == "offset" || key == "parent") ||
isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") ||
isIndex2(key, length)))) {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function arraySample(array) {
                var length = array.length;
                return length ? array[baseRandom(0, length - 1)] : undefined$1;
              }
              function arraySampleSize(array, n) {
                return shuffleSelf(copyArray2(array), baseClamp(n, 0, array.length));
              }
              function arrayShuffle(array) {
                return shuffleSelf(copyArray2(array));
              }
              function assignMergeValue2(object, key, value) {
                if (value !== undefined$1 && !eq2(object[key], value) || value === undefined$1 && !(key in object)) {
                  baseAssignValue2(object, key, value);
                }
              }
              function assignValue2(object, key, value) {
                var objValue = object[key];
                if (!(hasOwnProperty2.call(object, key) && eq2(objValue, value)) || value === undefined$1 && !(key in object)) {
                  baseAssignValue2(object, key, value);
                }
              }
              function assocIndexOf2(array, key) {
                var length = array.length;
                while (length--) {
                  if (eq2(array[length][0], key)) {
                    return length;
                  }
                }
                return -1;
              }
              function baseAggregator(collection, setter, iteratee2, accumulator) {
                baseEach2(collection, function(value, key, collection2) {
                  setter(accumulator, value, iteratee2(value), collection2);
                });
                return accumulator;
              }
              function baseAssign(object, source) {
                return object && copyObject2(source, keys2(source), object);
              }
              function baseAssignIn(object, source) {
                return object && copyObject2(source, keysIn2(source), object);
              }
              function baseAssignValue2(object, key, value) {
                if (key == "__proto__" && defineProperty2) {
                  defineProperty2(object, key, {
                    "configurable": true,
                    "enumerable": true,
                    "value": value,
                    "writable": true
                  });
                } else {
                  object[key] = value;
                }
              }
              function baseAt(object, paths) {
                var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
                while (++index < length) {
                  result2[index] = skip ? undefined$1 : get2(object, paths[index]);
                }
                return result2;
              }
              function baseClamp(number, lower, upper) {
                if (number === number) {
                  if (upper !== undefined$1) {
                    number = number <= upper ? number : upper;
                  }
                  if (lower !== undefined$1) {
                    number = number >= lower ? number : lower;
                  }
                }
                return number;
              }
              function baseClone(value, bitmask, customizer, key, object, stack2) {
                var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
                if (customizer) {
                  result2 = object ? customizer(value, key, object, stack2) : customizer(value);
                }
                if (result2 !== undefined$1) {
                  return result2;
                }
                if (!isObject2(value)) {
                  return value;
                }
                var isArr = isArray2(value);
                if (isArr) {
                  result2 = initCloneArray(value);
                  if (!isDeep) {
                    return copyArray2(value, result2);
                  }
                } else {
                  var tag = getTag2(value), isFunc = tag == funcTag2 || tag == genTag2;
                  if (isBuffer2(value)) {
                    return cloneBuffer2(value, isDeep);
                  }
                  if (tag == objectTag2 || tag == argsTag2 || isFunc && !object) {
                    result2 = isFlat || isFunc ? {} : initCloneObject2(value);
                    if (!isDeep) {
                      return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
                    }
                  } else {
                    if (!cloneableTags[tag]) {
                      return object ? value : {};
                    }
                    result2 = initCloneByTag(value, tag, isDeep);
                  }
                }
                stack2 || (stack2 = new Stack2());
                var stacked = stack2.get(value);
                if (stacked) {
                  return stacked;
                }
                stack2.set(value, result2);
                if (isSet(value)) {
                  value.forEach(function(subValue) {
                    result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack2));
                  });
                } else if (isMap(value)) {
                  value.forEach(function(subValue, key2) {
                    result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
                  });
                }
                var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys2 : isFlat ? keysIn2 : keys2;
                var props = isArr ? undefined$1 : keysFunc(value);
                arrayEach2(props || value, function(subValue, key2) {
                  if (props) {
                    key2 = subValue;
                    subValue = value[key2];
                  }
                  assignValue2(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack2));
                });
                return result2;
              }
              function baseConforms(source) {
                var props = keys2(source);
                return function(object) {
                  return baseConformsTo(object, source, props);
                };
              }
              function baseConformsTo(object, source, props) {
                var length = props.length;
                if (object == null) {
                  return !length;
                }
                object = Object2(object);
                while (length--) {
                  var key = props[length], predicate = source[key], value = object[key];
                  if (value === undefined$1 && !(key in object) || !predicate(value)) {
                    return false;
                  }
                }
                return true;
              }
              function baseDelay(func, wait, args) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                return setTimeout2(function() {
                  func.apply(undefined$1, args);
                }, wait);
              }
              function baseDifference(array, values2, iteratee2, comparator) {
                var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
                if (!length) {
                  return result2;
                }
                if (iteratee2) {
                  values2 = arrayMap2(values2, baseUnary2(iteratee2));
                }
                if (comparator) {
                  includes2 = arrayIncludesWith;
                  isCommon = false;
                } else if (values2.length >= LARGE_ARRAY_SIZE2) {
                  includes2 = cacheHas2;
                  isCommon = false;
                  values2 = new SetCache2(values2);
                }
                outer:
                  while (++index < length) {
                    var value = array[index], computed2 = iteratee2 == null ? value : iteratee2(value);
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed2 === computed2) {
                      var valuesIndex = valuesLength;
                      while (valuesIndex--) {
                        if (values2[valuesIndex] === computed2) {
                          continue outer;
                        }
                      }
                      result2.push(value);
                    } else if (!includes2(values2, computed2, comparator)) {
                      result2.push(value);
                    }
                  }
                return result2;
              }
              var baseEach2 = createBaseEach2(baseForOwn2);
              var baseEachRight = createBaseEach2(baseForOwnRight, true);
              function baseEvery(collection, predicate) {
                var result2 = true;
                baseEach2(collection, function(value, index, collection2) {
                  result2 = !!predicate(value, index, collection2);
                  return result2;
                });
                return result2;
              }
              function baseExtremum(array, iteratee2, comparator) {
                var index = -1, length = array.length;
                while (++index < length) {
                  var value = array[index], current = iteratee2(value);
                  if (current != null && (computed2 === undefined$1 ? current === current && !isSymbol2(current) : comparator(current, computed2))) {
                    var computed2 = current, result2 = value;
                  }
                }
                return result2;
              }
              function baseFill(array, value, start, end) {
                var length = array.length;
                start = toInteger(start);
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end === undefined$1 || end > length ? length : toInteger(end);
                if (end < 0) {
                  end += length;
                }
                end = start > end ? 0 : toLength(end);
                while (start < end) {
                  array[start++] = value;
                }
                return array;
              }
              function baseFilter(collection, predicate) {
                var result2 = [];
                baseEach2(collection, function(value, index, collection2) {
                  if (predicate(value, index, collection2)) {
                    result2.push(value);
                  }
                });
                return result2;
              }
              function baseFlatten(array, depth, predicate, isStrict, result2) {
                var index = -1, length = array.length;
                predicate || (predicate = isFlattenable);
                result2 || (result2 = []);
                while (++index < length) {
                  var value = array[index];
                  if (depth > 0 && predicate(value)) {
                    if (depth > 1) {
                      baseFlatten(value, depth - 1, predicate, isStrict, result2);
                    } else {
                      arrayPush2(result2, value);
                    }
                  } else if (!isStrict) {
                    result2[result2.length] = value;
                  }
                }
                return result2;
              }
              var baseFor2 = createBaseFor2();
              var baseForRight = createBaseFor2(true);
              function baseForOwn2(object, iteratee2) {
                return object && baseFor2(object, iteratee2, keys2);
              }
              function baseForOwnRight(object, iteratee2) {
                return object && baseForRight(object, iteratee2, keys2);
              }
              function baseFunctions(object, props) {
                return arrayFilter2(props, function(key) {
                  return isFunction2(object[key]);
                });
              }
              function baseGet2(object, path) {
                path = castPath2(path, object);
                var index = 0, length = path.length;
                while (object != null && index < length) {
                  object = object[toKey2(path[index++])];
                }
                return index && index == length ? object : undefined$1;
              }
              function baseGetAllKeys2(object, keysFunc, symbolsFunc) {
                var result2 = keysFunc(object);
                return isArray2(object) ? result2 : arrayPush2(result2, symbolsFunc(object));
              }
              function baseGetTag2(value) {
                if (value == null) {
                  return value === undefined$1 ? undefinedTag2 : nullTag2;
                }
                return symToStringTag2 && symToStringTag2 in Object2(value) ? getRawTag2(value) : objectToString2(value);
              }
              function baseGt(value, other) {
                return value > other;
              }
              function baseHas(object, key) {
                return object != null && hasOwnProperty2.call(object, key);
              }
              function baseHasIn2(object, key) {
                return object != null && key in Object2(object);
              }
              function baseInRange(number, start, end) {
                return number >= nativeMin2(start, end) && number < nativeMax2(start, end);
              }
              function baseIntersection(arrays, iteratee2, comparator) {
                var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
                while (othIndex--) {
                  var array = arrays[othIndex];
                  if (othIndex && iteratee2) {
                    array = arrayMap2(array, baseUnary2(iteratee2));
                  }
                  maxLength = nativeMin2(array.length, maxLength);
                  caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache2(othIndex && array) : undefined$1;
                }
                array = arrays[0];
                var index = -1, seen = caches[0];
                outer:
                  while (++index < length && result2.length < maxLength) {
                    var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (!(seen ? cacheHas2(seen, computed2) : includes2(result2, computed2, comparator))) {
                      othIndex = othLength;
                      while (--othIndex) {
                        var cache2 = caches[othIndex];
                        if (!(cache2 ? cacheHas2(cache2, computed2) : includes2(arrays[othIndex], computed2, comparator))) {
                          continue outer;
                        }
                      }
                      if (seen) {
                        seen.push(computed2);
                      }
                      result2.push(value);
                    }
                  }
                return result2;
              }
              function baseInverter(object, setter, iteratee2, accumulator) {
                baseForOwn2(object, function(value, key, object3) {
                  setter(accumulator, iteratee2(value), key, object3);
                });
                return accumulator;
              }
              function baseInvoke(object, path, args) {
                path = castPath2(path, object);
                object = parent(object, path);
                var func = object == null ? object : object[toKey2(last(path))];
                return func == null ? undefined$1 : apply2(func, object, args);
              }
              function baseIsArguments2(value) {
                return isObjectLike2(value) && baseGetTag2(value) == argsTag2;
              }
              function baseIsArrayBuffer(value) {
                return isObjectLike2(value) && baseGetTag2(value) == arrayBufferTag2;
              }
              function baseIsDate(value) {
                return isObjectLike2(value) && baseGetTag2(value) == dateTag2;
              }
              function baseIsEqual2(value, other, bitmask, customizer, stack2) {
                if (value === other) {
                  return true;
                }
                if (value == null || other == null || !isObjectLike2(value) && !isObjectLike2(other)) {
                  return value !== value && other !== other;
                }
                return baseIsEqualDeep2(value, other, bitmask, customizer, baseIsEqual2, stack2);
              }
              function baseIsEqualDeep2(object, other, bitmask, customizer, equalFunc, stack2) {
                var objIsArr = isArray2(object), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag2 : getTag2(object), othTag = othIsArr ? arrayTag2 : getTag2(other);
                objTag = objTag == argsTag2 ? objectTag2 : objTag;
                othTag = othTag == argsTag2 ? objectTag2 : othTag;
                var objIsObj = objTag == objectTag2, othIsObj = othTag == objectTag2, isSameTag = objTag == othTag;
                if (isSameTag && isBuffer2(object)) {
                  if (!isBuffer2(other)) {
                    return false;
                  }
                  objIsArr = true;
                  objIsObj = false;
                }
                if (isSameTag && !objIsObj) {
                  stack2 || (stack2 = new Stack2());
                  return objIsArr || isTypedArray2(object) ? equalArrays2(object, other, bitmask, customizer, equalFunc, stack2) : equalByTag2(object, other, objTag, bitmask, customizer, equalFunc, stack2);
                }
                if (!(bitmask & COMPARE_PARTIAL_FLAG2)) {
                  var objIsWrapped = objIsObj && hasOwnProperty2.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
                  if (objIsWrapped || othIsWrapped) {
                    var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
                    stack2 || (stack2 = new Stack2());
                    return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack2);
                  }
                }
                if (!isSameTag) {
                  return false;
                }
                stack2 || (stack2 = new Stack2());
                return equalObjects2(object, other, bitmask, customizer, equalFunc, stack2);
              }
              function baseIsMap(value) {
                return isObjectLike2(value) && getTag2(value) == mapTag2;
              }
              function baseIsMatch2(object, source, matchData, customizer) {
                var index = matchData.length, length = index, noCustomizer = !customizer;
                if (object == null) {
                  return !length;
                }
                object = Object2(object);
                while (index--) {
                  var data = matchData[index];
                  if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                    return false;
                  }
                }
                while (++index < length) {
                  data = matchData[index];
                  var key = data[0], objValue = object[key], srcValue = data[1];
                  if (noCustomizer && data[2]) {
                    if (objValue === undefined$1 && !(key in object)) {
                      return false;
                    }
                  } else {
                    var stack2 = new Stack2();
                    if (customizer) {
                      var result2 = customizer(objValue, srcValue, key, object, source, stack2);
                    }
                    if (!(result2 === undefined$1 ? baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2, customizer, stack2) : result2)) {
                      return false;
                    }
                  }
                }
                return true;
              }
              function baseIsNative2(value) {
                if (!isObject2(value) || isMasked2(value)) {
                  return false;
                }
                var pattern = isFunction2(value) ? reIsNative2 : reIsHostCtor2;
                return pattern.test(toSource2(value));
              }
              function baseIsRegExp(value) {
                return isObjectLike2(value) && baseGetTag2(value) == regexpTag2;
              }
              function baseIsSet(value) {
                return isObjectLike2(value) && getTag2(value) == setTag2;
              }
              function baseIsTypedArray2(value) {
                return isObjectLike2(value) && isLength2(value.length) && !!typedArrayTags2[baseGetTag2(value)];
              }
              function baseIteratee2(value) {
                if (typeof value == "function") {
                  return value;
                }
                if (value == null) {
                  return identity2;
                }
                if (typeof value == "object") {
                  return isArray2(value) ? baseMatchesProperty2(value[0], value[1]) : baseMatches2(value);
                }
                return property2(value);
              }
              function baseKeys2(object) {
                if (!isPrototype2(object)) {
                  return nativeKeys2(object);
                }
                var result2 = [];
                for (var key in Object2(object)) {
                  if (hasOwnProperty2.call(object, key) && key != "constructor") {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function baseKeysIn2(object) {
                if (!isObject2(object)) {
                  return nativeKeysIn2(object);
                }
                var isProto = isPrototype2(object), result2 = [];
                for (var key in object) {
                  if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object, key)))) {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function baseLt(value, other) {
                return value < other;
              }
              function baseMap2(collection, iteratee2) {
                var index = -1, result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
                baseEach2(collection, function(value, key, collection2) {
                  result2[++index] = iteratee2(value, key, collection2);
                });
                return result2;
              }
              function baseMatches2(source) {
                var matchData = getMatchData2(source);
                if (matchData.length == 1 && matchData[0][2]) {
                  return matchesStrictComparable2(matchData[0][0], matchData[0][1]);
                }
                return function(object) {
                  return object === source || baseIsMatch2(object, source, matchData);
                };
              }
              function baseMatchesProperty2(path, srcValue) {
                if (isKey2(path) && isStrictComparable2(srcValue)) {
                  return matchesStrictComparable2(toKey2(path), srcValue);
                }
                return function(object) {
                  var objValue = get2(object, path);
                  return objValue === undefined$1 && objValue === srcValue ? hasIn2(object, path) : baseIsEqual2(srcValue, objValue, COMPARE_PARTIAL_FLAG2 | COMPARE_UNORDERED_FLAG2);
                };
              }
              function baseMerge2(object, source, srcIndex, customizer, stack2) {
                if (object === source) {
                  return;
                }
                baseFor2(source, function(srcValue, key) {
                  stack2 || (stack2 = new Stack2());
                  if (isObject2(srcValue)) {
                    baseMergeDeep2(object, source, key, srcIndex, baseMerge2, customizer, stack2);
                  } else {
                    var newValue = customizer ? customizer(safeGet2(object, key), srcValue, key + "", object, source, stack2) : undefined$1;
                    if (newValue === undefined$1) {
                      newValue = srcValue;
                    }
                    assignMergeValue2(object, key, newValue);
                  }
                }, keysIn2);
              }
              function baseMergeDeep2(object, source, key, srcIndex, mergeFunc, customizer, stack2) {
                var objValue = safeGet2(object, key), srcValue = safeGet2(source, key), stacked = stack2.get(srcValue);
                if (stacked) {
                  assignMergeValue2(object, key, stacked);
                  return;
                }
                var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack2) : undefined$1;
                var isCommon = newValue === undefined$1;
                if (isCommon) {
                  var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
                  newValue = srcValue;
                  if (isArr || isBuff || isTyped) {
                    if (isArray2(objValue)) {
                      newValue = objValue;
                    } else if (isArrayLikeObject2(objValue)) {
                      newValue = copyArray2(objValue);
                    } else if (isBuff) {
                      isCommon = false;
                      newValue = cloneBuffer2(srcValue, true);
                    } else if (isTyped) {
                      isCommon = false;
                      newValue = cloneTypedArray2(srcValue, true);
                    } else {
                      newValue = [];
                    }
                  } else if (isPlainObject2(srcValue) || isArguments2(srcValue)) {
                    newValue = objValue;
                    if (isArguments2(objValue)) {
                      newValue = toPlainObject2(objValue);
                    } else if (!isObject2(objValue) || isFunction2(objValue)) {
                      newValue = initCloneObject2(srcValue);
                    }
                  } else {
                    isCommon = false;
                  }
                }
                if (isCommon) {
                  stack2.set(srcValue, newValue);
                  mergeFunc(newValue, srcValue, srcIndex, customizer, stack2);
                  stack2["delete"](srcValue);
                }
                assignMergeValue2(object, key, newValue);
              }
              function baseNth(array, n) {
                var length = array.length;
                if (!length) {
                  return;
                }
                n += n < 0 ? length : 0;
                return isIndex2(n, length) ? array[n] : undefined$1;
              }
              function baseOrderBy(collection, iteratees, orders) {
                if (iteratees.length) {
                  iteratees = arrayMap2(iteratees, function(iteratee2) {
                    if (isArray2(iteratee2)) {
                      return function(value) {
                        return baseGet2(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                      };
                    }
                    return iteratee2;
                  });
                } else {
                  iteratees = [identity2];
                }
                var index = -1;
                iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
                var result2 = baseMap2(collection, function(value, key, collection2) {
                  var criteria = arrayMap2(iteratees, function(iteratee2) {
                    return iteratee2(value);
                  });
                  return { "criteria": criteria, "index": ++index, "value": value };
                });
                return baseSortBy(result2, function(object, other) {
                  return compareMultiple(object, other, orders);
                });
              }
              function basePick(object, paths) {
                return basePickBy(object, paths, function(value, path) {
                  return hasIn2(object, path);
                });
              }
              function basePickBy(object, paths, predicate) {
                var index = -1, length = paths.length, result2 = {};
                while (++index < length) {
                  var path = paths[index], value = baseGet2(object, path);
                  if (predicate(value, path)) {
                    baseSet(result2, castPath2(path, object), value);
                  }
                }
                return result2;
              }
              function basePropertyDeep2(path) {
                return function(object) {
                  return baseGet2(object, path);
                };
              }
              function basePullAll(array, values2, iteratee2, comparator) {
                var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
                if (array === values2) {
                  values2 = copyArray2(values2);
                }
                if (iteratee2) {
                  seen = arrayMap2(array, baseUnary2(iteratee2));
                }
                while (++index < length) {
                  var fromIndex = 0, value = values2[index], computed2 = iteratee2 ? iteratee2(value) : value;
                  while ((fromIndex = indexOf2(seen, computed2, fromIndex, comparator)) > -1) {
                    if (seen !== array) {
                      splice2.call(seen, fromIndex, 1);
                    }
                    splice2.call(array, fromIndex, 1);
                  }
                }
                return array;
              }
              function basePullAt(array, indexes) {
                var length = array ? indexes.length : 0, lastIndex = length - 1;
                while (length--) {
                  var index = indexes[length];
                  if (length == lastIndex || index !== previous) {
                    var previous = index;
                    if (isIndex2(index)) {
                      splice2.call(array, index, 1);
                    } else {
                      baseUnset(array, index);
                    }
                  }
                }
                return array;
              }
              function baseRandom(lower, upper) {
                return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
              }
              function baseRange(start, end, step, fromRight) {
                var index = -1, length = nativeMax2(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
                while (length--) {
                  result2[fromRight ? length : ++index] = start;
                  start += step;
                }
                return result2;
              }
              function baseRepeat(string2, n) {
                var result2 = "";
                if (!string2 || n < 1 || n > MAX_SAFE_INTEGER2) {
                  return result2;
                }
                do {
                  if (n % 2) {
                    result2 += string2;
                  }
                  n = nativeFloor(n / 2);
                  if (n) {
                    string2 += string2;
                  }
                } while (n);
                return result2;
              }
              function baseRest2(func, start) {
                return setToString2(overRest2(func, start, identity2), func + "");
              }
              function baseSample(collection) {
                return arraySample(values(collection));
              }
              function baseSampleSize(collection, n) {
                var array = values(collection);
                return shuffleSelf(array, baseClamp(n, 0, array.length));
              }
              function baseSet(object, path, value, customizer) {
                if (!isObject2(object)) {
                  return object;
                }
                path = castPath2(path, object);
                var index = -1, length = path.length, lastIndex = length - 1, nested = object;
                while (nested != null && ++index < length) {
                  var key = toKey2(path[index]), newValue = value;
                  if (key === "__proto__" || key === "constructor" || key === "prototype") {
                    return object;
                  }
                  if (index != lastIndex) {
                    var objValue = nested[key];
                    newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
                    if (newValue === undefined$1) {
                      newValue = isObject2(objValue) ? objValue : isIndex2(path[index + 1]) ? [] : {};
                    }
                  }
                  assignValue2(nested, key, newValue);
                  nested = nested[key];
                }
                return object;
              }
              var baseSetData = !metaMap ? identity2 : function(func, data) {
                metaMap.set(func, data);
                return func;
              };
              var baseSetToString2 = !defineProperty2 ? identity2 : function(func, string2) {
                return defineProperty2(func, "toString", {
                  "configurable": true,
                  "enumerable": false,
                  "value": constant2(string2),
                  "writable": true
                });
              };
              function baseShuffle(collection) {
                return shuffleSelf(values(collection));
              }
              function baseSlice2(array, start, end) {
                var index = -1, length = array.length;
                if (start < 0) {
                  start = -start > length ? 0 : length + start;
                }
                end = end > length ? length : end;
                if (end < 0) {
                  end += length;
                }
                length = start > end ? 0 : end - start >>> 0;
                start >>>= 0;
                var result2 = Array2(length);
                while (++index < length) {
                  result2[index] = array[index + start];
                }
                return result2;
              }
              function baseSome(collection, predicate) {
                var result2;
                baseEach2(collection, function(value, index, collection2) {
                  result2 = predicate(value, index, collection2);
                  return !result2;
                });
                return !!result2;
              }
              function baseSortedIndex(array, value, retHighest) {
                var low = 0, high = array == null ? low : array.length;
                if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                  while (low < high) {
                    var mid = low + high >>> 1, computed2 = array[mid];
                    if (computed2 !== null && !isSymbol2(computed2) && (retHighest ? computed2 <= value : computed2 < value)) {
                      low = mid + 1;
                    } else {
                      high = mid;
                    }
                  }
                  return high;
                }
                return baseSortedIndexBy(array, value, identity2, retHighest);
              }
              function baseSortedIndexBy(array, value, iteratee2, retHighest) {
                var low = 0, high = array == null ? 0 : array.length;
                if (high === 0) {
                  return 0;
                }
                value = iteratee2(value);
                var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol2(value), valIsUndefined = value === undefined$1;
                while (low < high) {
                  var mid = nativeFloor((low + high) / 2), computed2 = iteratee2(array[mid]), othIsDefined = computed2 !== undefined$1, othIsNull = computed2 === null, othIsReflexive = computed2 === computed2, othIsSymbol = isSymbol2(computed2);
                  if (valIsNaN) {
                    var setLow = retHighest || othIsReflexive;
                  } else if (valIsUndefined) {
                    setLow = othIsReflexive && (retHighest || othIsDefined);
                  } else if (valIsNull) {
                    setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
                  } else if (valIsSymbol) {
                    setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
                  } else if (othIsNull || othIsSymbol) {
                    setLow = false;
                  } else {
                    setLow = retHighest ? computed2 <= value : computed2 < value;
                  }
                  if (setLow) {
                    low = mid + 1;
                  } else {
                    high = mid;
                  }
                }
                return nativeMin2(high, MAX_ARRAY_INDEX);
              }
              function baseSortedUniq(array, iteratee2) {
                var index = -1, length = array.length, resIndex = 0, result2 = [];
                while (++index < length) {
                  var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
                  if (!index || !eq2(computed2, seen)) {
                    var seen = computed2;
                    result2[resIndex++] = value === 0 ? 0 : value;
                  }
                }
                return result2;
              }
              function baseToNumber(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol2(value)) {
                  return NAN2;
                }
                return +value;
              }
              function baseToString2(value) {
                if (typeof value == "string") {
                  return value;
                }
                if (isArray2(value)) {
                  return arrayMap2(value, baseToString2) + "";
                }
                if (isSymbol2(value)) {
                  return symbolToString2 ? symbolToString2.call(value) : "";
                }
                var result2 = value + "";
                return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
              }
              function baseUniq(array, iteratee2, comparator) {
                var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
                if (comparator) {
                  isCommon = false;
                  includes2 = arrayIncludesWith;
                } else if (length >= LARGE_ARRAY_SIZE2) {
                  var set2 = iteratee2 ? null : createSet(array);
                  if (set2) {
                    return setToArray2(set2);
                  }
                  isCommon = false;
                  includes2 = cacheHas2;
                  seen = new SetCache2();
                } else {
                  seen = iteratee2 ? [] : result2;
                }
                outer:
                  while (++index < length) {
                    var value = array[index], computed2 = iteratee2 ? iteratee2(value) : value;
                    value = comparator || value !== 0 ? value : 0;
                    if (isCommon && computed2 === computed2) {
                      var seenIndex = seen.length;
                      while (seenIndex--) {
                        if (seen[seenIndex] === computed2) {
                          continue outer;
                        }
                      }
                      if (iteratee2) {
                        seen.push(computed2);
                      }
                      result2.push(value);
                    } else if (!includes2(seen, computed2, comparator)) {
                      if (seen !== result2) {
                        seen.push(computed2);
                      }
                      result2.push(value);
                    }
                  }
                return result2;
              }
              function baseUnset(object, path) {
                path = castPath2(path, object);
                object = parent(object, path);
                return object == null || delete object[toKey2(last(path))];
              }
              function baseUpdate(object, path, updater, customizer) {
                return baseSet(object, path, updater(baseGet2(object, path)), customizer);
              }
              function baseWhile(array, predicate, isDrop, fromRight) {
                var length = array.length, index = fromRight ? length : -1;
                while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
                }
                return isDrop ? baseSlice2(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice2(array, fromRight ? index + 1 : 0, fromRight ? length : index);
              }
              function baseWrapperValue(value, actions) {
                var result2 = value;
                if (result2 instanceof LazyWrapper) {
                  result2 = result2.value();
                }
                return arrayReduce(actions, function(result3, action) {
                  return action.func.apply(action.thisArg, arrayPush2([result3], action.args));
                }, result2);
              }
              function baseXor(arrays, iteratee2, comparator) {
                var length = arrays.length;
                if (length < 2) {
                  return length ? baseUniq(arrays[0]) : [];
                }
                var index = -1, result2 = Array2(length);
                while (++index < length) {
                  var array = arrays[index], othIndex = -1;
                  while (++othIndex < length) {
                    if (othIndex != index) {
                      result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
                    }
                  }
                }
                return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
              }
              function baseZipObject(props, values2, assignFunc) {
                var index = -1, length = props.length, valsLength = values2.length, result2 = {};
                while (++index < length) {
                  var value = index < valsLength ? values2[index] : undefined$1;
                  assignFunc(result2, props[index], value);
                }
                return result2;
              }
              function castArrayLikeObject(value) {
                return isArrayLikeObject2(value) ? value : [];
              }
              function castFunction2(value) {
                return typeof value == "function" ? value : identity2;
              }
              function castPath2(value, object) {
                if (isArray2(value)) {
                  return value;
                }
                return isKey2(value, object) ? [value] : stringToPath2(toString2(value));
              }
              var castRest = baseRest2;
              function castSlice2(array, start, end) {
                var length = array.length;
                end = end === undefined$1 ? length : end;
                return !start && end >= length ? array : baseSlice2(array, start, end);
              }
              var clearTimeout2 = ctxClearTimeout || function(id) {
                return root2.clearTimeout(id);
              };
              function cloneBuffer2(buffer, isDeep) {
                if (isDeep) {
                  return buffer.slice();
                }
                var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                buffer.copy(result2);
                return result2;
              }
              function cloneArrayBuffer2(arrayBuffer) {
                var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
                new Uint8Array3(result2).set(new Uint8Array3(arrayBuffer));
                return result2;
              }
              function cloneDataView(dataView, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
                return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
              }
              function cloneRegExp(regexp) {
                var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                result2.lastIndex = regexp.lastIndex;
                return result2;
              }
              function cloneSymbol(symbol) {
                return symbolValueOf2 ? Object2(symbolValueOf2.call(symbol)) : {};
              }
              function cloneTypedArray2(typedArray, isDeep) {
                var buffer = isDeep ? cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
                return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
              }
              function compareAscending(value, other) {
                if (value !== other) {
                  var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol2(value);
                  var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol2(other);
                  if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                    return 1;
                  }
                  if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                    return -1;
                  }
                }
                return 0;
              }
              function compareMultiple(object, other, orders) {
                var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
                while (++index < length) {
                  var result2 = compareAscending(objCriteria[index], othCriteria[index]);
                  if (result2) {
                    if (index >= ordersLength) {
                      return result2;
                    }
                    var order = orders[index];
                    return result2 * (order == "desc" ? -1 : 1);
                  }
                }
                return object.index - other.index;
              }
              function composeArgs(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
                while (++leftIndex < leftLength) {
                  result2[leftIndex] = partials[leftIndex];
                }
                while (++argsIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result2[holders[argsIndex]] = args[argsIndex];
                  }
                }
                while (rangeLength--) {
                  result2[leftIndex++] = args[argsIndex++];
                }
                return result2;
              }
              function composeArgsRight(args, partials, holders, isCurried) {
                var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax2(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
                while (++argsIndex < rangeLength) {
                  result2[argsIndex] = args[argsIndex];
                }
                var offset = argsIndex;
                while (++rightIndex < rightLength) {
                  result2[offset + rightIndex] = partials[rightIndex];
                }
                while (++holdersIndex < holdersLength) {
                  if (isUncurried || argsIndex < argsLength) {
                    result2[offset + holders[holdersIndex]] = args[argsIndex++];
                  }
                }
                return result2;
              }
              function copyArray2(source, array) {
                var index = -1, length = source.length;
                array || (array = Array2(length));
                while (++index < length) {
                  array[index] = source[index];
                }
                return array;
              }
              function copyObject2(source, props, object, customizer) {
                var isNew = !object;
                object || (object = {});
                var index = -1, length = props.length;
                while (++index < length) {
                  var key = props[index];
                  var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined$1;
                  if (newValue === undefined$1) {
                    newValue = source[key];
                  }
                  if (isNew) {
                    baseAssignValue2(object, key, newValue);
                  } else {
                    assignValue2(object, key, newValue);
                  }
                }
                return object;
              }
              function copySymbols(source, object) {
                return copyObject2(source, getSymbols2(source), object);
              }
              function copySymbolsIn(source, object) {
                return copyObject2(source, getSymbolsIn(source), object);
              }
              function createAggregator(setter, initializer) {
                return function(collection, iteratee2) {
                  var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
                  return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
                };
              }
              function createAssigner2(assigner) {
                return baseRest2(function(object, sources) {
                  var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined$1, guard = length > 2 ? sources[2] : undefined$1;
                  customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined$1;
                  if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
                    customizer = length < 3 ? undefined$1 : customizer;
                    length = 1;
                  }
                  object = Object2(object);
                  while (++index < length) {
                    var source = sources[index];
                    if (source) {
                      assigner(object, source, index, customizer);
                    }
                  }
                  return object;
                });
              }
              function createBaseEach2(eachFunc, fromRight) {
                return function(collection, iteratee2) {
                  if (collection == null) {
                    return collection;
                  }
                  if (!isArrayLike2(collection)) {
                    return eachFunc(collection, iteratee2);
                  }
                  var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
                  while (fromRight ? index-- : ++index < length) {
                    if (iteratee2(iterable[index], index, iterable) === false) {
                      break;
                    }
                  }
                  return collection;
                };
              }
              function createBaseFor2(fromRight) {
                return function(object, iteratee2, keysFunc) {
                  var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
                  while (length--) {
                    var key = props[fromRight ? length : ++index];
                    if (iteratee2(iterable[key], key, iterable) === false) {
                      break;
                    }
                  }
                  return object;
                };
              }
              function createBind(func, bitmask, thisArg) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
                  return fn.apply(isBind ? thisArg : this, arguments);
                }
                return wrapper;
              }
              function createCaseFirst2(methodName) {
                return function(string2) {
                  string2 = toString2(string2);
                  var strSymbols = hasUnicode2(string2) ? stringToArray2(string2) : undefined$1;
                  var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
                  var trailing = strSymbols ? castSlice2(strSymbols, 1).join("") : string2.slice(1);
                  return chr[methodName]() + trailing;
                };
              }
              function createCompounder(callback) {
                return function(string2) {
                  return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
                };
              }
              function createCtor(Ctor) {
                return function() {
                  var args = arguments;
                  switch (args.length) {
                    case 0:
                      return new Ctor();
                    case 1:
                      return new Ctor(args[0]);
                    case 2:
                      return new Ctor(args[0], args[1]);
                    case 3:
                      return new Ctor(args[0], args[1], args[2]);
                    case 4:
                      return new Ctor(args[0], args[1], args[2], args[3]);
                    case 5:
                      return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                    case 6:
                      return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                    case 7:
                      return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
                  }
                  var thisBinding = baseCreate2(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
                  return isObject2(result2) ? result2 : thisBinding;
                };
              }
              function createCurry(func, bitmask, arity) {
                var Ctor = createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
                  while (index--) {
                    args[index] = arguments[index];
                  }
                  var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                  length -= holders.length;
                  if (length < arity) {
                    return createRecurry(
                      func,
                      bitmask,
                      createHybrid,
                      wrapper.placeholder,
                      undefined$1,
                      args,
                      holders,
                      undefined$1,
                      undefined$1,
                      arity - length
                    );
                  }
                  var fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
                  return apply2(fn, this, args);
                }
                return wrapper;
              }
              function createFind(findIndexFunc) {
                return function(collection, predicate, fromIndex) {
                  var iterable = Object2(collection);
                  if (!isArrayLike2(collection)) {
                    var iteratee2 = getIteratee(predicate, 3);
                    collection = keys2(collection);
                    predicate = function(key) {
                      return iteratee2(iterable[key], key, iterable);
                    };
                  }
                  var index = findIndexFunc(collection, predicate, fromIndex);
                  return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined$1;
                };
              }
              function createFlow(fromRight) {
                return flatRest(function(funcs) {
                  var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
                  if (fromRight) {
                    funcs.reverse();
                  }
                  while (index--) {
                    var func = funcs[index];
                    if (typeof func != "function") {
                      throw new TypeError2(FUNC_ERROR_TEXT2);
                    }
                    if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                      var wrapper = new LodashWrapper([], true);
                    }
                  }
                  index = wrapper ? index : length;
                  while (++index < length) {
                    func = funcs[index];
                    var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
                    if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                      wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                    } else {
                      wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                    }
                  }
                  return function() {
                    var args = arguments, value = args[0];
                    if (wrapper && args.length == 1 && isArray2(value)) {
                      return wrapper.plant(value).value();
                    }
                    var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
                    while (++index2 < length) {
                      result2 = funcs[index2].call(this, result2);
                    }
                    return result2;
                  };
                });
              }
              function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
                var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
                function wrapper() {
                  var length = arguments.length, args = Array2(length), index = length;
                  while (index--) {
                    args[index] = arguments[index];
                  }
                  if (isCurried) {
                    var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
                  }
                  if (partials) {
                    args = composeArgs(args, partials, holders, isCurried);
                  }
                  if (partialsRight) {
                    args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
                  }
                  length -= holdersCount;
                  if (isCurried && length < arity) {
                    var newHolders = replaceHolders(args, placeholder);
                    return createRecurry(
                      func,
                      bitmask,
                      createHybrid,
                      wrapper.placeholder,
                      thisArg,
                      args,
                      newHolders,
                      argPos,
                      ary2,
                      arity - length
                    );
                  }
                  var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
                  length = args.length;
                  if (argPos) {
                    args = reorder(args, argPos);
                  } else if (isFlip && length > 1) {
                    args.reverse();
                  }
                  if (isAry && ary2 < length) {
                    args.length = ary2;
                  }
                  if (this && this !== root2 && this instanceof wrapper) {
                    fn = Ctor || createCtor(fn);
                  }
                  return fn.apply(thisBinding, args);
                }
                return wrapper;
              }
              function createInverter(setter, toIteratee) {
                return function(object, iteratee2) {
                  return baseInverter(object, setter, toIteratee(iteratee2), {});
                };
              }
              function createMathOperation(operator, defaultValue) {
                return function(value, other) {
                  var result2;
                  if (value === undefined$1 && other === undefined$1) {
                    return defaultValue;
                  }
                  if (value !== undefined$1) {
                    result2 = value;
                  }
                  if (other !== undefined$1) {
                    if (result2 === undefined$1) {
                      return other;
                    }
                    if (typeof value == "string" || typeof other == "string") {
                      value = baseToString2(value);
                      other = baseToString2(other);
                    } else {
                      value = baseToNumber(value);
                      other = baseToNumber(other);
                    }
                    result2 = operator(value, other);
                  }
                  return result2;
                };
              }
              function createOver(arrayFunc) {
                return flatRest(function(iteratees) {
                  iteratees = arrayMap2(iteratees, baseUnary2(getIteratee()));
                  return baseRest2(function(args) {
                    var thisArg = this;
                    return arrayFunc(iteratees, function(iteratee2) {
                      return apply2(iteratee2, thisArg, args);
                    });
                  });
                });
              }
              function createPadding(length, chars) {
                chars = chars === undefined$1 ? " " : baseToString2(chars);
                var charsLength = chars.length;
                if (charsLength < 2) {
                  return charsLength ? baseRepeat(chars, length) : chars;
                }
                var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                return hasUnicode2(chars) ? castSlice2(stringToArray2(result2), 0, length).join("") : result2.slice(0, length);
              }
              function createPartial(func, bitmask, thisArg, partials) {
                var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
                function wrapper() {
                  var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root2 && this instanceof wrapper ? Ctor : func;
                  while (++leftIndex < leftLength) {
                    args[leftIndex] = partials[leftIndex];
                  }
                  while (argsLength--) {
                    args[leftIndex++] = arguments[++argsIndex];
                  }
                  return apply2(fn, isBind ? thisArg : this, args);
                }
                return wrapper;
              }
              function createRange2(fromRight) {
                return function(start, end, step) {
                  if (step && typeof step != "number" && isIterateeCall2(start, end, step)) {
                    end = step = undefined$1;
                  }
                  start = toFinite(start);
                  if (end === undefined$1) {
                    end = start;
                    start = 0;
                  } else {
                    end = toFinite(end);
                  }
                  step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
                  return baseRange(start, end, step, fromRight);
                };
              }
              function createRelationalOperation(operator) {
                return function(value, other) {
                  if (!(typeof value == "string" && typeof other == "string")) {
                    value = toNumber2(value);
                    other = toNumber2(other);
                  }
                  return operator(value, other);
                };
              }
              function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
                var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
                bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
                bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
                if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
                  bitmask &= -4;
                }
                var newData = [
                  func,
                  bitmask,
                  thisArg,
                  newPartials,
                  newHolders,
                  newPartialsRight,
                  newHoldersRight,
                  argPos,
                  ary2,
                  arity
                ];
                var result2 = wrapFunc.apply(undefined$1, newData);
                if (isLaziable(func)) {
                  setData(result2, newData);
                }
                result2.placeholder = placeholder;
                return setWrapToString(result2, func, bitmask);
              }
              function createRound(methodName) {
                var func = Math2[methodName];
                return function(number, precision) {
                  number = toNumber2(number);
                  precision = precision == null ? 0 : nativeMin2(toInteger(precision), 292);
                  if (precision && nativeIsFinite(number)) {
                    var pair = (toString2(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
                    pair = (toString2(value) + "e").split("e");
                    return +(pair[0] + "e" + (+pair[1] - precision));
                  }
                  return func(number);
                };
              }
              var createSet = !(Set2 && 1 / setToArray2(new Set2([, -0]))[1] == INFINITY) ? noop2 : function(values2) {
                return new Set2(values2);
              };
              function createToPairs(keysFunc) {
                return function(object) {
                  var tag = getTag2(object);
                  if (tag == mapTag2) {
                    return mapToArray2(object);
                  }
                  if (tag == setTag2) {
                    return setToPairs(object);
                  }
                  return baseToPairs(object, keysFunc(object));
                };
              }
              function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
                var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                if (!isBindKey && typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                var length = partials ? partials.length : 0;
                if (!length) {
                  bitmask &= -97;
                  partials = holders = undefined$1;
                }
                ary2 = ary2 === undefined$1 ? ary2 : nativeMax2(toInteger(ary2), 0);
                arity = arity === undefined$1 ? arity : toInteger(arity);
                length -= holders ? holders.length : 0;
                if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                  var partialsRight = partials, holdersRight = holders;
                  partials = holders = undefined$1;
                }
                var data = isBindKey ? undefined$1 : getData(func);
                var newData = [
                  func,
                  bitmask,
                  thisArg,
                  partials,
                  holders,
                  partialsRight,
                  holdersRight,
                  argPos,
                  ary2,
                  arity
                ];
                if (data) {
                  mergeData(newData, data);
                }
                func = newData[0];
                bitmask = newData[1];
                thisArg = newData[2];
                partials = newData[3];
                holders = newData[4];
                arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax2(newData[9] - length, 0);
                if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
                  bitmask &= -25;
                }
                if (!bitmask || bitmask == WRAP_BIND_FLAG) {
                  var result2 = createBind(func, bitmask, thisArg);
                } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
                  result2 = createCurry(func, bitmask, arity);
                } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
                  result2 = createPartial(func, bitmask, thisArg, partials);
                } else {
                  result2 = createHybrid.apply(undefined$1, newData);
                }
                var setter = data ? baseSetData : setData;
                return setWrapToString(setter(result2, newData), func, bitmask);
              }
              function customDefaultsAssignIn(objValue, srcValue, key, object) {
                if (objValue === undefined$1 || eq2(objValue, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
                  return srcValue;
                }
                return objValue;
              }
              function customDefaultsMerge(objValue, srcValue, key, object, source, stack2) {
                if (isObject2(objValue) && isObject2(srcValue)) {
                  stack2.set(srcValue, objValue);
                  baseMerge2(objValue, srcValue, undefined$1, customDefaultsMerge, stack2);
                  stack2["delete"](srcValue);
                }
                return objValue;
              }
              function customOmitClone(value) {
                return isPlainObject2(value) ? undefined$1 : value;
              }
              function equalArrays2(array, other, bitmask, customizer, equalFunc, stack2) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, arrLength = array.length, othLength = other.length;
                if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
                  return false;
                }
                var arrStacked = stack2.get(array);
                var othStacked = stack2.get(other);
                if (arrStacked && othStacked) {
                  return arrStacked == other && othStacked == array;
                }
                var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG2 ? new SetCache2() : undefined$1;
                stack2.set(array, other);
                stack2.set(other, array);
                while (++index < arrLength) {
                  var arrValue = array[index], othValue = other[index];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack2) : customizer(arrValue, othValue, index, array, other, stack2);
                  }
                  if (compared !== undefined$1) {
                    if (compared) {
                      continue;
                    }
                    result2 = false;
                    break;
                  }
                  if (seen) {
                    if (!arraySome2(other, function(othValue2, othIndex) {
                      if (!cacheHas2(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack2))) {
                        return seen.push(othIndex);
                      }
                    })) {
                      result2 = false;
                      break;
                    }
                  } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack2))) {
                    result2 = false;
                    break;
                  }
                }
                stack2["delete"](array);
                stack2["delete"](other);
                return result2;
              }
              function equalByTag2(object, other, tag, bitmask, customizer, equalFunc, stack2) {
                switch (tag) {
                  case dataViewTag2:
                    if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                      return false;
                    }
                    object = object.buffer;
                    other = other.buffer;
                  case arrayBufferTag2:
                    if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array3(object), new Uint8Array3(other))) {
                      return false;
                    }
                    return true;
                  case boolTag2:
                  case dateTag2:
                  case numberTag2:
                    return eq2(+object, +other);
                  case errorTag2:
                    return object.name == other.name && object.message == other.message;
                  case regexpTag2:
                  case stringTag2:
                    return object == other + "";
                  case mapTag2:
                    var convert = mapToArray2;
                  case setTag2:
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG2;
                    convert || (convert = setToArray2);
                    if (object.size != other.size && !isPartial) {
                      return false;
                    }
                    var stacked = stack2.get(object);
                    if (stacked) {
                      return stacked == other;
                    }
                    bitmask |= COMPARE_UNORDERED_FLAG2;
                    stack2.set(object, other);
                    var result2 = equalArrays2(convert(object), convert(other), bitmask, customizer, equalFunc, stack2);
                    stack2["delete"](object);
                    return result2;
                  case symbolTag2:
                    if (symbolValueOf2) {
                      return symbolValueOf2.call(object) == symbolValueOf2.call(other);
                    }
                }
                return false;
              }
              function equalObjects2(object, other, bitmask, customizer, equalFunc, stack2) {
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, objProps = getAllKeys2(object), objLength = objProps.length, othProps = getAllKeys2(other), othLength = othProps.length;
                if (objLength != othLength && !isPartial) {
                  return false;
                }
                var index = objLength;
                while (index--) {
                  var key = objProps[index];
                  if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
                    return false;
                  }
                }
                var objStacked = stack2.get(object);
                var othStacked = stack2.get(other);
                if (objStacked && othStacked) {
                  return objStacked == other && othStacked == object;
                }
                var result2 = true;
                stack2.set(object, other);
                stack2.set(other, object);
                var skipCtor = isPartial;
                while (++index < objLength) {
                  key = objProps[index];
                  var objValue = object[key], othValue = other[key];
                  if (customizer) {
                    var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack2) : customizer(objValue, othValue, key, object, other, stack2);
                  }
                  if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack2) : compared)) {
                    result2 = false;
                    break;
                  }
                  skipCtor || (skipCtor = key == "constructor");
                }
                if (result2 && !skipCtor) {
                  var objCtor = object.constructor, othCtor = other.constructor;
                  if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
                    result2 = false;
                  }
                }
                stack2["delete"](object);
                stack2["delete"](other);
                return result2;
              }
              function flatRest(func) {
                return setToString2(overRest2(func, undefined$1, flatten2), func + "");
              }
              function getAllKeys2(object) {
                return baseGetAllKeys2(object, keys2, getSymbols2);
              }
              function getAllKeysIn(object) {
                return baseGetAllKeys2(object, keysIn2, getSymbolsIn);
              }
              var getData = !metaMap ? noop2 : function(func) {
                return metaMap.get(func);
              };
              function getFuncName(func) {
                var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty2.call(realNames, result2) ? array.length : 0;
                while (length--) {
                  var data = array[length], otherFunc = data.func;
                  if (otherFunc == null || otherFunc == func) {
                    return data.name;
                  }
                }
                return result2;
              }
              function getHolder(func) {
                var object = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
                return object.placeholder;
              }
              function getIteratee() {
                var result2 = lodash2.iteratee || iteratee;
                result2 = result2 === iteratee ? baseIteratee2 : result2;
                return arguments.length ? result2(arguments[0], arguments[1]) : result2;
              }
              function getMapData2(map3, key) {
                var data = map3.__data__;
                return isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
              }
              function getMatchData2(object) {
                var result2 = keys2(object), length = result2.length;
                while (length--) {
                  var key = result2[length], value = object[key];
                  result2[length] = [key, value, isStrictComparable2(value)];
                }
                return result2;
              }
              function getNative2(object, key) {
                var value = getValue2(object, key);
                return baseIsNative2(value) ? value : undefined$1;
              }
              function getRawTag2(value) {
                var isOwn = hasOwnProperty2.call(value, symToStringTag2), tag = value[symToStringTag2];
                try {
                  value[symToStringTag2] = undefined$1;
                  var unmasked = true;
                } catch (e) {
                }
                var result2 = nativeObjectToString2.call(value);
                if (unmasked) {
                  if (isOwn) {
                    value[symToStringTag2] = tag;
                  } else {
                    delete value[symToStringTag2];
                  }
                }
                return result2;
              }
              var getSymbols2 = !nativeGetSymbols2 ? stubArray2 : function(object) {
                if (object == null) {
                  return [];
                }
                object = Object2(object);
                return arrayFilter2(nativeGetSymbols2(object), function(symbol) {
                  return propertyIsEnumerable2.call(object, symbol);
                });
              };
              var getSymbolsIn = !nativeGetSymbols2 ? stubArray2 : function(object) {
                var result2 = [];
                while (object) {
                  arrayPush2(result2, getSymbols2(object));
                  object = getPrototype2(object);
                }
                return result2;
              };
              var getTag2 = baseGetTag2;
              if (DataView2 && getTag2(new DataView2(new ArrayBuffer(1))) != dataViewTag2 || Map2 && getTag2(new Map2()) != mapTag2 || Promise2 && getTag2(Promise2.resolve()) != promiseTag2 || Set2 && getTag2(new Set2()) != setTag2 || WeakMap2 && getTag2(new WeakMap2()) != weakMapTag2) {
                getTag2 = function(value) {
                  var result2 = baseGetTag2(value), Ctor = result2 == objectTag2 ? value.constructor : undefined$1, ctorString = Ctor ? toSource2(Ctor) : "";
                  if (ctorString) {
                    switch (ctorString) {
                      case dataViewCtorString2:
                        return dataViewTag2;
                      case mapCtorString2:
                        return mapTag2;
                      case promiseCtorString2:
                        return promiseTag2;
                      case setCtorString2:
                        return setTag2;
                      case weakMapCtorString2:
                        return weakMapTag2;
                    }
                  }
                  return result2;
                };
              }
              function getView(start, end, transforms) {
                var index = -1, length = transforms.length;
                while (++index < length) {
                  var data = transforms[index], size3 = data.size;
                  switch (data.type) {
                    case "drop":
                      start += size3;
                      break;
                    case "dropRight":
                      end -= size3;
                      break;
                    case "take":
                      end = nativeMin2(end, start + size3);
                      break;
                    case "takeRight":
                      start = nativeMax2(start, end - size3);
                      break;
                  }
                }
                return { "start": start, "end": end };
              }
              function getWrapDetails(source) {
                var match2 = source.match(reWrapDetails);
                return match2 ? match2[1].split(reSplitDetails) : [];
              }
              function hasPath2(object, path, hasFunc) {
                path = castPath2(path, object);
                var index = -1, length = path.length, result2 = false;
                while (++index < length) {
                  var key = toKey2(path[index]);
                  if (!(result2 = object != null && hasFunc(object, key))) {
                    break;
                  }
                  object = object[key];
                }
                if (result2 || ++index != length) {
                  return result2;
                }
                length = object == null ? 0 : object.length;
                return !!length && isLength2(length) && isIndex2(key, length) && (isArray2(object) || isArguments2(object));
              }
              function initCloneArray(array) {
                var length = array.length, result2 = new array.constructor(length);
                if (length && typeof array[0] == "string" && hasOwnProperty2.call(array, "index")) {
                  result2.index = array.index;
                  result2.input = array.input;
                }
                return result2;
              }
              function initCloneObject2(object) {
                return typeof object.constructor == "function" && !isPrototype2(object) ? baseCreate2(getPrototype2(object)) : {};
              }
              function initCloneByTag(object, tag, isDeep) {
                var Ctor = object.constructor;
                switch (tag) {
                  case arrayBufferTag2:
                    return cloneArrayBuffer2(object);
                  case boolTag2:
                  case dateTag2:
                    return new Ctor(+object);
                  case dataViewTag2:
                    return cloneDataView(object, isDeep);
                  case float32Tag2:
                  case float64Tag2:
                  case int8Tag2:
                  case int16Tag2:
                  case int32Tag2:
                  case uint8Tag2:
                  case uint8ClampedTag2:
                  case uint16Tag2:
                  case uint32Tag2:
                    return cloneTypedArray2(object, isDeep);
                  case mapTag2:
                    return new Ctor();
                  case numberTag2:
                  case stringTag2:
                    return new Ctor(object);
                  case regexpTag2:
                    return cloneRegExp(object);
                  case setTag2:
                    return new Ctor();
                  case symbolTag2:
                    return cloneSymbol(object);
                }
              }
              function insertWrapDetails(source, details) {
                var length = details.length;
                if (!length) {
                  return source;
                }
                var lastIndex = length - 1;
                details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
                details = details.join(length > 2 ? ", " : " ");
                return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
              }
              function isFlattenable(value) {
                return isArray2(value) || isArguments2(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
              }
              function isIndex2(value, length) {
                var type = typeof value;
                length = length == null ? MAX_SAFE_INTEGER2 : length;
                return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
              }
              function isIterateeCall2(value, index, object) {
                if (!isObject2(object)) {
                  return false;
                }
                var type = typeof index;
                if (type == "number" ? isArrayLike2(object) && isIndex2(index, object.length) : type == "string" && index in object) {
                  return eq2(object[index], value);
                }
                return false;
              }
              function isKey2(value, object) {
                if (isArray2(value)) {
                  return false;
                }
                var type = typeof value;
                if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol2(value)) {
                  return true;
                }
                return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object != null && value in Object2(object);
              }
              function isKeyable2(value) {
                var type = typeof value;
                return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
              }
              function isLaziable(func) {
                var funcName = getFuncName(func), other = lodash2[funcName];
                if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
                  return false;
                }
                if (func === other) {
                  return true;
                }
                var data = getData(other);
                return !!data && func === data[0];
              }
              function isMasked2(func) {
                return !!maskSrcKey2 && maskSrcKey2 in func;
              }
              var isMaskable = coreJsData2 ? isFunction2 : stubFalse2;
              function isPrototype2(value) {
                var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto2;
                return value === proto;
              }
              function isStrictComparable2(value) {
                return value === value && !isObject2(value);
              }
              function matchesStrictComparable2(key, srcValue) {
                return function(object) {
                  if (object == null) {
                    return false;
                  }
                  return object[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object));
                };
              }
              function memoizeCapped2(func) {
                var result2 = memoize2(func, function(key) {
                  if (cache2.size === MAX_MEMOIZE_SIZE2) {
                    cache2.clear();
                  }
                  return key;
                });
                var cache2 = result2.cache;
                return result2;
              }
              function mergeData(data, source) {
                var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
                var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                if (!(isCommon || isCombo)) {
                  return data;
                }
                if (srcBitmask & WRAP_BIND_FLAG) {
                  data[2] = source[2];
                  newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
                }
                var value = source[3];
                if (value) {
                  var partials = data[3];
                  data[3] = partials ? composeArgs(partials, value, source[4]) : value;
                  data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
                }
                value = source[5];
                if (value) {
                  partials = data[5];
                  data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
                  data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
                }
                value = source[7];
                if (value) {
                  data[7] = value;
                }
                if (srcBitmask & WRAP_ARY_FLAG) {
                  data[8] = data[8] == null ? source[8] : nativeMin2(data[8], source[8]);
                }
                if (data[9] == null) {
                  data[9] = source[9];
                }
                data[0] = source[0];
                data[1] = newBitmask;
                return data;
              }
              function nativeKeysIn2(object) {
                var result2 = [];
                if (object != null) {
                  for (var key in Object2(object)) {
                    result2.push(key);
                  }
                }
                return result2;
              }
              function objectToString2(value) {
                return nativeObjectToString2.call(value);
              }
              function overRest2(func, start, transform2) {
                start = nativeMax2(start === undefined$1 ? func.length - 1 : start, 0);
                return function() {
                  var args = arguments, index = -1, length = nativeMax2(args.length - start, 0), array = Array2(length);
                  while (++index < length) {
                    array[index] = args[start + index];
                  }
                  index = -1;
                  var otherArgs = Array2(start + 1);
                  while (++index < start) {
                    otherArgs[index] = args[index];
                  }
                  otherArgs[start] = transform2(array);
                  return apply2(func, this, otherArgs);
                };
              }
              function parent(object, path) {
                return path.length < 2 ? object : baseGet2(object, baseSlice2(path, 0, -1));
              }
              function reorder(array, indexes) {
                var arrLength = array.length, length = nativeMin2(indexes.length, arrLength), oldArray = copyArray2(array);
                while (length--) {
                  var index = indexes[length];
                  array[length] = isIndex2(index, arrLength) ? oldArray[index] : undefined$1;
                }
                return array;
              }
              function safeGet2(object, key) {
                if (key === "constructor" && typeof object[key] === "function") {
                  return;
                }
                if (key == "__proto__") {
                  return;
                }
                return object[key];
              }
              var setData = shortOut2(baseSetData);
              var setTimeout2 = ctxSetTimeout || function(func, wait) {
                return root2.setTimeout(func, wait);
              };
              var setToString2 = shortOut2(baseSetToString2);
              function setWrapToString(wrapper, reference, bitmask) {
                var source = reference + "";
                return setToString2(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
              }
              function shortOut2(func) {
                var count = 0, lastCalled = 0;
                return function() {
                  var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
                  lastCalled = stamp;
                  if (remaining > 0) {
                    if (++count >= HOT_COUNT2) {
                      return arguments[0];
                    }
                  } else {
                    count = 0;
                  }
                  return func.apply(undefined$1, arguments);
                };
              }
              function shuffleSelf(array, size3) {
                var index = -1, length = array.length, lastIndex = length - 1;
                size3 = size3 === undefined$1 ? length : size3;
                while (++index < size3) {
                  var rand = baseRandom(index, lastIndex), value = array[rand];
                  array[rand] = array[index];
                  array[index] = value;
                }
                array.length = size3;
                return array;
              }
              var stringToPath2 = memoizeCapped2(function(string2) {
                var result2 = [];
                if (string2.charCodeAt(0) === 46) {
                  result2.push("");
                }
                string2.replace(rePropName2, function(match2, number, quote, subString) {
                  result2.push(quote ? subString.replace(reEscapeChar2, "$1") : number || match2);
                });
                return result2;
              });
              function toKey2(value) {
                if (typeof value == "string" || isSymbol2(value)) {
                  return value;
                }
                var result2 = value + "";
                return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
              }
              function toSource2(func) {
                if (func != null) {
                  try {
                    return funcToString2.call(func);
                  } catch (e) {
                  }
                  try {
                    return func + "";
                  } catch (e) {
                  }
                }
                return "";
              }
              function updateWrapDetails(details, bitmask) {
                arrayEach2(wrapFlags, function(pair) {
                  var value = "_." + pair[0];
                  if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                    details.push(value);
                  }
                });
                return details.sort();
              }
              function wrapperClone(wrapper) {
                if (wrapper instanceof LazyWrapper) {
                  return wrapper.clone();
                }
                var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                result2.__actions__ = copyArray2(wrapper.__actions__);
                result2.__index__ = wrapper.__index__;
                result2.__values__ = wrapper.__values__;
                return result2;
              }
              function chunk(array, size3, guard) {
                if (guard ? isIterateeCall2(array, size3, guard) : size3 === undefined$1) {
                  size3 = 1;
                } else {
                  size3 = nativeMax2(toInteger(size3), 0);
                }
                var length = array == null ? 0 : array.length;
                if (!length || size3 < 1) {
                  return [];
                }
                var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size3));
                while (index < length) {
                  result2[resIndex++] = baseSlice2(array, index, index += size3);
                }
                return result2;
              }
              function compact(array) {
                var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
                while (++index < length) {
                  var value = array[index];
                  if (value) {
                    result2[resIndex++] = value;
                  }
                }
                return result2;
              }
              function concat() {
                var length = arguments.length;
                if (!length) {
                  return [];
                }
                var args = Array2(length - 1), array = arguments[0], index = length;
                while (index--) {
                  args[index - 1] = arguments[index];
                }
                return arrayPush2(isArray2(array) ? copyArray2(array) : [array], baseFlatten(args, 1));
              }
              var difference = baseRest2(function(array, values2) {
                return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject2, true)) : [];
              });
              var differenceBy = baseRest2(function(array, values2) {
                var iteratee2 = last(values2);
                if (isArrayLikeObject2(iteratee2)) {
                  iteratee2 = undefined$1;
                }
                return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2)) : [];
              });
              var differenceWith = baseRest2(function(array, values2) {
                var comparator = last(values2);
                if (isArrayLikeObject2(comparator)) {
                  comparator = undefined$1;
                }
                return isArrayLikeObject2(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject2, true), undefined$1, comparator) : [];
              });
              function drop(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                return baseSlice2(array, n < 0 ? 0 : n, length);
              }
              function dropRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                n = length - n;
                return baseSlice2(array, 0, n < 0 ? 0 : n);
              }
              function dropRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
              }
              function dropWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
              }
              function fill(array, value, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (start && typeof start != "number" && isIterateeCall2(array, value, start)) {
                  start = 0;
                  end = length;
                }
                return baseFill(array, value, start, end);
              }
              function findIndex2(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax2(length + index, 0);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index);
              }
              function findLastIndex(array, predicate, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = length - 1;
                if (fromIndex !== undefined$1) {
                  index = toInteger(fromIndex);
                  index = fromIndex < 0 ? nativeMax2(length + index, 0) : nativeMin2(index, length - 1);
                }
                return baseFindIndex(array, getIteratee(predicate, 3), index, true);
              }
              function flatten2(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, 1) : [];
              }
              function flattenDeep(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseFlatten(array, INFINITY) : [];
              }
              function flattenDepth(array, depth) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                depth = depth === undefined$1 ? 1 : toInteger(depth);
                return baseFlatten(array, depth);
              }
              function fromPairs(pairs) {
                var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
                while (++index < length) {
                  var pair = pairs[index];
                  result2[pair[0]] = pair[1];
                }
                return result2;
              }
              function head(array) {
                return array && array.length ? array[0] : undefined$1;
              }
              function indexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = fromIndex == null ? 0 : toInteger(fromIndex);
                if (index < 0) {
                  index = nativeMax2(length + index, 0);
                }
                return baseIndexOf(array, value, index);
              }
              function initial(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice2(array, 0, -1) : [];
              }
              var intersection = baseRest2(function(arrays) {
                var mapped = arrayMap2(arrays, castArrayLikeObject);
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
              });
              var intersectionBy = baseRest2(function(arrays) {
                var iteratee2 = last(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
                if (iteratee2 === last(mapped)) {
                  iteratee2 = undefined$1;
                } else {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
              });
              var intersectionWith = baseRest2(function(arrays) {
                var comparator = last(arrays), mapped = arrayMap2(arrays, castArrayLikeObject);
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                if (comparator) {
                  mapped.pop();
                }
                return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
              });
              function join(array, separator) {
                return array == null ? "" : nativeJoin.call(array, separator);
              }
              function last(array) {
                var length = array == null ? 0 : array.length;
                return length ? array[length - 1] : undefined$1;
              }
              function lastIndexOf(array, value, fromIndex) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return -1;
                }
                var index = length;
                if (fromIndex !== undefined$1) {
                  index = toInteger(fromIndex);
                  index = index < 0 ? nativeMax2(length + index, 0) : nativeMin2(index, length - 1);
                }
                return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
              }
              function nth(array, n) {
                return array && array.length ? baseNth(array, toInteger(n)) : undefined$1;
              }
              var pull = baseRest2(pullAll);
              function pullAll(array, values2) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
              }
              function pullAllBy(array, values2, iteratee2) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
              }
              function pullAllWith(array, values2, comparator) {
                return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined$1, comparator) : array;
              }
              var pullAt = flatRest(function(array, indexes) {
                var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
                basePullAt(array, arrayMap2(indexes, function(index) {
                  return isIndex2(index, length) ? +index : index;
                }).sort(compareAscending));
                return result2;
              });
              function remove(array, predicate) {
                var result2 = [];
                if (!(array && array.length)) {
                  return result2;
                }
                var index = -1, indexes = [], length = array.length;
                predicate = getIteratee(predicate, 3);
                while (++index < length) {
                  var value = array[index];
                  if (predicate(value, index, array)) {
                    result2.push(value);
                    indexes.push(index);
                  }
                }
                basePullAt(array, indexes);
                return result2;
              }
              function reverse(array) {
                return array == null ? array : nativeReverse.call(array);
              }
              function slice(array, start, end) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                if (end && typeof end != "number" && isIterateeCall2(array, start, end)) {
                  start = 0;
                  end = length;
                } else {
                  start = start == null ? 0 : toInteger(start);
                  end = end === undefined$1 ? length : toInteger(end);
                }
                return baseSlice2(array, start, end);
              }
              function sortedIndex(array, value) {
                return baseSortedIndex(array, value);
              }
              function sortedIndexBy(array, value, iteratee2) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
              }
              function sortedIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index = baseSortedIndex(array, value);
                  if (index < length && eq2(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              function sortedLastIndex(array, value) {
                return baseSortedIndex(array, value, true);
              }
              function sortedLastIndexBy(array, value, iteratee2) {
                return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
              }
              function sortedLastIndexOf(array, value) {
                var length = array == null ? 0 : array.length;
                if (length) {
                  var index = baseSortedIndex(array, value, true) - 1;
                  if (eq2(array[index], value)) {
                    return index;
                  }
                }
                return -1;
              }
              function sortedUniq(array) {
                return array && array.length ? baseSortedUniq(array) : [];
              }
              function sortedUniqBy(array, iteratee2) {
                return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
              }
              function tail(array) {
                var length = array == null ? 0 : array.length;
                return length ? baseSlice2(array, 1, length) : [];
              }
              function take(array, n, guard) {
                if (!(array && array.length)) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                return baseSlice2(array, 0, n < 0 ? 0 : n);
              }
              function takeRight(array, n, guard) {
                var length = array == null ? 0 : array.length;
                if (!length) {
                  return [];
                }
                n = guard || n === undefined$1 ? 1 : toInteger(n);
                n = length - n;
                return baseSlice2(array, n < 0 ? 0 : n, length);
              }
              function takeRightWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
              }
              function takeWhile(array, predicate) {
                return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
              }
              var union = baseRest2(function(arrays) {
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true));
              });
              var unionBy = baseRest2(function(arrays) {
                var iteratee2 = last(arrays);
                if (isArrayLikeObject2(iteratee2)) {
                  iteratee2 = undefined$1;
                }
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true), getIteratee(iteratee2, 2));
              });
              var unionWith = baseRest2(function(arrays) {
                var comparator = last(arrays);
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject2, true), undefined$1, comparator);
              });
              function uniq(array) {
                return array && array.length ? baseUniq(array) : [];
              }
              function uniqBy(array, iteratee2) {
                return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
              }
              function uniqWith(array, comparator) {
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                return array && array.length ? baseUniq(array, undefined$1, comparator) : [];
              }
              function unzip(array) {
                if (!(array && array.length)) {
                  return [];
                }
                var length = 0;
                array = arrayFilter2(array, function(group) {
                  if (isArrayLikeObject2(group)) {
                    length = nativeMax2(group.length, length);
                    return true;
                  }
                });
                return baseTimes2(length, function(index) {
                  return arrayMap2(array, baseProperty2(index));
                });
              }
              function unzipWith(array, iteratee2) {
                if (!(array && array.length)) {
                  return [];
                }
                var result2 = unzip(array);
                if (iteratee2 == null) {
                  return result2;
                }
                return arrayMap2(result2, function(group) {
                  return apply2(iteratee2, undefined$1, group);
                });
              }
              var without = baseRest2(function(array, values2) {
                return isArrayLikeObject2(array) ? baseDifference(array, values2) : [];
              });
              var xor = baseRest2(function(arrays) {
                return baseXor(arrayFilter2(arrays, isArrayLikeObject2));
              });
              var xorBy = baseRest2(function(arrays) {
                var iteratee2 = last(arrays);
                if (isArrayLikeObject2(iteratee2)) {
                  iteratee2 = undefined$1;
                }
                return baseXor(arrayFilter2(arrays, isArrayLikeObject2), getIteratee(iteratee2, 2));
              });
              var xorWith = baseRest2(function(arrays) {
                var comparator = last(arrays);
                comparator = typeof comparator == "function" ? comparator : undefined$1;
                return baseXor(arrayFilter2(arrays, isArrayLikeObject2), undefined$1, comparator);
              });
              var zip = baseRest2(unzip);
              function zipObject(props, values2) {
                return baseZipObject(props || [], values2 || [], assignValue2);
              }
              function zipObjectDeep(props, values2) {
                return baseZipObject(props || [], values2 || [], baseSet);
              }
              var zipWith = baseRest2(function(arrays) {
                var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined$1;
                iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
                return unzipWith(arrays, iteratee2);
              });
              function chain(value) {
                var result2 = lodash2(value);
                result2.__chain__ = true;
                return result2;
              }
              function tap(value, interceptor) {
                interceptor(value);
                return value;
              }
              function thru(value, interceptor) {
                return interceptor(value);
              }
              var wrapperAt = flatRest(function(paths) {
                var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
                  return baseAt(object, paths);
                };
                if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex2(start)) {
                  return this.thru(interceptor);
                }
                value = value.slice(start, +start + (length ? 1 : 0));
                value.__actions__.push({
                  "func": thru,
                  "args": [interceptor],
                  "thisArg": undefined$1
                });
                return new LodashWrapper(value, this.__chain__).thru(function(array) {
                  if (length && !array.length) {
                    array.push(undefined$1);
                  }
                  return array;
                });
              });
              function wrapperChain() {
                return chain(this);
              }
              function wrapperCommit() {
                return new LodashWrapper(this.value(), this.__chain__);
              }
              function wrapperNext() {
                if (this.__values__ === undefined$1) {
                  this.__values__ = toArray2(this.value());
                }
                var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
                return { "done": done, "value": value };
              }
              function wrapperToIterator() {
                return this;
              }
              function wrapperPlant(value) {
                var result2, parent2 = this;
                while (parent2 instanceof baseLodash) {
                  var clone2 = wrapperClone(parent2);
                  clone2.__index__ = 0;
                  clone2.__values__ = undefined$1;
                  if (result2) {
                    previous.__wrapped__ = clone2;
                  } else {
                    result2 = clone2;
                  }
                  var previous = clone2;
                  parent2 = parent2.__wrapped__;
                }
                previous.__wrapped__ = value;
                return result2;
              }
              function wrapperReverse() {
                var value = this.__wrapped__;
                if (value instanceof LazyWrapper) {
                  var wrapped = value;
                  if (this.__actions__.length) {
                    wrapped = new LazyWrapper(this);
                  }
                  wrapped = wrapped.reverse();
                  wrapped.__actions__.push({
                    "func": thru,
                    "args": [reverse],
                    "thisArg": undefined$1
                  });
                  return new LodashWrapper(wrapped, this.__chain__);
                }
                return this.thru(reverse);
              }
              function wrapperValue() {
                return baseWrapperValue(this.__wrapped__, this.__actions__);
              }
              var countBy = createAggregator(function(result2, value, key) {
                if (hasOwnProperty2.call(result2, key)) {
                  ++result2[key];
                } else {
                  baseAssignValue2(result2, key, 1);
                }
              });
              function every(collection, predicate, guard) {
                var func = isArray2(collection) ? arrayEvery : baseEvery;
                if (guard && isIterateeCall2(collection, predicate, guard)) {
                  predicate = undefined$1;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              function filter(collection, predicate) {
                var func = isArray2(collection) ? arrayFilter2 : baseFilter;
                return func(collection, getIteratee(predicate, 3));
              }
              var find2 = createFind(findIndex2);
              var findLast = createFind(findLastIndex);
              function flatMap(collection, iteratee2) {
                return baseFlatten(map2(collection, iteratee2), 1);
              }
              function flatMapDeep(collection, iteratee2) {
                return baseFlatten(map2(collection, iteratee2), INFINITY);
              }
              function flatMapDepth(collection, iteratee2, depth) {
                depth = depth === undefined$1 ? 1 : toInteger(depth);
                return baseFlatten(map2(collection, iteratee2), depth);
              }
              function forEach2(collection, iteratee2) {
                var func = isArray2(collection) ? arrayEach2 : baseEach2;
                return func(collection, getIteratee(iteratee2, 3));
              }
              function forEachRight(collection, iteratee2) {
                var func = isArray2(collection) ? arrayEachRight : baseEachRight;
                return func(collection, getIteratee(iteratee2, 3));
              }
              var groupBy = createAggregator(function(result2, value, key) {
                if (hasOwnProperty2.call(result2, key)) {
                  result2[key].push(value);
                } else {
                  baseAssignValue2(result2, key, [value]);
                }
              });
              function includes(collection, value, fromIndex, guard) {
                collection = isArrayLike2(collection) ? collection : values(collection);
                fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                var length = collection.length;
                if (fromIndex < 0) {
                  fromIndex = nativeMax2(length + fromIndex, 0);
                }
                return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
              }
              var invokeMap = baseRest2(function(collection, path, args) {
                var index = -1, isFunc = typeof path == "function", result2 = isArrayLike2(collection) ? Array2(collection.length) : [];
                baseEach2(collection, function(value) {
                  result2[++index] = isFunc ? apply2(path, value, args) : baseInvoke(value, path, args);
                });
                return result2;
              });
              var keyBy = createAggregator(function(result2, value, key) {
                baseAssignValue2(result2, key, value);
              });
              function map2(collection, iteratee2) {
                var func = isArray2(collection) ? arrayMap2 : baseMap2;
                return func(collection, getIteratee(iteratee2, 3));
              }
              function orderBy(collection, iteratees, orders, guard) {
                if (collection == null) {
                  return [];
                }
                if (!isArray2(iteratees)) {
                  iteratees = iteratees == null ? [] : [iteratees];
                }
                orders = guard ? undefined$1 : orders;
                if (!isArray2(orders)) {
                  orders = orders == null ? [] : [orders];
                }
                return baseOrderBy(collection, iteratees, orders);
              }
              var partition = createAggregator(function(result2, value, key) {
                result2[key ? 0 : 1].push(value);
              }, function() {
                return [[], []];
              });
              function reduce(collection, iteratee2, accumulator) {
                var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach2);
              }
              function reduceRight(collection, iteratee2, accumulator) {
                var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
                return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
              }
              function reject(collection, predicate) {
                var func = isArray2(collection) ? arrayFilter2 : baseFilter;
                return func(collection, negate(getIteratee(predicate, 3)));
              }
              function sample(collection) {
                var func = isArray2(collection) ? arraySample : baseSample;
                return func(collection);
              }
              function sampleSize(collection, n, guard) {
                if (guard ? isIterateeCall2(collection, n, guard) : n === undefined$1) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
                return func(collection, n);
              }
              function shuffle(collection) {
                var func = isArray2(collection) ? arrayShuffle : baseShuffle;
                return func(collection);
              }
              function size2(collection) {
                if (collection == null) {
                  return 0;
                }
                if (isArrayLike2(collection)) {
                  return isString(collection) ? stringSize(collection) : collection.length;
                }
                var tag = getTag2(collection);
                if (tag == mapTag2 || tag == setTag2) {
                  return collection.size;
                }
                return baseKeys2(collection).length;
              }
              function some(collection, predicate, guard) {
                var func = isArray2(collection) ? arraySome2 : baseSome;
                if (guard && isIterateeCall2(collection, predicate, guard)) {
                  predicate = undefined$1;
                }
                return func(collection, getIteratee(predicate, 3));
              }
              var sortBy = baseRest2(function(collection, iteratees) {
                if (collection == null) {
                  return [];
                }
                var length = iteratees.length;
                if (length > 1 && isIterateeCall2(collection, iteratees[0], iteratees[1])) {
                  iteratees = [];
                } else if (length > 2 && isIterateeCall2(iteratees[0], iteratees[1], iteratees[2])) {
                  iteratees = [iteratees[0]];
                }
                return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
              });
              var now2 = ctxNow || function() {
                return root2.Date.now();
              };
              function after(n, func) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                n = toInteger(n);
                return function() {
                  if (--n < 1) {
                    return func.apply(this, arguments);
                  }
                };
              }
              function ary(func, n, guard) {
                n = guard ? undefined$1 : n;
                n = func && n == null ? func.length : n;
                return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
              }
              function before(n, func) {
                var result2;
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                n = toInteger(n);
                return function() {
                  if (--n > 0) {
                    result2 = func.apply(this, arguments);
                  }
                  if (n <= 1) {
                    func = undefined$1;
                  }
                  return result2;
                };
              }
              var bind = baseRest2(function(func, thisArg, partials) {
                var bitmask = WRAP_BIND_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bind));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(func, bitmask, thisArg, partials, holders);
              });
              var bindKey = baseRest2(function(object, key, partials) {
                var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                if (partials.length) {
                  var holders = replaceHolders(partials, getHolder(bindKey));
                  bitmask |= WRAP_PARTIAL_FLAG;
                }
                return createWrap(key, bitmask, object, partials, holders);
              });
              function curry(func, arity, guard) {
                arity = guard ? undefined$1 : arity;
                var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                result2.placeholder = curry.placeholder;
                return result2;
              }
              function curryRight(func, arity, guard) {
                arity = guard ? undefined$1 : arity;
                var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
                result2.placeholder = curryRight.placeholder;
                return result2;
              }
              function debounce2(func, wait, options) {
                var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                wait = toNumber2(wait) || 0;
                if (isObject2(options)) {
                  leading = !!options.leading;
                  maxing = "maxWait" in options;
                  maxWait = maxing ? nativeMax2(toNumber2(options.maxWait) || 0, wait) : maxWait;
                  trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                function invokeFunc(time2) {
                  var args = lastArgs, thisArg = lastThis;
                  lastArgs = lastThis = undefined$1;
                  lastInvokeTime = time2;
                  result2 = func.apply(thisArg, args);
                  return result2;
                }
                function leadingEdge(time2) {
                  lastInvokeTime = time2;
                  timerId = setTimeout2(timerExpired, wait);
                  return leading ? invokeFunc(time2) : result2;
                }
                function remainingWait(time2) {
                  var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
                  return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
                }
                function shouldInvoke(time2) {
                  var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
                  return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
                }
                function timerExpired() {
                  var time2 = now2();
                  if (shouldInvoke(time2)) {
                    return trailingEdge(time2);
                  }
                  timerId = setTimeout2(timerExpired, remainingWait(time2));
                }
                function trailingEdge(time2) {
                  timerId = undefined$1;
                  if (trailing && lastArgs) {
                    return invokeFunc(time2);
                  }
                  lastArgs = lastThis = undefined$1;
                  return result2;
                }
                function cancel() {
                  if (timerId !== undefined$1) {
                    clearTimeout2(timerId);
                  }
                  lastInvokeTime = 0;
                  lastArgs = lastCallTime = lastThis = timerId = undefined$1;
                }
                function flush() {
                  return timerId === undefined$1 ? result2 : trailingEdge(now2());
                }
                function debounced() {
                  var time2 = now2(), isInvoking = shouldInvoke(time2);
                  lastArgs = arguments;
                  lastThis = this;
                  lastCallTime = time2;
                  if (isInvoking) {
                    if (timerId === undefined$1) {
                      return leadingEdge(lastCallTime);
                    }
                    if (maxing) {
                      clearTimeout2(timerId);
                      timerId = setTimeout2(timerExpired, wait);
                      return invokeFunc(lastCallTime);
                    }
                  }
                  if (timerId === undefined$1) {
                    timerId = setTimeout2(timerExpired, wait);
                  }
                  return result2;
                }
                debounced.cancel = cancel;
                debounced.flush = flush;
                return debounced;
              }
              var defer = baseRest2(function(func, args) {
                return baseDelay(func, 1, args);
              });
              var delay = baseRest2(function(func, wait, args) {
                return baseDelay(func, toNumber2(wait) || 0, args);
              });
              function flip(func) {
                return createWrap(func, WRAP_FLIP_FLAG);
              }
              function memoize2(func, resolver) {
                if (typeof func != "function" || resolver != null && typeof resolver != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                var memoized = function() {
                  var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache2 = memoized.cache;
                  if (cache2.has(key)) {
                    return cache2.get(key);
                  }
                  var result2 = func.apply(this, args);
                  memoized.cache = cache2.set(key, result2) || cache2;
                  return result2;
                };
                memoized.cache = new (memoize2.Cache || MapCache2)();
                return memoized;
              }
              memoize2.Cache = MapCache2;
              function negate(predicate) {
                if (typeof predicate != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                return function() {
                  var args = arguments;
                  switch (args.length) {
                    case 0:
                      return !predicate.call(this);
                    case 1:
                      return !predicate.call(this, args[0]);
                    case 2:
                      return !predicate.call(this, args[0], args[1]);
                    case 3:
                      return !predicate.call(this, args[0], args[1], args[2]);
                  }
                  return !predicate.apply(this, args);
                };
              }
              function once(func) {
                return before(2, func);
              }
              var overArgs = castRest(function(func, transforms) {
                transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap2(transforms[0], baseUnary2(getIteratee())) : arrayMap2(baseFlatten(transforms, 1), baseUnary2(getIteratee()));
                var funcsLength = transforms.length;
                return baseRest2(function(args) {
                  var index = -1, length = nativeMin2(args.length, funcsLength);
                  while (++index < length) {
                    args[index] = transforms[index].call(this, args[index]);
                  }
                  return apply2(func, this, args);
                });
              });
              var partial = baseRest2(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partial));
                return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
              });
              var partialRight = baseRest2(function(func, partials) {
                var holders = replaceHolders(partials, getHolder(partialRight));
                return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
              });
              var rearg = flatRest(function(func, indexes) {
                return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
              });
              function rest(func, start) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                start = start === undefined$1 ? start : toInteger(start);
                return baseRest2(func, start);
              }
              function spread(func, start) {
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                start = start == null ? 0 : nativeMax2(toInteger(start), 0);
                return baseRest2(function(args) {
                  var array = args[start], otherArgs = castSlice2(args, 0, start);
                  if (array) {
                    arrayPush2(otherArgs, array);
                  }
                  return apply2(func, this, otherArgs);
                });
              }
              function throttle2(func, wait, options) {
                var leading = true, trailing = true;
                if (typeof func != "function") {
                  throw new TypeError2(FUNC_ERROR_TEXT2);
                }
                if (isObject2(options)) {
                  leading = "leading" in options ? !!options.leading : leading;
                  trailing = "trailing" in options ? !!options.trailing : trailing;
                }
                return debounce2(func, wait, {
                  "leading": leading,
                  "maxWait": wait,
                  "trailing": trailing
                });
              }
              function unary(func) {
                return ary(func, 1);
              }
              function wrap(value, wrapper) {
                return partial(castFunction2(wrapper), value);
              }
              function castArray() {
                if (!arguments.length) {
                  return [];
                }
                var value = arguments[0];
                return isArray2(value) ? value : [value];
              }
              function clone(value) {
                return baseClone(value, CLONE_SYMBOLS_FLAG);
              }
              function cloneWith(value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
              }
              function cloneDeep(value) {
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
              }
              function cloneDeepWith(value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
              }
              function conformsTo(object, source) {
                return source == null || baseConformsTo(object, source, keys2(source));
              }
              function eq2(value, other) {
                return value === other || value !== value && other !== other;
              }
              var gt = createRelationalOperation(baseGt);
              var gte = createRelationalOperation(function(value, other) {
                return value >= other;
              });
              var isArguments2 = baseIsArguments2( (function() {
                return arguments;
              })()) ? baseIsArguments2 : function(value) {
                return isObjectLike2(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable2.call(value, "callee");
              };
              var isArray2 = Array2.isArray;
              var isArrayBuffer = nodeIsArrayBuffer ? baseUnary2(nodeIsArrayBuffer) : baseIsArrayBuffer;
              function isArrayLike2(value) {
                return value != null && isLength2(value.length) && !isFunction2(value);
              }
              function isArrayLikeObject2(value) {
                return isObjectLike2(value) && isArrayLike2(value);
              }
              function isBoolean(value) {
                return value === true || value === false || isObjectLike2(value) && baseGetTag2(value) == boolTag2;
              }
              var isBuffer2 = nativeIsBuffer2 || stubFalse2;
              var isDate = nodeIsDate ? baseUnary2(nodeIsDate) : baseIsDate;
              function isElement2(value) {
                return isObjectLike2(value) && value.nodeType === 1 && !isPlainObject2(value);
              }
              function isEmpty(value) {
                if (value == null) {
                  return true;
                }
                if (isArrayLike2(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments2(value))) {
                  return !value.length;
                }
                var tag = getTag2(value);
                if (tag == mapTag2 || tag == setTag2) {
                  return !value.size;
                }
                if (isPrototype2(value)) {
                  return !baseKeys2(value).length;
                }
                for (var key in value) {
                  if (hasOwnProperty2.call(value, key)) {
                    return false;
                  }
                }
                return true;
              }
              function isEqual(value, other) {
                return baseIsEqual2(value, other);
              }
              function isEqualWith(value, other, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                var result2 = customizer ? customizer(value, other) : undefined$1;
                return result2 === undefined$1 ? baseIsEqual2(value, other, undefined$1, customizer) : !!result2;
              }
              function isError(value) {
                if (!isObjectLike2(value)) {
                  return false;
                }
                var tag = baseGetTag2(value);
                return tag == errorTag2 || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
              }
              function isFinite(value) {
                return typeof value == "number" && nativeIsFinite(value);
              }
              function isFunction2(value) {
                if (!isObject2(value)) {
                  return false;
                }
                var tag = baseGetTag2(value);
                return tag == funcTag2 || tag == genTag2 || tag == asyncTag2 || tag == proxyTag2;
              }
              function isInteger(value) {
                return typeof value == "number" && value == toInteger(value);
              }
              function isLength2(value) {
                return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER2;
              }
              function isObject2(value) {
                var type = typeof value;
                return value != null && (type == "object" || type == "function");
              }
              function isObjectLike2(value) {
                return value != null && typeof value == "object";
              }
              var isMap = nodeIsMap ? baseUnary2(nodeIsMap) : baseIsMap;
              function isMatch(object, source) {
                return object === source || baseIsMatch2(object, source, getMatchData2(source));
              }
              function isMatchWith(object, source, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return baseIsMatch2(object, source, getMatchData2(source), customizer);
              }
              function isNaN2(value) {
                return isNumber(value) && value != +value;
              }
              function isNative(value) {
                if (isMaskable(value)) {
                  throw new Error2(CORE_ERROR_TEXT);
                }
                return baseIsNative2(value);
              }
              function isNull(value) {
                return value === null;
              }
              function isNil(value) {
                return value == null;
              }
              function isNumber(value) {
                return typeof value == "number" || isObjectLike2(value) && baseGetTag2(value) == numberTag2;
              }
              function isPlainObject2(value) {
                if (!isObjectLike2(value) || baseGetTag2(value) != objectTag2) {
                  return false;
                }
                var proto = getPrototype2(value);
                if (proto === null) {
                  return true;
                }
                var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
                return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString2;
              }
              var isRegExp = nodeIsRegExp ? baseUnary2(nodeIsRegExp) : baseIsRegExp;
              function isSafeInteger(value) {
                return isInteger(value) && value >= -MAX_SAFE_INTEGER2 && value <= MAX_SAFE_INTEGER2;
              }
              var isSet = nodeIsSet ? baseUnary2(nodeIsSet) : baseIsSet;
              function isString(value) {
                return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && baseGetTag2(value) == stringTag2;
              }
              function isSymbol2(value) {
                return typeof value == "symbol" || isObjectLike2(value) && baseGetTag2(value) == symbolTag2;
              }
              var isTypedArray2 = nodeIsTypedArray2 ? baseUnary2(nodeIsTypedArray2) : baseIsTypedArray2;
              function isUndefined(value) {
                return value === undefined$1;
              }
              function isWeakMap(value) {
                return isObjectLike2(value) && getTag2(value) == weakMapTag2;
              }
              function isWeakSet(value) {
                return isObjectLike2(value) && baseGetTag2(value) == weakSetTag;
              }
              var lt = createRelationalOperation(baseLt);
              var lte = createRelationalOperation(function(value, other) {
                return value <= other;
              });
              function toArray2(value) {
                if (!value) {
                  return [];
                }
                if (isArrayLike2(value)) {
                  return isString(value) ? stringToArray2(value) : copyArray2(value);
                }
                if (symIterator && value[symIterator]) {
                  return iteratorToArray(value[symIterator]());
                }
                var tag = getTag2(value), func = tag == mapTag2 ? mapToArray2 : tag == setTag2 ? setToArray2 : values;
                return func(value);
              }
              function toFinite(value) {
                if (!value) {
                  return value === 0 ? value : 0;
                }
                value = toNumber2(value);
                if (value === INFINITY || value === -INFINITY) {
                  var sign = value < 0 ? -1 : 1;
                  return sign * MAX_INTEGER;
                }
                return value === value ? value : 0;
              }
              function toInteger(value) {
                var result2 = toFinite(value), remainder = result2 % 1;
                return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
              }
              function toLength(value) {
                return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
              }
              function toNumber2(value) {
                if (typeof value == "number") {
                  return value;
                }
                if (isSymbol2(value)) {
                  return NAN2;
                }
                if (isObject2(value)) {
                  var other = typeof value.valueOf == "function" ? value.valueOf() : value;
                  value = isObject2(other) ? other + "" : other;
                }
                if (typeof value != "string") {
                  return value === 0 ? value : +value;
                }
                value = baseTrim2(value);
                var isBinary = reIsBinary2.test(value);
                return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
              }
              function toPlainObject2(value) {
                return copyObject2(value, keysIn2(value));
              }
              function toSafeInteger(value) {
                return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER2, MAX_SAFE_INTEGER2) : value === 0 ? value : 0;
              }
              function toString2(value) {
                return value == null ? "" : baseToString2(value);
              }
              var assign2 = createAssigner2(function(object, source) {
                if (isPrototype2(source) || isArrayLike2(source)) {
                  copyObject2(source, keys2(source), object);
                  return;
                }
                for (var key in source) {
                  if (hasOwnProperty2.call(source, key)) {
                    assignValue2(object, key, source[key]);
                  }
                }
              });
              var assignIn = createAssigner2(function(object, source) {
                copyObject2(source, keysIn2(source), object);
              });
              var assignInWith = createAssigner2(function(object, source, srcIndex, customizer) {
                copyObject2(source, keysIn2(source), object, customizer);
              });
              var assignWith = createAssigner2(function(object, source, srcIndex, customizer) {
                copyObject2(source, keys2(source), object, customizer);
              });
              var at = flatRest(baseAt);
              function create(prototype, properties) {
                var result2 = baseCreate2(prototype);
                return properties == null ? result2 : baseAssign(result2, properties);
              }
              var defaults = baseRest2(function(object, sources) {
                object = Object2(object);
                var index = -1;
                var length = sources.length;
                var guard = length > 2 ? sources[2] : undefined$1;
                if (guard && isIterateeCall2(sources[0], sources[1], guard)) {
                  length = 1;
                }
                while (++index < length) {
                  var source = sources[index];
                  var props = keysIn2(source);
                  var propsIndex = -1;
                  var propsLength = props.length;
                  while (++propsIndex < propsLength) {
                    var key = props[propsIndex];
                    var value = object[key];
                    if (value === undefined$1 || eq2(value, objectProto2[key]) && !hasOwnProperty2.call(object, key)) {
                      object[key] = source[key];
                    }
                  }
                }
                return object;
              });
              var defaultsDeep = baseRest2(function(args) {
                args.push(undefined$1, customDefaultsMerge);
                return apply2(mergeWith, undefined$1, args);
              });
              function findKey2(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwn2);
              }
              function findLastKey(object, predicate) {
                return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
              }
              function forIn(object, iteratee2) {
                return object == null ? object : baseFor2(object, getIteratee(iteratee2, 3), keysIn2);
              }
              function forInRight(object, iteratee2) {
                return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn2);
              }
              function forOwn(object, iteratee2) {
                return object && baseForOwn2(object, getIteratee(iteratee2, 3));
              }
              function forOwnRight(object, iteratee2) {
                return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
              }
              function functions(object) {
                return object == null ? [] : baseFunctions(object, keys2(object));
              }
              function functionsIn(object) {
                return object == null ? [] : baseFunctions(object, keysIn2(object));
              }
              function get2(object, path, defaultValue) {
                var result2 = object == null ? undefined$1 : baseGet2(object, path);
                return result2 === undefined$1 ? defaultValue : result2;
              }
              function has(object, path) {
                return object != null && hasPath2(object, path, baseHas);
              }
              function hasIn2(object, path) {
                return object != null && hasPath2(object, path, baseHasIn2);
              }
              var invert = createInverter(function(result2, value, key) {
                if (value != null && typeof value.toString != "function") {
                  value = nativeObjectToString2.call(value);
                }
                result2[value] = key;
              }, constant2(identity2));
              var invertBy = createInverter(function(result2, value, key) {
                if (value != null && typeof value.toString != "function") {
                  value = nativeObjectToString2.call(value);
                }
                if (hasOwnProperty2.call(result2, value)) {
                  result2[value].push(key);
                } else {
                  result2[value] = [key];
                }
              }, getIteratee);
              var invoke = baseRest2(baseInvoke);
              function keys2(object) {
                return isArrayLike2(object) ? arrayLikeKeys2(object) : baseKeys2(object);
              }
              function keysIn2(object) {
                return isArrayLike2(object) ? arrayLikeKeys2(object, true) : baseKeysIn2(object);
              }
              function mapKeys(object, iteratee2) {
                var result2 = {};
                iteratee2 = getIteratee(iteratee2, 3);
                baseForOwn2(object, function(value, key, object3) {
                  baseAssignValue2(result2, iteratee2(value, key, object3), value);
                });
                return result2;
              }
              function mapValues(object, iteratee2) {
                var result2 = {};
                iteratee2 = getIteratee(iteratee2, 3);
                baseForOwn2(object, function(value, key, object3) {
                  baseAssignValue2(result2, key, iteratee2(value, key, object3));
                });
                return result2;
              }
              var merge2 = createAssigner2(function(object, source, srcIndex) {
                baseMerge2(object, source, srcIndex);
              });
              var mergeWith = createAssigner2(function(object, source, srcIndex, customizer) {
                baseMerge2(object, source, srcIndex, customizer);
              });
              var omit2 = flatRest(function(object, paths) {
                var result2 = {};
                if (object == null) {
                  return result2;
                }
                var isDeep = false;
                paths = arrayMap2(paths, function(path) {
                  path = castPath2(path, object);
                  isDeep || (isDeep = path.length > 1);
                  return path;
                });
                copyObject2(object, getAllKeysIn(object), result2);
                if (isDeep) {
                  result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
                }
                var length = paths.length;
                while (length--) {
                  baseUnset(result2, paths[length]);
                }
                return result2;
              });
              function omitBy(object, predicate) {
                return pickBy(object, negate(getIteratee(predicate)));
              }
              var pick = flatRest(function(object, paths) {
                return object == null ? {} : basePick(object, paths);
              });
              function pickBy(object, predicate) {
                if (object == null) {
                  return {};
                }
                var props = arrayMap2(getAllKeysIn(object), function(prop) {
                  return [prop];
                });
                predicate = getIteratee(predicate);
                return basePickBy(object, props, function(value, path) {
                  return predicate(value, path[0]);
                });
              }
              function result(object, path, defaultValue) {
                path = castPath2(path, object);
                var index = -1, length = path.length;
                if (!length) {
                  length = 1;
                  object = undefined$1;
                }
                while (++index < length) {
                  var value = object == null ? undefined$1 : object[toKey2(path[index])];
                  if (value === undefined$1) {
                    index = length;
                    value = defaultValue;
                  }
                  object = isFunction2(value) ? value.call(object) : value;
                }
                return object;
              }
              function set(object, path, value) {
                return object == null ? object : baseSet(object, path, value);
              }
              function setWith(object, path, value, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return object == null ? object : baseSet(object, path, value, customizer);
              }
              var toPairs = createToPairs(keys2);
              var toPairsIn = createToPairs(keysIn2);
              function transform(object, iteratee2, accumulator) {
                var isArr = isArray2(object), isArrLike = isArr || isBuffer2(object) || isTypedArray2(object);
                iteratee2 = getIteratee(iteratee2, 4);
                if (accumulator == null) {
                  var Ctor = object && object.constructor;
                  if (isArrLike) {
                    accumulator = isArr ? new Ctor() : [];
                  } else if (isObject2(object)) {
                    accumulator = isFunction2(Ctor) ? baseCreate2(getPrototype2(object)) : {};
                  } else {
                    accumulator = {};
                  }
                }
                (isArrLike ? arrayEach2 : baseForOwn2)(object, function(value, index, object3) {
                  return iteratee2(accumulator, value, index, object3);
                });
                return accumulator;
              }
              function unset(object, path) {
                return object == null ? true : baseUnset(object, path);
              }
              function update(object, path, updater) {
                return object == null ? object : baseUpdate(object, path, castFunction2(updater));
              }
              function updateWith(object, path, updater, customizer) {
                customizer = typeof customizer == "function" ? customizer : undefined$1;
                return object == null ? object : baseUpdate(object, path, castFunction2(updater), customizer);
              }
              function values(object) {
                return object == null ? [] : baseValues(object, keys2(object));
              }
              function valuesIn(object) {
                return object == null ? [] : baseValues(object, keysIn2(object));
              }
              function clamp(number, lower, upper) {
                if (upper === undefined$1) {
                  upper = lower;
                  lower = undefined$1;
                }
                if (upper !== undefined$1) {
                  upper = toNumber2(upper);
                  upper = upper === upper ? upper : 0;
                }
                if (lower !== undefined$1) {
                  lower = toNumber2(lower);
                  lower = lower === lower ? lower : 0;
                }
                return baseClamp(toNumber2(number), lower, upper);
              }
              function inRange(number, start, end) {
                start = toFinite(start);
                if (end === undefined$1) {
                  end = start;
                  start = 0;
                } else {
                  end = toFinite(end);
                }
                number = toNumber2(number);
                return baseInRange(number, start, end);
              }
              function random(lower, upper, floating) {
                if (floating && typeof floating != "boolean" && isIterateeCall2(lower, upper, floating)) {
                  upper = floating = undefined$1;
                }
                if (floating === undefined$1) {
                  if (typeof upper == "boolean") {
                    floating = upper;
                    upper = undefined$1;
                  } else if (typeof lower == "boolean") {
                    floating = lower;
                    lower = undefined$1;
                  }
                }
                if (lower === undefined$1 && upper === undefined$1) {
                  lower = 0;
                  upper = 1;
                } else {
                  lower = toFinite(lower);
                  if (upper === undefined$1) {
                    upper = lower;
                    lower = 0;
                  } else {
                    upper = toFinite(upper);
                  }
                }
                if (lower > upper) {
                  var temp = lower;
                  lower = upper;
                  upper = temp;
                }
                if (floating || lower % 1 || upper % 1) {
                  var rand = nativeRandom();
                  return nativeMin2(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
                }
                return baseRandom(lower, upper);
              }
              var camelCase = createCompounder(function(result2, word, index) {
                word = word.toLowerCase();
                return result2 + (index ? capitalize(word) : word);
              });
              function capitalize(string2) {
                return upperFirst2(toString2(string2).toLowerCase());
              }
              function deburr(string2) {
                string2 = toString2(string2);
                return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
              }
              function endsWith(string2, target, position) {
                string2 = toString2(string2);
                target = baseToString2(target);
                var length = string2.length;
                position = position === undefined$1 ? length : baseClamp(toInteger(position), 0, length);
                var end = position;
                position -= target.length;
                return position >= 0 && string2.slice(position, end) == target;
              }
              function escape(string2) {
                string2 = toString2(string2);
                return string2 && reHasUnescapedHtml.test(string2) ? string2.replace(reUnescapedHtml, escapeHtmlChar) : string2;
              }
              function escapeRegExp(string2) {
                string2 = toString2(string2);
                return string2 && reHasRegExpChar.test(string2) ? string2.replace(reRegExpChar2, "\\$&") : string2;
              }
              var kebabCase2 = createCompounder(function(result2, word, index) {
                return result2 + (index ? "-" : "") + word.toLowerCase();
              });
              var lowerCase = createCompounder(function(result2, word, index) {
                return result2 + (index ? " " : "") + word.toLowerCase();
              });
              var lowerFirst = createCaseFirst2("toLowerCase");
              function pad(string2, length, chars) {
                string2 = toString2(string2);
                length = toInteger(length);
                var strLength = length ? stringSize(string2) : 0;
                if (!length || strLength >= length) {
                  return string2;
                }
                var mid = (length - strLength) / 2;
                return createPadding(nativeFloor(mid), chars) + string2 + createPadding(nativeCeil(mid), chars);
              }
              function padEnd(string2, length, chars) {
                string2 = toString2(string2);
                length = toInteger(length);
                var strLength = length ? stringSize(string2) : 0;
                return length && strLength < length ? string2 + createPadding(length - strLength, chars) : string2;
              }
              function padStart(string2, length, chars) {
                string2 = toString2(string2);
                length = toInteger(length);
                var strLength = length ? stringSize(string2) : 0;
                return length && strLength < length ? createPadding(length - strLength, chars) + string2 : string2;
              }
              function parseInt2(string2, radix, guard) {
                if (guard || radix == null) {
                  radix = 0;
                } else if (radix) {
                  radix = +radix;
                }
                return nativeParseInt(toString2(string2).replace(reTrimStart2, ""), radix || 0);
              }
              function repeat2(string2, n, guard) {
                if (guard ? isIterateeCall2(string2, n, guard) : n === undefined$1) {
                  n = 1;
                } else {
                  n = toInteger(n);
                }
                return baseRepeat(toString2(string2), n);
              }
              function replace() {
                var args = arguments, string2 = toString2(args[0]);
                return args.length < 3 ? string2 : string2.replace(args[1], args[2]);
              }
              var snakeCase = createCompounder(function(result2, word, index) {
                return result2 + (index ? "_" : "") + word.toLowerCase();
              });
              function split(string2, separator, limit) {
                if (limit && typeof limit != "number" && isIterateeCall2(string2, separator, limit)) {
                  separator = limit = undefined$1;
                }
                limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
                if (!limit) {
                  return [];
                }
                string2 = toString2(string2);
                if (string2 && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
                  separator = baseToString2(separator);
                  if (!separator && hasUnicode2(string2)) {
                    return castSlice2(stringToArray2(string2), 0, limit);
                  }
                }
                return string2.split(separator, limit);
              }
              var startCase = createCompounder(function(result2, word, index) {
                return result2 + (index ? " " : "") + upperFirst2(word);
              });
              function startsWith(string2, target, position) {
                string2 = toString2(string2);
                position = position == null ? 0 : baseClamp(toInteger(position), 0, string2.length);
                target = baseToString2(target);
                return string2.slice(position, position + target.length) == target;
              }
              function template(string2, options, guard) {
                var settings = lodash2.templateSettings;
                if (guard && isIterateeCall2(string2, options, guard)) {
                  options = undefined$1;
                }
                string2 = toString2(string2);
                options = assignInWith({}, options, settings, customDefaultsAssignIn);
                var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
                var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
                var reDelimiters = RegExp2(
                  (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
                  "g"
                );
                var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                string2.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                  interpolateValue || (interpolateValue = esTemplateValue);
                  source += string2.slice(index, offset).replace(reUnescapedString, escapeStringChar);
                  if (escapeValue) {
                    isEscaping = true;
                    source += "' +\n__e(" + escapeValue + ") +\n'";
                  }
                  if (evaluateValue) {
                    isEvaluating = true;
                    source += "';\n" + evaluateValue + ";\n__p += '";
                  }
                  if (interpolateValue) {
                    source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                  }
                  index = offset + match2.length;
                  return match2;
                });
                source += "';\n";
                var variable = hasOwnProperty2.call(options, "variable") && options.variable;
                if (!variable) {
                  source = "with (obj) {\n" + source + "\n}\n";
                } else if (reForbiddenIdentifierChars.test(variable)) {
                  throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
                }
                source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
                source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                var result2 = attempt(function() {
                  return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
                });
                result2.source = source;
                if (isError(result2)) {
                  throw result2;
                }
                return result2;
              }
              function toLower(value) {
                return toString2(value).toLowerCase();
              }
              function toUpper(value) {
                return toString2(value).toUpperCase();
              }
              function trim(string2, chars, guard) {
                string2 = toString2(string2);
                if (string2 && (guard || chars === undefined$1)) {
                  return baseTrim2(string2);
                }
                if (!string2 || !(chars = baseToString2(chars))) {
                  return string2;
                }
                var strSymbols = stringToArray2(string2), chrSymbols = stringToArray2(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
                return castSlice2(strSymbols, start, end).join("");
              }
              function trimEnd(string2, chars, guard) {
                string2 = toString2(string2);
                if (string2 && (guard || chars === undefined$1)) {
                  return string2.slice(0, trimmedEndIndex2(string2) + 1);
                }
                if (!string2 || !(chars = baseToString2(chars))) {
                  return string2;
                }
                var strSymbols = stringToArray2(string2), end = charsEndIndex(strSymbols, stringToArray2(chars)) + 1;
                return castSlice2(strSymbols, 0, end).join("");
              }
              function trimStart(string2, chars, guard) {
                string2 = toString2(string2);
                if (string2 && (guard || chars === undefined$1)) {
                  return string2.replace(reTrimStart2, "");
                }
                if (!string2 || !(chars = baseToString2(chars))) {
                  return string2;
                }
                var strSymbols = stringToArray2(string2), start = charsStartIndex(strSymbols, stringToArray2(chars));
                return castSlice2(strSymbols, start).join("");
              }
              function truncate(string2, options) {
                var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
                if (isObject2(options)) {
                  var separator = "separator" in options ? options.separator : separator;
                  length = "length" in options ? toInteger(options.length) : length;
                  omission = "omission" in options ? baseToString2(options.omission) : omission;
                }
                string2 = toString2(string2);
                var strLength = string2.length;
                if (hasUnicode2(string2)) {
                  var strSymbols = stringToArray2(string2);
                  strLength = strSymbols.length;
                }
                if (length >= strLength) {
                  return string2;
                }
                var end = length - stringSize(omission);
                if (end < 1) {
                  return omission;
                }
                var result2 = strSymbols ? castSlice2(strSymbols, 0, end).join("") : string2.slice(0, end);
                if (separator === undefined$1) {
                  return result2 + omission;
                }
                if (strSymbols) {
                  end += result2.length - end;
                }
                if (isRegExp(separator)) {
                  if (string2.slice(end).search(separator)) {
                    var match2, substring = result2;
                    if (!separator.global) {
                      separator = RegExp2(separator.source, toString2(reFlags.exec(separator)) + "g");
                    }
                    separator.lastIndex = 0;
                    while (match2 = separator.exec(substring)) {
                      var newEnd = match2.index;
                    }
                    result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
                  }
                } else if (string2.indexOf(baseToString2(separator), end) != end) {
                  var index = result2.lastIndexOf(separator);
                  if (index > -1) {
                    result2 = result2.slice(0, index);
                  }
                }
                return result2 + omission;
              }
              function unescape(string2) {
                string2 = toString2(string2);
                return string2 && reHasEscapedHtml.test(string2) ? string2.replace(reEscapedHtml, unescapeHtmlChar) : string2;
              }
              var upperCase = createCompounder(function(result2, word, index) {
                return result2 + (index ? " " : "") + word.toUpperCase();
              });
              var upperFirst2 = createCaseFirst2("toUpperCase");
              function words(string2, pattern, guard) {
                string2 = toString2(string2);
                pattern = guard ? undefined$1 : pattern;
                if (pattern === undefined$1) {
                  return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
                }
                return string2.match(pattern) || [];
              }
              var attempt = baseRest2(function(func, args) {
                try {
                  return apply2(func, undefined$1, args);
                } catch (e) {
                  return isError(e) ? e : new Error2(e);
                }
              });
              var bindAll = flatRest(function(object, methodNames) {
                arrayEach2(methodNames, function(key) {
                  key = toKey2(key);
                  baseAssignValue2(object, key, bind(object[key], object));
                });
                return object;
              });
              function cond(pairs) {
                var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
                pairs = !length ? [] : arrayMap2(pairs, function(pair) {
                  if (typeof pair[1] != "function") {
                    throw new TypeError2(FUNC_ERROR_TEXT2);
                  }
                  return [toIteratee(pair[0]), pair[1]];
                });
                return baseRest2(function(args) {
                  var index = -1;
                  while (++index < length) {
                    var pair = pairs[index];
                    if (apply2(pair[0], this, args)) {
                      return apply2(pair[1], this, args);
                    }
                  }
                });
              }
              function conforms(source) {
                return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
              }
              function constant2(value) {
                return function() {
                  return value;
                };
              }
              function defaultTo(value, defaultValue) {
                return value == null || value !== value ? defaultValue : value;
              }
              var flow = createFlow();
              var flowRight = createFlow(true);
              function identity2(value) {
                return value;
              }
              function iteratee(func) {
                return baseIteratee2(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
              }
              function matches(source) {
                return baseMatches2(baseClone(source, CLONE_DEEP_FLAG));
              }
              function matchesProperty(path, srcValue) {
                return baseMatchesProperty2(path, baseClone(srcValue, CLONE_DEEP_FLAG));
              }
              var method = baseRest2(function(path, args) {
                return function(object) {
                  return baseInvoke(object, path, args);
                };
              });
              var methodOf = baseRest2(function(object, args) {
                return function(path) {
                  return baseInvoke(object, path, args);
                };
              });
              function mixin(object, source, options) {
                var props = keys2(source), methodNames = baseFunctions(source, props);
                if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
                  options = source;
                  source = object;
                  object = this;
                  methodNames = baseFunctions(source, keys2(source));
                }
                var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object);
                arrayEach2(methodNames, function(methodName) {
                  var func = source[methodName];
                  object[methodName] = func;
                  if (isFunc) {
                    object.prototype[methodName] = function() {
                      var chainAll = this.__chain__;
                      if (chain2 || chainAll) {
                        var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray2(this.__actions__);
                        actions.push({ "func": func, "args": arguments, "thisArg": object });
                        result2.__chain__ = chainAll;
                        return result2;
                      }
                      return func.apply(object, arrayPush2([this.value()], arguments));
                    };
                  }
                });
                return object;
              }
              function noConflict() {
                if (root2._ === this) {
                  root2._ = oldDash;
                }
                return this;
              }
              function noop2() {
              }
              function nthArg(n) {
                n = toInteger(n);
                return baseRest2(function(args) {
                  return baseNth(args, n);
                });
              }
              var over = createOver(arrayMap2);
              var overEvery = createOver(arrayEvery);
              var overSome = createOver(arraySome2);
              function property2(path) {
                return isKey2(path) ? baseProperty2(toKey2(path)) : basePropertyDeep2(path);
              }
              function propertyOf(object) {
                return function(path) {
                  return object == null ? undefined$1 : baseGet2(object, path);
                };
              }
              var range2 = createRange2();
              var rangeRight = createRange2(true);
              function stubArray2() {
                return [];
              }
              function stubFalse2() {
                return false;
              }
              function stubObject() {
                return {};
              }
              function stubString() {
                return "";
              }
              function stubTrue() {
                return true;
              }
              function times(n, iteratee2) {
                n = toInteger(n);
                if (n < 1 || n > MAX_SAFE_INTEGER2) {
                  return [];
                }
                var index = MAX_ARRAY_LENGTH, length = nativeMin2(n, MAX_ARRAY_LENGTH);
                iteratee2 = getIteratee(iteratee2);
                n -= MAX_ARRAY_LENGTH;
                var result2 = baseTimes2(length, iteratee2);
                while (++index < n) {
                  iteratee2(index);
                }
                return result2;
              }
              function toPath(value) {
                if (isArray2(value)) {
                  return arrayMap2(value, toKey2);
                }
                return isSymbol2(value) ? [value] : copyArray2(stringToPath2(toString2(value)));
              }
              function uniqueId(prefix2) {
                var id = ++idCounter;
                return toString2(prefix2) + id;
              }
              var add = createMathOperation(function(augend, addend) {
                return augend + addend;
              }, 0);
              var ceil = createRound("ceil");
              var divide = createMathOperation(function(dividend, divisor) {
                return dividend / divisor;
              }, 1);
              var floor = createRound("floor");
              function max(array) {
                return array && array.length ? baseExtremum(array, identity2, baseGt) : undefined$1;
              }
              function maxBy(array, iteratee2) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined$1;
              }
              function mean(array) {
                return baseMean(array, identity2);
              }
              function meanBy(array, iteratee2) {
                return baseMean(array, getIteratee(iteratee2, 2));
              }
              function min(array) {
                return array && array.length ? baseExtremum(array, identity2, baseLt) : undefined$1;
              }
              function minBy(array, iteratee2) {
                return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined$1;
              }
              var multiply = createMathOperation(function(multiplier, multiplicand) {
                return multiplier * multiplicand;
              }, 1);
              var round = createRound("round");
              var subtract = createMathOperation(function(minuend, subtrahend) {
                return minuend - subtrahend;
              }, 0);
              function sum(array) {
                return array && array.length ? baseSum(array, identity2) : 0;
              }
              function sumBy(array, iteratee2) {
                return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
              }
              lodash2.after = after;
              lodash2.ary = ary;
              lodash2.assign = assign2;
              lodash2.assignIn = assignIn;
              lodash2.assignInWith = assignInWith;
              lodash2.assignWith = assignWith;
              lodash2.at = at;
              lodash2.before = before;
              lodash2.bind = bind;
              lodash2.bindAll = bindAll;
              lodash2.bindKey = bindKey;
              lodash2.castArray = castArray;
              lodash2.chain = chain;
              lodash2.chunk = chunk;
              lodash2.compact = compact;
              lodash2.concat = concat;
              lodash2.cond = cond;
              lodash2.conforms = conforms;
              lodash2.constant = constant2;
              lodash2.countBy = countBy;
              lodash2.create = create;
              lodash2.curry = curry;
              lodash2.curryRight = curryRight;
              lodash2.debounce = debounce2;
              lodash2.defaults = defaults;
              lodash2.defaultsDeep = defaultsDeep;
              lodash2.defer = defer;
              lodash2.delay = delay;
              lodash2.difference = difference;
              lodash2.differenceBy = differenceBy;
              lodash2.differenceWith = differenceWith;
              lodash2.drop = drop;
              lodash2.dropRight = dropRight;
              lodash2.dropRightWhile = dropRightWhile;
              lodash2.dropWhile = dropWhile;
              lodash2.fill = fill;
              lodash2.filter = filter;
              lodash2.flatMap = flatMap;
              lodash2.flatMapDeep = flatMapDeep;
              lodash2.flatMapDepth = flatMapDepth;
              lodash2.flatten = flatten2;
              lodash2.flattenDeep = flattenDeep;
              lodash2.flattenDepth = flattenDepth;
              lodash2.flip = flip;
              lodash2.flow = flow;
              lodash2.flowRight = flowRight;
              lodash2.fromPairs = fromPairs;
              lodash2.functions = functions;
              lodash2.functionsIn = functionsIn;
              lodash2.groupBy = groupBy;
              lodash2.initial = initial;
              lodash2.intersection = intersection;
              lodash2.intersectionBy = intersectionBy;
              lodash2.intersectionWith = intersectionWith;
              lodash2.invert = invert;
              lodash2.invertBy = invertBy;
              lodash2.invokeMap = invokeMap;
              lodash2.iteratee = iteratee;
              lodash2.keyBy = keyBy;
              lodash2.keys = keys2;
              lodash2.keysIn = keysIn2;
              lodash2.map = map2;
              lodash2.mapKeys = mapKeys;
              lodash2.mapValues = mapValues;
              lodash2.matches = matches;
              lodash2.matchesProperty = matchesProperty;
              lodash2.memoize = memoize2;
              lodash2.merge = merge2;
              lodash2.mergeWith = mergeWith;
              lodash2.method = method;
              lodash2.methodOf = methodOf;
              lodash2.mixin = mixin;
              lodash2.negate = negate;
              lodash2.nthArg = nthArg;
              lodash2.omit = omit2;
              lodash2.omitBy = omitBy;
              lodash2.once = once;
              lodash2.orderBy = orderBy;
              lodash2.over = over;
              lodash2.overArgs = overArgs;
              lodash2.overEvery = overEvery;
              lodash2.overSome = overSome;
              lodash2.partial = partial;
              lodash2.partialRight = partialRight;
              lodash2.partition = partition;
              lodash2.pick = pick;
              lodash2.pickBy = pickBy;
              lodash2.property = property2;
              lodash2.propertyOf = propertyOf;
              lodash2.pull = pull;
              lodash2.pullAll = pullAll;
              lodash2.pullAllBy = pullAllBy;
              lodash2.pullAllWith = pullAllWith;
              lodash2.pullAt = pullAt;
              lodash2.range = range2;
              lodash2.rangeRight = rangeRight;
              lodash2.rearg = rearg;
              lodash2.reject = reject;
              lodash2.remove = remove;
              lodash2.rest = rest;
              lodash2.reverse = reverse;
              lodash2.sampleSize = sampleSize;
              lodash2.set = set;
              lodash2.setWith = setWith;
              lodash2.shuffle = shuffle;
              lodash2.slice = slice;
              lodash2.sortBy = sortBy;
              lodash2.sortedUniq = sortedUniq;
              lodash2.sortedUniqBy = sortedUniqBy;
              lodash2.split = split;
              lodash2.spread = spread;
              lodash2.tail = tail;
              lodash2.take = take;
              lodash2.takeRight = takeRight;
              lodash2.takeRightWhile = takeRightWhile;
              lodash2.takeWhile = takeWhile;
              lodash2.tap = tap;
              lodash2.throttle = throttle2;
              lodash2.thru = thru;
              lodash2.toArray = toArray2;
              lodash2.toPairs = toPairs;
              lodash2.toPairsIn = toPairsIn;
              lodash2.toPath = toPath;
              lodash2.toPlainObject = toPlainObject2;
              lodash2.transform = transform;
              lodash2.unary = unary;
              lodash2.union = union;
              lodash2.unionBy = unionBy;
              lodash2.unionWith = unionWith;
              lodash2.uniq = uniq;
              lodash2.uniqBy = uniqBy;
              lodash2.uniqWith = uniqWith;
              lodash2.unset = unset;
              lodash2.unzip = unzip;
              lodash2.unzipWith = unzipWith;
              lodash2.update = update;
              lodash2.updateWith = updateWith;
              lodash2.values = values;
              lodash2.valuesIn = valuesIn;
              lodash2.without = without;
              lodash2.words = words;
              lodash2.wrap = wrap;
              lodash2.xor = xor;
              lodash2.xorBy = xorBy;
              lodash2.xorWith = xorWith;
              lodash2.zip = zip;
              lodash2.zipObject = zipObject;
              lodash2.zipObjectDeep = zipObjectDeep;
              lodash2.zipWith = zipWith;
              lodash2.entries = toPairs;
              lodash2.entriesIn = toPairsIn;
              lodash2.extend = assignIn;
              lodash2.extendWith = assignInWith;
              mixin(lodash2, lodash2);
              lodash2.add = add;
              lodash2.attempt = attempt;
              lodash2.camelCase = camelCase;
              lodash2.capitalize = capitalize;
              lodash2.ceil = ceil;
              lodash2.clamp = clamp;
              lodash2.clone = clone;
              lodash2.cloneDeep = cloneDeep;
              lodash2.cloneDeepWith = cloneDeepWith;
              lodash2.cloneWith = cloneWith;
              lodash2.conformsTo = conformsTo;
              lodash2.deburr = deburr;
              lodash2.defaultTo = defaultTo;
              lodash2.divide = divide;
              lodash2.endsWith = endsWith;
              lodash2.eq = eq2;
              lodash2.escape = escape;
              lodash2.escapeRegExp = escapeRegExp;
              lodash2.every = every;
              lodash2.find = find2;
              lodash2.findIndex = findIndex2;
              lodash2.findKey = findKey2;
              lodash2.findLast = findLast;
              lodash2.findLastIndex = findLastIndex;
              lodash2.findLastKey = findLastKey;
              lodash2.floor = floor;
              lodash2.forEach = forEach2;
              lodash2.forEachRight = forEachRight;
              lodash2.forIn = forIn;
              lodash2.forInRight = forInRight;
              lodash2.forOwn = forOwn;
              lodash2.forOwnRight = forOwnRight;
              lodash2.get = get2;
              lodash2.gt = gt;
              lodash2.gte = gte;
              lodash2.has = has;
              lodash2.hasIn = hasIn2;
              lodash2.head = head;
              lodash2.identity = identity2;
              lodash2.includes = includes;
              lodash2.indexOf = indexOf;
              lodash2.inRange = inRange;
              lodash2.invoke = invoke;
              lodash2.isArguments = isArguments2;
              lodash2.isArray = isArray2;
              lodash2.isArrayBuffer = isArrayBuffer;
              lodash2.isArrayLike = isArrayLike2;
              lodash2.isArrayLikeObject = isArrayLikeObject2;
              lodash2.isBoolean = isBoolean;
              lodash2.isBuffer = isBuffer2;
              lodash2.isDate = isDate;
              lodash2.isElement = isElement2;
              lodash2.isEmpty = isEmpty;
              lodash2.isEqual = isEqual;
              lodash2.isEqualWith = isEqualWith;
              lodash2.isError = isError;
              lodash2.isFinite = isFinite;
              lodash2.isFunction = isFunction2;
              lodash2.isInteger = isInteger;
              lodash2.isLength = isLength2;
              lodash2.isMap = isMap;
              lodash2.isMatch = isMatch;
              lodash2.isMatchWith = isMatchWith;
              lodash2.isNaN = isNaN2;
              lodash2.isNative = isNative;
              lodash2.isNil = isNil;
              lodash2.isNull = isNull;
              lodash2.isNumber = isNumber;
              lodash2.isObject = isObject2;
              lodash2.isObjectLike = isObjectLike2;
              lodash2.isPlainObject = isPlainObject2;
              lodash2.isRegExp = isRegExp;
              lodash2.isSafeInteger = isSafeInteger;
              lodash2.isSet = isSet;
              lodash2.isString = isString;
              lodash2.isSymbol = isSymbol2;
              lodash2.isTypedArray = isTypedArray2;
              lodash2.isUndefined = isUndefined;
              lodash2.isWeakMap = isWeakMap;
              lodash2.isWeakSet = isWeakSet;
              lodash2.join = join;
              lodash2.kebabCase = kebabCase2;
              lodash2.last = last;
              lodash2.lastIndexOf = lastIndexOf;
              lodash2.lowerCase = lowerCase;
              lodash2.lowerFirst = lowerFirst;
              lodash2.lt = lt;
              lodash2.lte = lte;
              lodash2.max = max;
              lodash2.maxBy = maxBy;
              lodash2.mean = mean;
              lodash2.meanBy = meanBy;
              lodash2.min = min;
              lodash2.minBy = minBy;
              lodash2.stubArray = stubArray2;
              lodash2.stubFalse = stubFalse2;
              lodash2.stubObject = stubObject;
              lodash2.stubString = stubString;
              lodash2.stubTrue = stubTrue;
              lodash2.multiply = multiply;
              lodash2.nth = nth;
              lodash2.noConflict = noConflict;
              lodash2.noop = noop2;
              lodash2.now = now2;
              lodash2.pad = pad;
              lodash2.padEnd = padEnd;
              lodash2.padStart = padStart;
              lodash2.parseInt = parseInt2;
              lodash2.random = random;
              lodash2.reduce = reduce;
              lodash2.reduceRight = reduceRight;
              lodash2.repeat = repeat2;
              lodash2.replace = replace;
              lodash2.result = result;
              lodash2.round = round;
              lodash2.runInContext = runInContext2;
              lodash2.sample = sample;
              lodash2.size = size2;
              lodash2.snakeCase = snakeCase;
              lodash2.some = some;
              lodash2.sortedIndex = sortedIndex;
              lodash2.sortedIndexBy = sortedIndexBy;
              lodash2.sortedIndexOf = sortedIndexOf;
              lodash2.sortedLastIndex = sortedLastIndex;
              lodash2.sortedLastIndexBy = sortedLastIndexBy;
              lodash2.sortedLastIndexOf = sortedLastIndexOf;
              lodash2.startCase = startCase;
              lodash2.startsWith = startsWith;
              lodash2.subtract = subtract;
              lodash2.sum = sum;
              lodash2.sumBy = sumBy;
              lodash2.template = template;
              lodash2.times = times;
              lodash2.toFinite = toFinite;
              lodash2.toInteger = toInteger;
              lodash2.toLength = toLength;
              lodash2.toLower = toLower;
              lodash2.toNumber = toNumber2;
              lodash2.toSafeInteger = toSafeInteger;
              lodash2.toString = toString2;
              lodash2.toUpper = toUpper;
              lodash2.trim = trim;
              lodash2.trimEnd = trimEnd;
              lodash2.trimStart = trimStart;
              lodash2.truncate = truncate;
              lodash2.unescape = unescape;
              lodash2.uniqueId = uniqueId;
              lodash2.upperCase = upperCase;
              lodash2.upperFirst = upperFirst2;
              lodash2.each = forEach2;
              lodash2.eachRight = forEachRight;
              lodash2.first = head;
              mixin(lodash2, (function() {
                var source = {};
                baseForOwn2(lodash2, function(func, methodName) {
                  if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
                    source[methodName] = func;
                  }
                });
                return source;
              })(), { "chain": false });
              lodash2.VERSION = VERSION;
              arrayEach2(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                lodash2[methodName].placeholder = lodash2;
              });
              arrayEach2(["drop", "take"], function(methodName, index) {
                LazyWrapper.prototype[methodName] = function(n) {
                  n = n === undefined$1 ? 1 : nativeMax2(toInteger(n), 0);
                  var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                  if (result2.__filtered__) {
                    result2.__takeCount__ = nativeMin2(n, result2.__takeCount__);
                  } else {
                    result2.__views__.push({
                      "size": nativeMin2(n, MAX_ARRAY_LENGTH),
                      "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
                    });
                  }
                  return result2;
                };
                LazyWrapper.prototype[methodName + "Right"] = function(n) {
                  return this.reverse()[methodName](n).reverse();
                };
              });
              arrayEach2(["filter", "map", "takeWhile"], function(methodName, index) {
                var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                LazyWrapper.prototype[methodName] = function(iteratee2) {
                  var result2 = this.clone();
                  result2.__iteratees__.push({
                    "iteratee": getIteratee(iteratee2, 3),
                    "type": type
                  });
                  result2.__filtered__ = result2.__filtered__ || isFilter;
                  return result2;
                };
              });
              arrayEach2(["head", "last"], function(methodName, index) {
                var takeName = "take" + (index ? "Right" : "");
                LazyWrapper.prototype[methodName] = function() {
                  return this[takeName](1).value()[0];
                };
              });
              arrayEach2(["initial", "tail"], function(methodName, index) {
                var dropName = "drop" + (index ? "" : "Right");
                LazyWrapper.prototype[methodName] = function() {
                  return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
                };
              });
              LazyWrapper.prototype.compact = function() {
                return this.filter(identity2);
              };
              LazyWrapper.prototype.find = function(predicate) {
                return this.filter(predicate).head();
              };
              LazyWrapper.prototype.findLast = function(predicate) {
                return this.reverse().find(predicate);
              };
              LazyWrapper.prototype.invokeMap = baseRest2(function(path, args) {
                if (typeof path == "function") {
                  return new LazyWrapper(this);
                }
                return this.map(function(value) {
                  return baseInvoke(value, path, args);
                });
              });
              LazyWrapper.prototype.reject = function(predicate) {
                return this.filter(negate(getIteratee(predicate)));
              };
              LazyWrapper.prototype.slice = function(start, end) {
                start = toInteger(start);
                var result2 = this;
                if (result2.__filtered__ && (start > 0 || end < 0)) {
                  return new LazyWrapper(result2);
                }
                if (start < 0) {
                  result2 = result2.takeRight(-start);
                } else if (start) {
                  result2 = result2.drop(start);
                }
                if (end !== undefined$1) {
                  end = toInteger(end);
                  result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
                }
                return result2;
              };
              LazyWrapper.prototype.takeRightWhile = function(predicate) {
                return this.reverse().takeWhile(predicate).reverse();
              };
              LazyWrapper.prototype.toArray = function() {
                return this.take(MAX_ARRAY_LENGTH);
              };
              baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
                var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
                if (!lodashFunc) {
                  return;
                }
                lodash2.prototype[methodName] = function() {
                  var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
                  var interceptor = function(value2) {
                    var result3 = lodashFunc.apply(lodash2, arrayPush2([value2], args));
                    return isTaker && chainAll ? result3[0] : result3;
                  };
                  if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
                    isLazy = useLazy = false;
                  }
                  var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
                  if (!retUnwrapped && useLazy) {
                    value = onlyLazy ? value : new LazyWrapper(this);
                    var result2 = func.apply(value, args);
                    result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
                    return new LodashWrapper(result2, chainAll);
                  }
                  if (isUnwrapped && onlyLazy) {
                    return func.apply(this, args);
                  }
                  result2 = this.thru(interceptor);
                  return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
                };
              });
              arrayEach2(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                var func = arrayProto2[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                lodash2.prototype[methodName] = function() {
                  var args = arguments;
                  if (retUnwrapped && !this.__chain__) {
                    var value = this.value();
                    return func.apply(isArray2(value) ? value : [], args);
                  }
                  return this[chainName](function(value2) {
                    return func.apply(isArray2(value2) ? value2 : [], args);
                  });
                };
              });
              baseForOwn2(LazyWrapper.prototype, function(func, methodName) {
                var lodashFunc = lodash2[methodName];
                if (lodashFunc) {
                  var key = lodashFunc.name + "";
                  if (!hasOwnProperty2.call(realNames, key)) {
                    realNames[key] = [];
                  }
                  realNames[key].push({ "name": methodName, "func": lodashFunc });
                }
              });
              realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
                "name": "wrapper",
                "func": undefined$1
              }];
              LazyWrapper.prototype.clone = lazyClone;
              LazyWrapper.prototype.reverse = lazyReverse;
              LazyWrapper.prototype.value = lazyValue;
              lodash2.prototype.at = wrapperAt;
              lodash2.prototype.chain = wrapperChain;
              lodash2.prototype.commit = wrapperCommit;
              lodash2.prototype.next = wrapperNext;
              lodash2.prototype.plant = wrapperPlant;
              lodash2.prototype.reverse = wrapperReverse;
              lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
              lodash2.prototype.first = lodash2.prototype.head;
              if (symIterator) {
                lodash2.prototype[symIterator] = wrapperToIterator;
              }
              return lodash2;
            });
            var _ = runInContext();
            if (freeModule2) {
              (freeModule2.exports = _)._ = _;
              freeExports2._ = _;
            } else {
              root2._ = _;
            }
          }).call(lodash);
        })(lodash$1, lodash$1.exports);
        return lodash$1.exports;
      }
      var lodashExports = requireLodash();
      const { message } = createDiscreteApi(["message"]);
      class DataStorage {
        STORAGE_KEY = "hgj_environment_switcher_data";
CROSS_ENV_SYNC_KEY = "hgj_cross_env_sync_timestamp";
DEFAULT_ACCOUNT_KEY = "hgj_default_account_id";
SWITCH_BTN_POS = "hgj_switch_btn_pos";
SETTINGS_KEY = "hgj_switch_settings";

eventCallbacks = new Map();
        globalCallbacks = [];
        listenerIds = [];
getDefaultValue(key) {
          const defaults = {
            hgj_environment_switcher_data: [],
            hgj_cross_env_sync_timestamp: 0,
            hgj_default_account_id: {},
            hgj_switch_btn_pos: { x: 0, y: 0 },
            hgj_switch_settings: {}
          };
          return defaults[key];
        }
init() {
          const allKeys = [
            "hgj_environment_switcher_data",
            "hgj_cross_env_sync_timestamp",
            "hgj_default_account_id",
            "hgj_switch_btn_pos",
            "hgj_switch_settings"
          ];
          allKeys.forEach((key) => {
            try {
              const listenerId = _GM_addValueChangeListener(
                key,
                (name, oldValue, newValue, remote) => {
                  this.handleStorageChange(
                    name,
                    oldValue,
                    newValue,
                    remote
                  );
                }
              );
              if (listenerId !== null) {
                this.listenerIds.push(listenerId);
              }
            } catch (error) {
              console.error(`Failed to add listener for key: ${key}`, error);
            }
          });
        }
handleStorageChange(key, oldValue, newValue, remote) {
          const event = {
            key,
            oldValue,
            newValue,
            remote,
            timestamp: Date.now()
          };
          this.globalCallbacks.forEach((callback) => {
            try {
              callback(event);
            } catch (error) {
              console.error("Error in global storage callback:", error);
            }
          });
          const keyCallbacks = this.eventCallbacks.get(key);
          if (keyCallbacks) {
            keyCallbacks.forEach((callback) => {
              try {
                callback(event);
              } catch (error) {
                console.error(
                  `Error in storage callback for key ${key}:`,
                  error
                );
              }
            });
          }
        }
onStorageChange(callback) {
          this.globalCallbacks.push(callback);
          return () => {
            const index = this.globalCallbacks.indexOf(callback);
            if (index > -1) {
              this.globalCallbacks.splice(index, 1);
            }
          };
        }
onKeyChange(key, callback) {
          const wrappedCallback = (event) => {
            if (event.key === key) {
              callback({
                key,
                oldValue: event.oldValue,
                newValue: event.newValue,
                remote: event.remote,
                timestamp: event.timestamp
              });
            }
          };
          if (!this.eventCallbacks.has(key)) {
            this.eventCallbacks.set(key, []);
          }
          this.eventCallbacks.get(key).push(wrappedCallback);
          return () => {
            const callbacks2 = this.eventCallbacks.get(key);
            if (callbacks2) {
              const index = callbacks2.indexOf(wrappedCallback);
              if (index > -1) {
                callbacks2.splice(index, 1);
              }
            }
          };
        }
destroy() {
          this.listenerIds.forEach((id) => {
            try {
              _GM_removeValueChangeListener(id);
              console.log("Cleaning up listener:", id);
            } catch (error) {
              console.error("Error removing GM listener:", error);
            }
          });
          this.globalCallbacks.length = 0;
          this.eventCallbacks.clear();
          this.listenerIds.length = 0;
        }
async set(key, value) {
          try {
            await _GM_setValue(key, value);
            return true;
          } catch (error) {
            return false;
          }
        }
async push(key, value) {
          try {
            const currentValue = await this.get(key);
            if (lodashExports.isEmpty(currentValue)) {
              const defaultValue = this.getDefaultValue(key);
              if (lodashExports.isArray(defaultValue)) {
                const newArray = [...defaultValue, value];
                await _GM_setValue(key, newArray);
              } else if (lodashExports.isObject(defaultValue)) {
                const updatedValue = Object.assign({}, defaultValue, value);
                await _GM_setValue(key, updatedValue);
              } else {
                await _GM_setValue(key, value);
              }
              await _GM_setValue(this.CROSS_ENV_SYNC_KEY, ( new Date()).getTime());
              return true;
            }
            if (lodashExports.isArray(currentValue)) {
              const newArray = [...currentValue, value];
              await _GM_setValue(key, newArray);
              return true;
            }
            if (lodashExports.isObject(currentValue)) {
              const updatedValue = Object.assign({}, currentValue, value);
              await _GM_setValue(key, updatedValue);
              return true;
            }
            await _GM_setValue(key, value);
            return true;
          } catch (error) {
            console.error("Error in push method:", error);
            message.error("数据格式不匹配，未插入数据");
            return false;
          }
        }
async get(key, defaultValue = null) {
          try {
            const value = await _GM_getValue(key, defaultValue);
            return value;
          } catch (error) {
            return defaultValue;
          }
        }
async delete(key) {
          try {
            await _GM_deleteValue(key);
            return true;
          } catch (error) {
            return false;
          }
        }
addListener(key, callback) {
          try {
            const listenerId = _GM_addValueChangeListener(
              key,
              (name, oldValue, newValue, remote) => {
                callback(
                  name,
                  oldValue,
                  newValue,
                  remote
                );
              }
            );
            return listenerId;
          } catch (error) {
            return null;
          }
        }
getSync(key, defaultValue = null) {
          try {
            return _GM_getValue(key, defaultValue);
          } catch (error) {
            return defaultValue;
          }
        }
setSync(key, value) {
          try {
            _GM_setValue(key, value);
            return true;
          } catch (error) {
            return false;
          }
        }
sessionGet(key, defaultValue = null) {
          try {
            const value = sessionStorage.getItem(key);
            return value !== null ? JSON.parse(value) : defaultValue;
          } catch (error) {
            return defaultValue;
          }
        }
sessionSet(key, value) {
          try {
            if (value === null || value === void 0) {
              sessionStorage.removeItem(key);
            } else {
              sessionStorage.setItem(key, JSON.stringify(value));
            }
            return true;
          } catch (error) {
            return false;
          }
        }
remove(key) {
          try {
            sessionStorage.removeItem(key);
            return true;
          } catch (error) {
            return false;
          }
        }
        constructor() {
          this.init();
        }
      }
      const dataStorage = new DataStorage();
      function mitt(n) {
        return { all: n = n || new Map(), on: function(t, e) {
          var i = n.get(t);
          i ? i.push(e) : n.set(t, [e]);
        }, off: function(t, e) {
          var i = n.get(t);
          i && (e ? i.splice(i.indexOf(e) >>> 0, 1) : n.set(t, []));
        }, emit: function(t, e) {
          var i = n.get(t);
          i && i.slice().map(function(n2) {
            n2(e);
          }), (i = n.get("*")) && i.slice().map(function(n2) {
            n2(t, e);
          });
        } };
      }
      function isInIframe() {
        try {
          return window.self !== window.top;
        } catch (e) {
          return true;
        }
      }
      function guid() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
          /[xy]/g,
          function(c2) {
            var r = Math.random() * 16 | 0, v = c2 == "x" ? r : r & 3 | 8;
            return v.toString(16);
          }
        );
      }
      function getCurrentEnvironment() {
        const hostname = window.location.hostname;
        if (hostname.includes("dev") || hostname.includes("localhost")) {
          return "dev";
        } else if (hostname.includes("beta") || hostname.includes("test")) {
          return "beta";
        } else {
          return "prod";
        }
      }
      function processUrl(env) {
        const currentUrl = window.location.href.includes("localhost:") || env === "prod" ? "https://eyun.hgj.com/login" : window.location.href;
        const url = new URL(currentUrl);
        if (env !== "prod") {
          let hostname = url.hostname;
          const dashIndex = hostname.indexOf("-");
          dashIndex != -1 ? hostname = env + hostname.substring(dashIndex) : hostname = env + "-" + hostname;
          url.hostname = hostname;
        }
        return url.toString();
      }
      function clearHGJCookie() {
        const cookies = document.cookie ? document.cookie.split(";") : [];
        for (let i = 0; i < cookies.length; i++) {
          if (!cookies[i].includes("hgj")) continue;
          const cookie = cookies[i];
          const eqPos = cookie.indexOf("=");
          const name = eqPos > -1 ? cookie.substr(0, eqPos) : cookie;
          _GM_cookie.delete({ name });
        }
      }
      function logOut() {
        if (_unsafeWindow) {
          clearHGJCookie();
          document.getElementById("app")?.__vue__?.$store?.commit(
            "logout"
          );
          window.location.href = window.location.origin + "/login";
        }
      }
      function fillInAccount(accountInfo) {
        const { account, password } = accountInfo;
        const allTextInputs = Array.from(
          document.querySelectorAll(
            'input[type="text"], input[type="email"], input:not([type])'
          )
        );
        const usernameInputs = allTextInputs.filter((input) => {
          if (input.value === "+86" || input.value === "86" || input.placeholder === "+86") {
            return false;
          }
          if (input.offsetWidth < 100) {
            return false;
          }
          if (input.disabled || input.readOnly) {
            return false;
          }
          const name = (input.name || "").toLowerCase();
          const id = (input.id || "").toLowerCase();
          const placeholder = (input.placeholder || "").toLowerCase();
          const className = (input.className || "").toLowerCase();
          if (name.includes("code") || id.includes("code") || placeholder.includes("区号") || className.includes("code")) {
            return false;
          }
          return true;
        });
        const passwordInputs = Array.from(
          document.querySelectorAll('input[type="password"]')
        );
        if (usernameInputs.length > 0) {
          let usernameInput = usernameInputs.find((input) => {
            const name = (input.name || "").toLowerCase();
            const id = (input.id || "").toLowerCase();
            const placeholder = (input.placeholder || "").toLowerCase();
            return name.includes("username") || name.includes("user") || name.includes("account") || id.includes("username") || id.includes("user") || id.includes("account") || placeholder.includes("用户名") || placeholder.includes("账号") || placeholder.includes("手机号") || placeholder.includes("邮箱");
          });
          if (!usernameInput) {
            usernameInput = usernameInputs[0];
          }
          usernameInput.value = account;
          usernameInput.dispatchEvent(new Event("input", { bubbles: true }));
          usernameInput.dispatchEvent(new Event("change", { bubbles: true }));
        }
        if (passwordInputs.length > 0) {
          const passwordInput = passwordInputs[0];
          passwordInput.value = password;
          passwordInput.dispatchEvent(new Event("input", { bubbles: true }));
          passwordInput.dispatchEvent(new Event("change", { bubbles: true }));
        }
      }
      function clickLoginBtn() {
        const loginButtons = document.querySelectorAll(".login-btn");
        console.log(loginButtons.length);
        if (loginButtons.length >= 1) {
          const loginButton = loginButtons[0];
          if (loginButton.offsetParent !== null) {
            loginButton.click();
            loginButton.dispatchEvent(new Event("mousedown", { bubbles: true }));
            loginButton.dispatchEvent(new Event("mouseup", { bubbles: true }));
            loginButton.dispatchEvent(new Event("click", { bubbles: true }));
          }
        } else {
          document.querySelectorAll("article")[1];
          let btns = document.querySelectorAll("article");
          btns.forEach((item) => {
            if (item.textContent?.includes("登录")) {
              item.click();
            }
          });
        }
      }
      const emitter = mitt();
      const globalEmitter = emitter;
      const useSwitcherStore = defineStore("switcher", () => {
        const accounts = vue.ref([]);
        const devAccounts = vue.computed(
          () => accounts.value.filter((account) => account.env.includes("dev"))
        );
        const betaAccounts = vue.computed(
          () => accounts.value.filter((account) => account.env.includes("beta"))
        );
        const prodAccounts = vue.computed(
          () => accounts.value.filter((account) => account.env.includes("prod"))
        );
        const position = vue.ref(null);
        const defaultAccount = vue.ref({});
        const settings = vue.ref({
          incognito: false,
          newTab: false
        });
        const currentEnv = vue.ref();
        const globalStorageListener = (event) => {
          switch (event.key) {
            case dataStorage.STORAGE_KEY:
              handleEnvironmentSwitchDataChange(event);
              break;
            case dataStorage.SWITCH_BTN_POS:
              handlePositionChange(event);
              break;
            case dataStorage.DEFAULT_ACCOUNT_KEY:
              handleDefaultAccountChange(event);
              break;
          }
        };
        const handleEnvironmentSwitchDataChange = (event) => {
          event.newValue && (accounts.value = event.newValue);
        };
        const deleteAccountById = (id) => {
          const index = accounts.value.findIndex((account) => account.id === id);
          if (index !== -1) {
            defaultAccount.value = forEach(
              defaultAccount.value,
              (value, key) => {
                value === id && (defaultAccount.value[key] = void 0);
              }
            );
            setDefaultAccount(defaultAccount.value);
            accounts.value.splice(index, 1);
            dataStorage.setSync(dataStorage.STORAGE_KEY, accounts.value);
            return true;
          }
          return false;
        };
        const addNewAccount = (account) => {
          dataStorage.push(dataStorage.STORAGE_KEY, account);
          return true;
        };
        const upDataAccountById = (id, account) => {
          const index = accounts.value.findIndex((account2) => account2.id === id);
          if (index !== -1) {
            accounts.value[index] = account;
            dataStorage.setSync(dataStorage.STORAGE_KEY, accounts.value);
            defaultAccount.value = forEach(
              defaultAccount.value,
              (value, key) => {
                if (value === id && !accounts.value[index].env.includes(key)) {
                  defaultAccount.value[key] = void 0;
                }
              }
            );
            setDefaultAccount(defaultAccount.value);
            return true;
          } else {
            return false;
          }
        };
        const handlePositionChange = (event) => {
          position.value = event.newValue;
        };
        const setPosition = (pos) => {
          position.value = pos;
          dataStorage.setSync(dataStorage.SWITCH_BTN_POS, pos);
        };
        const handleDefaultAccountChange = (event) => {
          defaultAccount.value = event.newValue;
        };
        const setDefaultAccount = (account) => {
          defaultAccount.value = account;
          dataStorage.setSync(dataStorage.DEFAULT_ACCOUNT_KEY, account);
        };
        const setSettings = (settings2) => {
          dataStorage.setSync(dataStorage.SETTINGS_KEY, settings2);
        };
        dataStorage.onStorageChange(globalStorageListener);
        (() => {
          accounts.value = dataStorage.getSync(
            dataStorage.STORAGE_KEY,
            []
          );
          position.value = dataStorage.getSync(
            dataStorage.SWITCH_BTN_POS
          );
          defaultAccount.value = dataStorage.getSync(
            dataStorage.DEFAULT_ACCOUNT_KEY,
            {}
          );
          settings.value = dataStorage.getSync(dataStorage.SETTINGS_KEY, {
            incognito: false,
            newTab: false
          });
          currentEnv.value = getCurrentEnvironment();
        })();
        return {
          accounts,
          deleteAccountById,
          addNewAccount,
          upDataAccountById,
          devAccounts,
          betaAccounts,
          prodAccounts,
          position,
          setPosition,
          defaultAccount,
          setDefaultAccount,
          settings,
          setSettings,
          currentEnv
        };
      });
      const _hoisted_1$3 = {
        xmlns: "http://www.w3.org/2000/svg",
        "xmlns:xlink": "http://www.w3.org/1999/xlink",
        viewBox: "0 0 512 512"
      };
      const CheckmarkCircle = vue.defineComponent({
        name: "CheckmarkCircle",
        render: function render2(_ctx, _cache) {
          return vue.openBlock(), vue.createElementBlock(
            "svg",
            _hoisted_1$3,
            _cache[0] || (_cache[0] = [
              vue.createElementVNode(
                "path",
                {
                  d: "M256 48C141.31 48 48 141.31 48 256s93.31 208 208 208s208-93.31 208-208S370.69 48 256 48zm108.25 138.29l-134.4 160a16 16 0 0 1-12 5.71h-.27a16 16 0 0 1-11.89-5.3l-57.6-64a16 16 0 1 1 23.78-21.4l45.29 50.32l122.59-145.91a16 16 0 0 1 24.5 20.58z",
                  fill: "currentColor"
                },
                null,
                -1
)
            ])
          );
        }
      });
      const _hoisted_1$2 = {
        class: "quick-switch",
        role: "region",
        "aria-label": "快捷切换"
      };
      const _hoisted_2$1 = ["onClick"];
      const _hoisted_3$1 = { class: "item-top" };
      const _hoisted_4 = { class: "account-name" };
      const _hoisted_5 = { style: { "font-size": "10px", "margin-top": "10px" } };
      const _hoisted_6 = { class: "options" };
      const _sfc_main$7 = vue.defineComponent({
        __name: "QuickMenu",
        props: {
          env: {}
        },
        setup(__props) {
          const switcherStore = useSwitcherStore();
          const { message: message2 } = createDiscreteApi(["message"]);
          const props = __props;
          const accounts = vue.computed(() => {
            switch (props.env) {
              case "dev":
                return switcherStore.devAccounts;
              case "beta":
                return switcherStore.betaAccounts;
              case "prod":
                return switcherStore.prodAccounts;
              default:
                return switcherStore.accounts;
            }
          });
          const defaultAccount = vue.computed(() => {
            return (id) => {
              return switcherStore.defaultAccount[props.env] === id;
            };
          });
          const fillAccount = (account) => {
            if (switcherStore.currentEnv === props.env) {
              dataStorage.sessionSet("session_account", {
                account: account.account,
                password: account.password
              });
              if (!window.location.pathname.includes("login")) {
                clearHGJCookie();
                logOut();
              } else {
                fillInAccount(account);
                clickLoginBtn();
              }
            } else {
              let url = `${processUrl(props.env)}?id=${account.id}`;
              if (switcherStore.settings.newTab) {
                _GM_openInTab(url, {
                  active: true,
                  incognito: switcherStore.settings.incognito
                });
              } else {
                window.open(url);
              }
            }
          };
          const addNewByEnv = () => {
            globalEmitter.emit("addNewByEnv");
          };
          const copyToClipboard = (account) => {
            _GM_setClipboard(
              `账号: ${account.account} 
密码: ${account.password}`,
              "text"
            );
            message2.success("账号信息已复制到剪贴板");
          };
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$2, [
              _cache[3] || (_cache[3] = vue.createElementVNode("div", { class: "quick-switch__header" }, [
                vue.createElementVNode("span", null, "快捷切换")
              ], -1)),
              vue.createElementVNode("div", {
                class: "quick-switch__list",
                style: vue.normalizeStyle({
                  "justify-content": !accounts.value.length ? "center" : "flex-start"
                })
              }, [
                (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(accounts.value, (item) => {
                  return vue.openBlock(), vue.createElementBlock("div", {
                    class: "quick-switch__item",
                    key: item.id,
                    onClick: vue.withModifiers(($event) => fillAccount(item), ["stop"])
                  }, [
                    vue.createElementVNode("div", _hoisted_3$1, [
                      vue.createElementVNode("div", _hoisted_4, [
                        vue.createElementVNode("div", null, vue.toDisplayString(item.name), 1),
                        vue.createElementVNode("div", _hoisted_5, vue.toDisplayString(item.account), 1)
                      ]),
                      vue.createElementVNode("div", _hoisted_6, [
                        defaultAccount.value(item.id) ? (vue.openBlock(), vue.createBlock(vue.unref(NTag), {
                          key: 0,
                          round: "",
                          bordered: false,
                          type: "success"
                        }, {
                          icon: vue.withCtx(() => [
                            vue.createVNode(vue.unref(NIcon), { component: vue.unref(CheckmarkCircle) }, null, 8, ["component"])
                          ]),
                          default: vue.withCtx(() => [
                            _cache[0] || (_cache[0] = vue.createElementVNode("span", { class: "env" }, " 默认 ", -1))
                          ]),
                          _: 1
                        })) : vue.createCommentVNode("", true),
                        vue.createVNode(vue.unref(Button), {
                          type: "primary",
                          size: "small",
                          class: "copyBtn",
                          onClick: vue.withModifiers(($event) => copyToClipboard(item), ["stop"])
                        }, {
                          default: vue.withCtx(() => [..._cache[1] || (_cache[1] = [
                            vue.createTextVNode("复制", -1)
                          ])]),
                          _: 1
                        }, 8, ["onClick"])
                      ])
                    ])
                  ], 8, _hoisted_2$1);
                }), 128)),
                !accounts.value.length ? (vue.openBlock(), vue.createBlock(vue.unref(NEmpty), {
                  key: 0,
                  description: "暂无数据"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(Button), {
                      type: "primary",
                      onClick: vue.withModifiers(addNewByEnv, ["stop"])
                    }, {
                      default: vue.withCtx(() => [..._cache[2] || (_cache[2] = [
                        vue.createTextVNode(" 添加新账号 ", -1)
                      ])]),
                      _: 1
                    })
                  ]),
                  _: 1
                })) : vue.createCommentVNode("", true)
              ], 4)
            ]);
          };
        }
      });
      const _export_sfc = (sfc, props) => {
        const target = sfc.__vccOpts || sfc;
        for (const [key, val] of props) {
          target[key] = val;
        }
        return target;
      };
      const QuickMenu = _export_sfc(_sfc_main$7, [["__scopeId", "data-v-f5224cf8"]]);
      const btnWidth = 44;
      const _sfc_main$6 = vue.defineComponent({
        __name: "SwitchBtn",
        props: vue.mergeModels({
          parentPos: {}
        }, {
          "show": { type: Boolean, default: false },
          "showModifiers": {}
        }),
        emits: ["update:show"],
        setup(__props, { expose: __expose }) {
          const switcherStore = useSwitcherStore();
          const { message: message2 } = createDiscreteApi(["message"]);
          const show = vue.useModel(__props, "show");
          const menu = vue.ref([
            {
              name: "开发环境",
              value: "dev",
              type: "primary",
              show: false
            },
            {
              name: "测试环境",
              value: "beta",
              type: "info",
              show: false
            },
            {
              name: "生产环境",
              value: "prod",
              type: "warning",
              show: false
            }
          ]);
          const menuDirection = vue.ref([
            0,
            0
]);
          const windowWidth = window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth;
          const envOptions = vue.ref(null);
          const pos = vue.ref({ x: 0, y: 0 });
          const safeMargin = { width: 0, height: 0 };
          let observer = null;
          let move2 = false;
          let closeTimer = null;
          const adjustPosition = (entry) => {
            if (!envOptions.value || move2) return;
            move2 = true;
            const { x, y } = recordMoveStep(entry);
            pos.value.x = x;
            pos.value.y = y;
            setTimeout(() => move2 = false, 300);
          };
          const recordMoveStep = (entry) => {
            const { left, right, top, bottom } = entry.boundingClientRect;
            let newX = pos.value.x;
            let newY = pos.value.y;
            if (left <= 0) {
              console.log("enter left");
              newX = pos.value.x + safeMargin.width + btnWidth;
              menuDirection.value[0] = 1;
            } else if (left > windowWidth - safeMargin.width && menuDirection.value[0] === 1) {
              console.log("enter right");
              console.log(window.innerWidth, right);
              newX = pos.value.x - safeMargin.width - btnWidth;
              menuDirection.value[0] = 0;
            } else if (top < 0 && menuDirection.value[1] !== 1) {
              console.log("enter top");
              newY = pos.value.y + safeMargin.height + btnWidth;
              menuDirection.value[1] = 1;
            } else if (window.innerHeight <= bottom && menuDirection.value[1] !== 0) {
              console.log("enter bottom");
              newY = pos.value.y - safeMargin.height - btnWidth;
              menuDirection.value[1] = 0;
            }
            return { x: newX, y: newY };
          };
          const createObserver = () => {
            observer && observer.disconnect();
            observer = new IntersectionObserver(
              (entries) => {
                const entry = entries[0];
                console.log("enter move", entry);
                entry.intersectionRatio < 1 && adjustPosition(entry);
              },
              {
                threshold: [0, 0.1, 0.5, 0.9, 0.95, 1]
              }
            );
            envOptions.value && observer.observe(envOptions.value);
          };
          vue.watch(show, (newValue) => {
            if (newValue) {
              setTimeout(init2, 0);
            } else {
              observer && observer.disconnect();
            }
          });
          const init2 = () => {
            safeMargin.width = envOptions.value?.offsetWidth || 144;
            safeMargin.height = envOptions.value?.offsetHeight || 150;
            pos.value = {
              x: -safeMargin.width,
              y: -safeMargin.height
            };
            createObserver();
            closeTimer && clearTimeout(closeTimer) && (closeTimer = null);
            closeTimer = setTimeout(
              () => envOptions.value.style.transition = "all 0.3s ease",
              100
            );
          };
          vue.onUnmounted(() => {
            observer && observer.disconnect();
            closeTimer && clearTimeout(closeTimer) && (closeTimer = null);
          });
          const openQuickMenu = (index) => {
            closeTimer && clearTimeout(closeTimer) && (closeTimer = null);
            if (menu.value[index].show) return;
            closeQuickMenu();
            menu.value[index].show = true;
          };
          const closeQuickMenu = (index) => {
            if (index !== void 0) {
              closeTimer && clearTimeout(closeTimer);
              closeTimer = setTimeout(() => {
                menu.value[index].show = false;
                closeTimer = null;
              }, 300);
            } else {
              closeTimer && clearTimeout(closeTimer) && (closeTimer = null);
              menu.value?.forEach((item) => item.show = false);
            }
          };
          const openNewTabByEnv = (env) => {
            if (switcherStore.currentEnv === env) {
              message2.info("当前已是该环境，无需重复打开");
              return;
            } else {
              if (switcherStore.settings.newTab) {
                _GM_openInTab(processUrl(env), {
                  active: true,
                  incognito: switcherStore.settings.incognito
                });
              } else {
                window.open(processUrl(env));
              }
            }
            show.value = false;
          };
          __expose({
            closeQuickMenu
          });
          return (_ctx, _cache) => {
            return show.value ? (vue.openBlock(), vue.createElementBlock("div", {
              key: 0,
              ref_key: "envOptions",
              ref: envOptions,
              class: "envOptions",
              style: vue.normalizeStyle({ top: pos.value.y + "px", left: pos.value.x + "px" })
            }, [
              (vue.openBlock(true), vue.createElementBlock(vue.Fragment, null, vue.renderList(menu.value, (item, index) => {
                return vue.openBlock(), vue.createBlock(vue.unref(Button), {
                  strong: "",
                  secondary: "",
                  type: item.type,
                  class: "ui-button",
                  key: item.value,
                  onMouseenter: ($event) => openQuickMenu(index),
                  onMouseleave: ($event) => closeQuickMenu(index),
                  onClick: vue.withModifiers(($event) => openNewTabByEnv(item.value), ["stop"])
                }, {
                  default: vue.withCtx(() => [
                    vue.createElementVNode("span", null, vue.toDisplayString(item.name), 1),
                    item.show ? (vue.openBlock(), vue.createElementBlock("div", {
                      key: 0,
                      class: "quick-menu",
                      style: vue.normalizeStyle({
                        transform: menuDirection.value[0] === 0 ? "translateX(-118%)" : "translateX(48%)"
                      })
                    }, [
                      vue.createVNode(QuickMenu, {
                        env: item.value
                      }, null, 8, ["env"])
                    ], 4)) : vue.createCommentVNode("", true)
                  ]),
                  _: 2
                }, 1032, ["type", "onMouseenter", "onMouseleave", "onClick"]);
              }), 128))
            ], 4)) : vue.createCommentVNode("", true);
          };
        }
      });
      const SwitchBtn = _export_sfc(_sfc_main$6, [["__scopeId", "data-v-d9ac85f1"]]);
      const _sfc_main$5 = vue.defineComponent({
        __name: "AccountForm",
        setup(__props) {
          const { message: message2 } = createDiscreteApi(["message"]);
          const switcherStore = useSwitcherStore();
          const loading = vue.ref(false);
          const accountModel = vue.ref({
            id: "",
            name: "",
            account: "",
            password: "",
            env: []
          });
          const formRef = vue.ref();
          const rules2 = {
            name: {
              required: true,
              message: "请输入账号名",
              trigger: ["input", "blur"]
            },
            account: {
              required: true,
              message: "请输入账号",
              trigger: ["input", "blur"]
            },
            password: {
              required: true,
              message: "请输入密码",
              trigger: ["input", "blur"]
            },
            env: {
              type: "array",
              required: true,
              message: "请选择所属环境",
              trigger: ["change", "blur"]
            }
          };
          vue.onMounted(() => {
            globalEmitter.on("edit-account", (account) => {
              accountModel.value = { ...account };
            });
            globalEmitter.on("delete-account", (id) => {
              accountModel.value.id === id && clear(true);
            });
          });
          const saveAccount = lodashExports.debounce(() => {
            formRef.value?.validate(async (errors) => {
              if (!errors) {
                loading.value = true;
                if (!accountModel.value.id) {
                  const newAccount = Object.assign({}, accountModel.value, {
                    id: guid()
                  });
                  switcherStore.addNewAccount(newAccount) && message2.success("账号新增成功");
                } else {
                  switcherStore.upDataAccountById(
                    accountModel.value.id,
                    accountModel.value
                  ) && message2.success("账号修改成功");
                }
                clear(true);
              } else {
                message2.warning("请检查表单填写是否正确");
              }
            });
            loading.value = false;
          }, 300);
          const clear = (clearAll = false) => {
            accountModel.value = Object.assign(
              {
                name: "",
                account: "",
                password: "",
                env: []
              },
              accountModel.value.id && !clearAll ? { id: accountModel.value.id } : {}
            );
          };
          return (_ctx, _cache) => {
            const _component_n_spin = vue.resolveComponent("n-spin");
            return vue.openBlock(), vue.createBlock(_component_n_spin, { show: loading.value }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(NForm), {
                  size: "small",
                  "label-placement": "left",
                  "label-width": "80",
                  ref_key: "formRef",
                  ref: formRef,
                  model: accountModel.value,
                  rules: rules2
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(NFormItem), {
                      path: "name",
                      label: "账号名称"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(NInput), {
                          value: accountModel.value.name,
                          "onUpdate:value": _cache[0] || (_cache[0] = ($event) => accountModel.value.name = $event),
                          placeholder: "请输入账号名称",
                          onKeydown: _cache[1] || (_cache[1] = vue.withKeys(vue.withModifiers(() => {
                          }, ["prevent"]), ["enter"]))
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(NFormItem), {
                      path: "account",
                      label: "账号"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(NInput), {
                          value: accountModel.value.account,
                          "onUpdate:value": _cache[2] || (_cache[2] = ($event) => accountModel.value.account = $event),
                          placeholder: "请输入账号",
                          onKeydown: _cache[3] || (_cache[3] = vue.withKeys(vue.withModifiers(() => {
                          }, ["prevent"]), ["enter"]))
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(NFormItem), {
                      path: "password",
                      label: "密码"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(NInput), {
                          value: accountModel.value.password,
                          "onUpdate:value": _cache[4] || (_cache[4] = ($event) => accountModel.value.password = $event),
                          placeholder: "请输入密码",
                          onKeydown: _cache[5] || (_cache[5] = vue.withKeys(vue.withModifiers(() => {
                          }, ["prevent"]), ["enter"]))
                        }, null, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(NFormItem), {
                      path: "env",
                      label: "所属环境"
                    }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(NCheckboxGroup), {
                          value: accountModel.value.env,
                          "onUpdate:value": _cache[6] || (_cache[6] = ($event) => accountModel.value.env = $event)
                        }, {
                          default: vue.withCtx(() => [
                            vue.createVNode(vue.unref(NSpace), null, {
                              default: vue.withCtx(() => [
                                vue.createVNode(vue.unref(NCheckbox), { value: "dev" }, {
                                  default: vue.withCtx(() => [..._cache[9] || (_cache[9] = [
                                    vue.createTextVNode("开发环境", -1)
                                  ])]),
                                  _: 1
                                }),
                                vue.createVNode(vue.unref(NCheckbox), { value: "beta" }, {
                                  default: vue.withCtx(() => [..._cache[10] || (_cache[10] = [
                                    vue.createTextVNode("测试环境", -1)
                                  ])]),
                                  _: 1
                                }),
                                vue.createVNode(vue.unref(NCheckbox), { value: "prod" }, {
                                  default: vue.withCtx(() => [..._cache[11] || (_cache[11] = [
                                    vue.createTextVNode("生产环境", -1)
                                  ])]),
                                  _: 1
                                })
                              ]),
                              _: 1
                            })
                          ]),
                          _: 1
                        }, 8, ["value"])
                      ]),
                      _: 1
                    }),
                    vue.createVNode(vue.unref(NSpace), { justify: "end" }, {
                      default: vue.withCtx(() => [
                        vue.createVNode(vue.unref(Button), {
                          type: "primary",
                          style: { "width": "150px" },
                          onClick: vue.unref(saveAccount)
                        }, {
                          default: vue.withCtx(() => [..._cache[12] || (_cache[12] = [
                            vue.createTextVNode("保存", -1)
                          ])]),
                          _: 1
                        }, 8, ["onClick"]),
                        accountModel.value.id ? (vue.openBlock(), vue.createBlock(vue.unref(Button), {
                          key: 0,
                          type: "default",
                          style: { "width": "150px" },
                          onClick: _cache[7] || (_cache[7] = ($event) => clear(true))
                        }, {
                          default: vue.withCtx(() => [..._cache[13] || (_cache[13] = [
                            vue.createTextVNode("取消修改", -1)
                          ])]),
                          _: 1
                        })) : vue.createCommentVNode("", true),
                        vue.createVNode(vue.unref(Button), {
                          type: "warning",
                          style: { "width": "150px" },
                          onClick: _cache[8] || (_cache[8] = ($event) => clear())
                        }, {
                          default: vue.withCtx(() => [..._cache[14] || (_cache[14] = [
                            vue.createTextVNode("清空", -1)
                          ])]),
                          _: 1
                        })
                      ]),
                      _: 1
                    })
                  ]),
                  _: 1
                }, 8, ["model"])
              ]),
              _: 1
            }, 8, ["show"]);
          };
        }
      });
      var EnvTagType = ((EnvTagType2) => {
        EnvTagType2["dev"] = "info";
        EnvTagType2["beta"] = "warning";
        EnvTagType2["prod"] = "success";
        return EnvTagType2;
      })(EnvTagType || {});
      const _hoisted_1$1 = { class: "account-table" };
      const _sfc_main$4 = vue.defineComponent({
        __name: "AccountTable",
        setup(__props) {
          const { message: message2 } = createDiscreteApi(["message"]);
          const switcherStore = useSwitcherStore();
          const accounts = vue.ref([]);
          const columns = [
            {
              title: "账号名",
              key: "name",
              align: "center"
            },
            {
              title: "账号",
              key: "account",
              align: "center"
            },
            {
              title: "密码",
              key: "password",
              align: "center"
            },
            {
              title: "环境",
              key: "env",
              align: "center",
              render: (row) => {
                return vue.h(
                  NSpace,
                  { justify: "space-evenly", size: "small" },
                  () => row.env.map(
                    (env) => vue.h(
                      NTag,
                      { type: EnvTagType[env], size: "medium" },
                      { default: () => env }
                    )
                  )
                );
              }
            },
            {
              title: "操作",
              key: "actions",
              minWidth: 200,
              align: "center",
              render: (row) => {
                return vue.h(NSpace, { justify: "space-evenly" }, () => [
                  vue.h(
                    Button,
                    {
                      size: "small",
                      strong: true,
                      secondary: true,
                      type: "info",
                      onClick: (e) => {
                        e.stopPropagation();
                        globalEmitter.emit("edit-account", row);
                      }
                    },
                    { default: () => "修改" }
                  ),
                  vue.h(
                    NPopconfirm,
                    {
                      onPositiveClick: (e) => {
                        e.stopPropagation();
                        deleteAccount(row.id);
                      },
                      positiveText: "确认删除",
                      negativeText: "取消"
                    },
                    {
                      trigger: () => vue.h(
                        Button,
                        {
                          size: "small",
                          strong: true,
                          secondary: true,
                          type: "error"
                        },
                        { default: () => "删除" }
                      ),
                      default: () => "确定要删除这个账号吗？"
                    }
                  )
                ]);
              }
            }
          ];
          const loading = vue.ref(false);
          vue.onMounted(async () => {
            loading.value = true;
            accounts.value = switcherStore.accounts;
            loading.value = false;
          });
          const deleteAccount = (id) => {
            globalEmitter.emit("delete-account", id);
            switcherStore.deleteAccountById(id) && message2.success("账号删除成功");
          };
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock("div", _hoisted_1$1, [
              vue.createVNode(vue.unref(NDataTable), {
                remote: "",
                "max-height": 170,
                columns,
                data: vue.unref(switcherStore).accounts,
                paging: false,
                loading: loading.value
              }, null, 8, ["data", "loading"])
            ]);
          };
        }
      });
      const AccountTable = _export_sfc(_sfc_main$4, [["__scopeId", "data-v-8f985f51"]]);
      const _sfc_main$3 = vue.defineComponent({
        __name: "EnvironmentForm",
        setup(__props) {
          const switcherStore = useSwitcherStore();
          const { message: message2 } = createDiscreteApi(["message"]);
          const formRef = vue.ref();
          const envModel = vue.ref({
            dev: "",
            beta: "",
            prod: "",
            setting: {
              incognito: false,
              newTab: false
            }
          });
          vue.onMounted(() => {
            envModel.value = {
              ...switcherStore.defaultAccount,
              setting: switcherStore.settings
            };
          });
          const devAccountOptions = vue.computed(
            () => switcherStore.devAccounts.map((account) => ({
              label: `${account.name} (${account.account})`,
              value: account.id
            }))
          );
          const betaAccountOptions = vue.computed(
            () => switcherStore.betaAccounts.map((account) => ({
              label: `${account.name} (${account.account})`,
              value: account.id
            }))
          );
          const prodAccountOptions = vue.computed(
            () => switcherStore.prodAccounts.map((account) => ({
              label: `${account.name} (${account.account})`,
              value: account.id
            }))
          );
          const handleSubmit = () => {
            const accountData = lodashExports.omit(envModel.value, ["setting"]);
            switcherStore.setDefaultAccount(accountData);
            switcherStore.setSettings(envModel.value.setting);
            message2.success("环境设置已保存");
            globalEmitter.emit("closeManage");
          };
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(NForm), {
              size: "small",
              "label-placement": "left",
              "label-width": "80",
              ref_key: "formRef",
              ref: formRef,
              model: envModel.value
            }, {
              default: vue.withCtx(() => [
                vue.createVNode(vue.unref(NFormItem), {
                  path: "dev",
                  label: "开发环境"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(NSelect), {
                      value: envModel.value.dev,
                      "onUpdate:value": _cache[0] || (_cache[0] = ($event) => envModel.value.dev = $event),
                      placeholder: "请选择开发环境默认账号",
                      clearable: true,
                      filterable: true,
                      style: { "width": "100%" },
                      options: devAccountOptions.value
                    }, null, 8, ["value", "options"])
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(NFormItem), {
                  path: "beta",
                  label: "测试环境"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(NSelect), {
                      value: envModel.value.beta,
                      "onUpdate:value": _cache[1] || (_cache[1] = ($event) => envModel.value.beta = $event),
                      placeholder: "请选择测试环境默认账号",
                      clearable: true,
                      filterable: true,
                      style: { "width": "100%" },
                      options: betaAccountOptions.value
                    }, null, 8, ["value", "options"])
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(NFormItem), {
                  path: "prod",
                  label: "生产环境"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(NSelect), {
                      value: envModel.value.prod,
                      "onUpdate:value": _cache[2] || (_cache[2] = ($event) => envModel.value.prod = $event),
                      placeholder: "请选择生产环境默认账号",
                      clearable: true,
                      filterable: true,
                      style: { "width": "100%" },
                      options: prodAccountOptions.value
                    }, null, 8, ["value", "options"])
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(NFormItem), {
                  path: "setting.newTab",
                  label: "是否新标签打开"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(NSwitch), {
                      value: envModel.value.setting.newTab,
                      "onUpdate:value": _cache[3] || (_cache[3] = ($event) => envModel.value.setting.newTab = $event)
                    }, {
                      checked: vue.withCtx(() => [..._cache[5] || (_cache[5] = [
                        vue.createTextVNode(" 新标签页打开 ", -1)
                      ])]),
                      unchecked: vue.withCtx(() => [..._cache[6] || (_cache[6] = [
                        vue.createTextVNode(" 当前标签页打开 ", -1)
                      ])]),
                      _: 1
                    }, 8, ["value"])
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(NFormItem), {
                  path: "setting.incognito",
                  label: "是否隐私窗口打开新标签页"
                }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(NSwitch), {
                      value: envModel.value.setting.incognito,
                      "onUpdate:value": _cache[4] || (_cache[4] = ($event) => envModel.value.setting.incognito = $event),
                      disabled: !envModel.value.setting.newTab
                    }, {
                      checked: vue.withCtx(() => [..._cache[7] || (_cache[7] = [
                        vue.createTextVNode(" 隐私窗口打开 ", -1)
                      ])]),
                      unchecked: vue.withCtx(() => [..._cache[8] || (_cache[8] = [
                        vue.createTextVNode(" 非隐私窗口打开 ", -1)
                      ])]),
                      _: 1
                    }, 8, ["value", "disabled"])
                  ]),
                  _: 1
                }),
                vue.createVNode(vue.unref(NFlex), { justify: "center" }, {
                  default: vue.withCtx(() => [
                    vue.createVNode(vue.unref(Button), {
                      style: { "width": "250px" },
                      type: "primary",
                      onClick: handleSubmit
                    }, {
                      default: vue.withCtx(() => [..._cache[9] || (_cache[9] = [
                        vue.createTextVNode("提交", -1)
                      ])]),
                      _: 1
                    })
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["model"]);
          };
        }
      });
      const _hoisted_1 = { class: "modal-content" };
      const _hoisted_2 = { class: "tab-content" };
      const _hoisted_3 = { class: "tab-content" };
      const _sfc_main$2 = vue.defineComponent({
        __name: "AccountManage",
        setup(__props, { expose: __expose }) {
          const dialogVisible = vue.ref(false);
          vue.onMounted(() => {
            globalEmitter.on("closeManage", () => {
              dialogVisible.value = false;
            });
          });
          const openDialog = () => {
            dialogVisible.value = true;
          };
          __expose({
            openDialog
          });
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(vue.unref(NModal), {
              preset: "dialog",
              "transform-origin": "center",
              "show-icon": false,
              show: dialogVisible.value,
              "onUpdate:show": _cache[0] || (_cache[0] = ($event) => dialogVisible.value = $event),
              style: { "min-width": "700px" }
            }, {
              default: vue.withCtx(() => [
                vue.createElementVNode("div", _hoisted_1, [
                  vue.createVNode(vue.unref(NTabs), {
                    type: "line",
                    size: "large",
                    animated: "",
                    "tabs-padding": 20,
                    "justify-content": "space-evenly"
                  }, {
                    default: vue.withCtx(() => [
                      vue.createVNode(vue.unref(NTabPane), { name: "账号列表" }, {
                        default: vue.withCtx(() => [
                          vue.createElementVNode("div", _hoisted_2, [
                            vue.createVNode(_sfc_main$5),
                            vue.createVNode(AccountTable)
                          ])
                        ]),
                        _: 1
                      }),
                      vue.createVNode(vue.unref(NTabPane), { name: "环境设置" }, {
                        default: vue.withCtx(() => [
                          vue.createElementVNode("div", _hoisted_3, [
                            vue.createVNode(_sfc_main$3)
                          ])
                        ]),
                        _: 1
                      })
                    ]),
                    _: 1
                  })
                ])
              ]),
              _: 1
            }, 8, ["show"]);
          };
        }
      });
      const AccountManage = _export_sfc(_sfc_main$2, [["__scopeId", "data-v-d1d92ceb"]]);
      const moveThreshold = 5;
      const clickTimeout = 150;
      const _sfc_main$1 = vue.defineComponent({
        __name: "EnvSwitcher",
        setup(__props) {
          const switcherStore = useSwitcherStore();
          const pos = vue.ref({ x: 0, y: 0 });
          const startPos = vue.ref({ x: 0, y: 0 });
          let offsetX = 0;
          let offsetY = 0;
          let maxX = 0;
          let maxY = 0;
          const optionsShow = vue.ref(false);
          const switcher = vue.ref(null);
          const envSwitcherBtn = vue.ref(null);
          const accountManage = vue.ref(null);
          const switchBtn = vue.ref();
          const isDragging = vue.ref(false);
          let hasMoved = false;
          let isMouseDown = false;
          let clickTimer = null;
          let animationId = null;
          let pendingX = null;
          let pendingY = null;
          vue.onMounted(() => {
            pos.value = { x: window.innerWidth - 80, y: window.innerHeight - 80 };
            switcherStore.position && (pos.value = switcherStore.position);
            maxX = window.innerWidth - envSwitcherBtn.value?.offsetWidth;
            maxY = window.innerHeight - envSwitcherBtn.value?.offsetHeight;
            document.addEventListener("mousemove", handleDocumentMouseMove);
            document.addEventListener("mouseup", handleDocumentMouseUp);
            setTimeout(
              () => switcher.value.style.transition = "all 0.3s ease",
              1e3
            );
            globalEmitter.on("addNewByEnv", () => {
              optionsShow.value = false;
              accountManage.value.openDialog();
            });
          });
          vue.onUnmounted(() => {
            document.removeEventListener("mousemove", handleDocumentMouseMove);
            document.removeEventListener("mouseup", handleDocumentMouseUp);
            document.removeEventListener("click", closeOptionsOnClickOutside);
            if (animationId) {
              cancelAnimationFrame(animationId);
            }
            if (clickTimer) {
              clearTimeout(clickTimer);
            }
          });
          const updatePosition = () => {
            if (pendingX !== null && pendingY !== null) {
              const boundedX = Math.max(0, Math.min(pendingX, maxX));
              const boundedY = Math.max(0, Math.min(pendingY, maxY));
              pos.value = { x: boundedX, y: boundedY };
              pendingX = null;
              pendingY = null;
            }
            animationId = null;
          };
          const dragStart = (e) => {
            e.preventDefault();
            console.log("mousedown");
            isMouseDown = true;
            hasMoved = false;
            switcher.value.style.transition = "none";
            startPos.value = { x: e.clientX, y: e.clientY };
            offsetX = e.clientX - switcher.value.getBoundingClientRect().left;
            offsetY = e.clientY - switcher.value.getBoundingClientRect().top;
            clickTimer = window.setTimeout(() => {
              if (isMouseDown && !hasMoved) {
                startDragging();
              }
            }, clickTimeout);
          };
          const startDragging = () => {
            isDragging.value = true;
            if (clickTimer) {
              clearTimeout(clickTimer);
              clickTimer = null;
            }
          };
          const handleDocumentMouseMove = (e) => {
            if (!isMouseDown) return;
            const moveX = Math.abs(e.clientX - startPos.value.x);
            const moveY = Math.abs(e.clientY - startPos.value.y);
            if (moveX > moveThreshold || moveY > moveThreshold) {
              hasMoved = true;
              if (!isDragging.value) {
                startDragging();
              }
              if (isDragging.value) {
                pendingX = e.clientX - offsetX;
                pendingY = e.clientY - offsetY;
                switcherStore.setPosition({
                  x: pendingX,
                  y: pendingY
                });
                if (!animationId) {
                  animationId = requestAnimationFrame(updatePosition);
                }
              }
            }
          };
          const handleDocumentMouseUp = () => {
            if (clickTimer) {
              clearTimeout(clickTimer);
              clickTimer = null;
            }
            isMouseDown = false;
            clickTimer = setTimeout(() => {
              isDragging.value = false;
            }, 300);
            hasMoved = false;
            switcher.value.style.transition = "all 0.3s ease";
          };
          const handleClick2 = () => {
            if (isDragging.value) return;
            const newValue = !optionsShow.value;
            !newValue && switchBtn.value?.closeQuickMenu();
            optionsShow.value = newValue;
            if (newValue) {
              setTimeout(() => {
                document.addEventListener("click", closeOptionsOnClickOutside);
              }, 0);
            }
          };
          const closeOptionsOnClickOutside = (e) => {
            if (switcher.value && !switcher.value.contains(e.target)) {
              optionsShow.value = false;
              document.removeEventListener("click", closeOptionsOnClickOutside);
            }
          };
          const showDialog = () => {
            optionsShow.value = false;
            accountManage.value.openDialog();
          };
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createElementBlock(vue.Fragment, null, [
              vue.createElementVNode("div", {
                ref_key: "switcher",
                ref: switcher,
                class: "env-switcher",
                style: vue.normalizeStyle({ left: pos.value.x + "px", top: pos.value.y + "px" })
              }, [
                vue.createElementVNode("div", {
                  ref_key: "envSwitcherBtn",
                  ref: envSwitcherBtn,
                  class: "env-switcher-btn",
                  onMousedown: vue.withModifiers(dragStart, ["stop"]),
                  onClick: vue.withModifiers(handleClick2, ["stop"])
                }, [..._cache[2] || (_cache[2] = [
                  vue.createElementVNode("svg", {
                    t: "1757574763114",
                    class: "icon",
                    viewBox: "0 0 1024 1024",
                    version: "1.1",
                    xmlns: "http://www.w3.org/2000/svg",
                    "p-id": "6581",
                    width: "20",
                    height: "20"
                  }, [
                    vue.createElementVNode("path", {
                      d: "M738.56 168.192l116.48 116.8a128 128 0 0 1 37.248 84.288l0.64 14.72A61.12 61.12 0 0 1 832 448H192a64 64 0 1 1 0-128h517.504l-61.312-61.376a64 64 0 0 1 90.432-90.432zM285.44 850.688l-116.48-116.864a128 128 0 0 1-37.248-84.288l-0.64-14.72a61.12 61.12 0 0 1 60.992-64H832a64 64 0 0 1 0 128l-517.504 0.064 61.312 61.376a64 64 0 0 1-90.432 90.432z",
                      fill: "#ffffff",
                      "p-id": "6582",
                      "data-spm-anchor-id": "a313x.search_index.0.i1.28003a81ISwaJq",
                      class: "selected"
                    })
                  ], -1)
                ])], 544),
                vue.createElementVNode("div", {
                  class: "account-icon",
                  onMousedown: _cache[0] || (_cache[0] = vue.withModifiers(() => {
                  }, ["stop"])),
                  onClick: vue.withModifiers(showDialog, ["stop"])
                }, [..._cache[3] || (_cache[3] = [
                  vue.createElementVNode("svg", {
                    t: "1758098433552",
                    class: "icon",
                    viewBox: "0 0 1024 1024",
                    version: "1.1",
                    xmlns: "http://www.w3.org/2000/svg",
                    "p-id": "17033",
                    width: "25",
                    height: "25"
                  }, [
                    vue.createElementVNode("path", {
                      d: "M757.700755 776.680844c0.036125-0.296225 0.065025-0.59245 0.0867-0.895901C757.65018 775.893318 757.570705 776.088393 757.700755 776.680844z",
                      fill: "#4C79ED",
                      "p-id": "17034"
                    }),
                    vue.createElementVNode("path", {
                      d: "M661.030184 417.583631c0-88.116165-71.440852-159.557017-159.549792-159.557017-88.116165 0-159.549792 71.440852-159.549792 159.557017 0 88.145065 71.433627 159.549792 159.549792 159.549792C589.589332 577.140648 661.030184 505.728695 661.030184 417.583631z",
                      fill: "#4C79ED",
                      "p-id": "17035"
                    }),
                    vue.createElementVNode("path", {
                      d: "M757.787455 775.784943c0.007225-0.007225 0.01445-0.021675 0.021675-0.0289l0.093925-1.069301C757.89583 775.055218 757.816355 775.416468 757.787455 775.784943z",
                      fill: "#4C79ED",
                      "p-id": "17036"
                    }),
                    vue.createElementVNode("path", {
                      d: "M501.545417 7.225005C224.545939 7.225005 0 231.770945 0 508.770423c0 276.977803 224.545939 501.516517 501.545417 501.516517 276.992253 0 501.538192-224.538714 501.538192-501.516517C1003.08361 231.770945 778.53767 7.225005 501.545417 7.225005zM757.715205 776.832569c-0.021675-0.079475 0-0.0867-0.01445-0.151725-0.989826 7.44898-7.282805 13.185635-14.999111 13.185635-8.409906 0-15.880562-6.777055-15.880562-15.186961-29.297396-96.706696-119.060862-167.150497-225.333465-167.150497-106.279828 0-196.484019 73.803429-225.78864 170.524575l0.411825-3.374077c0 10.078882-10.042757 15.186961-15.851662 15.186961-8.402681 0-15.194186-6.777055-15.194186-15.186961 0.4046-1.640076 0.50575-3.244027 0.968151-4.913004 0.151725-0.411825 0.21675-0.859776 0.3757-1.271601 24.817893-84.922712 90.637691-152.332012 174.780103-178.963381-64.721597-30.279997-109.64668-95.78912-109.64668-171.955126 0-104.878177 85.031087-189.945389 189.945389-189.945389 104.878177 0 189.938164 85.059987 189.938164 189.945389 0 76.166006-44.968433 141.675129-109.668355 171.940676 84.142412 26.63137 149.954985 94.055119 174.772878 178.963381 0.180625 0.411825 1.242701 5.787229 1.365526 6.19183 0.238425 0.830876 0.07225 0.946476-0.093925 1.069301L757.715205 776.832569z",
                      fill: "#4C79ED",
                      "p-id": "17037"
                    })
                  ], -1)
                ])], 32),
                vue.createVNode(SwitchBtn, {
                  show: optionsShow.value,
                  "onUpdate:show": _cache[1] || (_cache[1] = ($event) => optionsShow.value = $event),
                  parentPos: pos.value,
                  ref_key: "switchBtn",
                  ref: switchBtn
                }, null, 8, ["show", "parentPos"])
              ], 4),
              vue.createVNode(AccountManage, {
                ref_key: "accountManage",
                ref: accountManage
              }, null, 512)
            ], 64);
          };
        }
      });
      const EnvSwitcher = _export_sfc(_sfc_main$1, [["__scopeId", "data-v-e1bd9c12"]]);
      const _sfc_main = vue.defineComponent({
        __name: "App",
        setup(__props) {
          const switcherStore = useSwitcherStore();
          const env = switcherStore.currentEnv;
          const defaultAccount = switcherStore.accounts.find(
            (item) => item.id === switcherStore.defaultAccount[env]
          );
          vue.onMounted(() => {
            document.querySelector("#app")?.__vue__?.$router.afterHooks.push(
              (to, from) => {
                console.log("路由发生改变", to, from);
                if (to.name === "login" || to.path.includes("login")) {
                  fillAccount();
                }
              }
            );
            fillAccount();
          });
          const fillAccount = () => {
            if (window.location.pathname.includes("login") && !lodashExports.isEmpty(defaultAccount)) {
              let urlSearchParams = new URL(window.location.href).searchParams;
              if (urlSearchParams.has("id")) {
                let temporaryAccount = switcherStore.accounts.find(
                  (item) => item.id === urlSearchParams.get("id")
                );
                dataStorage.sessionSet("session_account", {
                  account: temporaryAccount?.account,
                  password: temporaryAccount?.password
                });
              }
              let session_account = dataStorage.sessionGet("session_account");
              !lodashExports.isEmpty(session_account) ? fillInAccount(
                session_account
              ) : fillInAccount(defaultAccount);
              clickLoginBtn();
              dataStorage.remove("session_account");
            }
          };
          return (_ctx, _cache) => {
            return vue.openBlock(), vue.createBlock(EnvSwitcher);
          };
        }
      });
      const isolationCss = ".hgj-env-switcher-wrapper{isolation:isolate!important;contain:layout style!important;position:relative!important;z-index:999999!important;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,sans-serif}.hgj-env-switcher-wrapper *,.hgj-env-switcher-wrapper *:before,.hgj-env-switcher-wrapper *:after{box-sizing:border-box!important}.hgj-env-switcher-wrapper button{font-family:inherit!important;font-size:inherit!important;line-height:inherit!important}.hgj-env-switcher-wrapper .el-button{margin:0!important}.hgj-env-switcher-wrapper .env-switcher,.hgj-env-switcher-wrapper .env-switcher *{pointer-events:auto!important}.hgj-env-switcher-wrapper [class*=flex],.hgj-env-switcher-wrapper [class*=gap-],.hgj-env-switcher-wrapper [class*=p-],.hgj-env-switcher-wrapper [class*=m-],.hgj-env-switcher-wrapper [class*=w-],.hgj-env-switcher-wrapper [class*=h-],.hgj-env-switcher-wrapper [class*=z-],.hgj-env-switcher-wrapper [class*=absolute],.hgj-env-switcher-wrapper [class*=relative],.hgj-env-switcher-wrapper [class*=fixed]{isolation:auto}";
      importCSS(isolationCss);
      if (!isInIframe() && !document.getElementById("hgj-env-switcher-root")) {
        const container = document.createElement("div");
        container.id = "hgj-env-switcher-root";
        container.style.cssText = `
    position: fixed !important;
    top: 0 !important;
    left: 0 !important;
    width: 0 !important;
    height: 0 !important;
    pointer-events: none !important;
    z-index: 999999 !important;
    overflow: visible !important;
`;
        const wrapper = document.createElement("div");
        wrapper.className = "hgj-env-switcher-wrapper";
        wrapper.style.cssText = `
    position: relative !important;
    pointer-events: auto !important;
`;
        container.appendChild(wrapper);
        document.body.appendChild(container);
        const app = vue.createApp(_sfc_main);
        app.use(createPinia());
        app.mount(wrapper);
      }
    }
  });
  require_main_001();

})(Vue);